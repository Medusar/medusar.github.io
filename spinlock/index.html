<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>自旋锁 - Medusar&#39;s playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="锁，自旋锁，Java中自旋锁，可重入自旋锁，公平的自旋锁，TicketLock，CLHLock，MCSLock，自旋锁的原理以及改进。">
<meta property="og:type" content="article">
<meta property="og:title" content="自旋锁">
<meta property="og:url" content="http://blog.onlycatch.com/spinlock/index.html">
<meta property="og:site_name" content="Medusar's playground">
<meta property="og:description" content="锁，自旋锁，Java中自旋锁，可重入自旋锁，公平的自旋锁，TicketLock，CLHLock，MCSLock，自旋锁的原理以及改进。">
<meta property="og:updated_time" content="2016-01-10T14:22:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="自旋锁">
<meta name="twitter:description" content="锁，自旋锁，Java中自旋锁，可重入自旋锁，公平的自旋锁，TicketLock，CLHLock，MCSLock，自旋锁的原理以及改进。">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/booklist">Booklist</a>
        
          <a class="main-nav-link" href="/others">Resources</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.onlycatch.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-spinlock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      自旋锁
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/spinlock/" class="article-date">
  <time datetime="2016-01-04T13:03:40.000Z" itemprop="datePublished">2016-01-04</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u4EC0_u4E48_u662F_u81EA_u65CB_u9501_uFF1F"><a href="#u4EC0_u4E48_u662F_u81EA_u65CB_u9501_uFF1F" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h2><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。<br>获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成<a href="https://en.wikipedia.org/wiki/Busy_waiting" target="_blank" rel="external">busy-waiting</a>。</p>
<h2 id="Java_u5982_u4F55_u5B9E_u73B0_u81EA_u65CB_u9501_uFF1F"><a href="#Java_u5982_u4F55_u5B9E_u73B0_u81EA_u65CB_u9501_uFF1F" class="headerlink" title="Java如何实现自旋锁？"></a>Java如何实现自旋锁？</h2><p>下面是个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Date: 2016年1月4日 下午4:41:50 &lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> medusar</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="comment">// 利用CAS</span></span><br><span class="line">		<span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">			<span class="comment">// DO nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		cas.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。   </p>
<h2 id="u81EA_u65CB_u9501_u5B58_u5728_u7684_u95EE_u9898"><a href="#u81EA_u65CB_u9501_u5B58_u5728_u7684_u95EE_u9898" class="headerlink" title="自旋锁存在的问题"></a>自旋锁存在的问题</h2><p>使用自旋锁会有以下一个问题：</p>
<ol>
<li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</li>
<li>上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。     </li>
</ol>
<h2 id="u81EA_u65CB_u9501_u7684_u4F18_u70B9"><a href="#u81EA_u65CB_u9501_u7684_u4F18_u70B9" class="headerlink" title="自旋锁的优点"></a>自旋锁的优点</h2><ol>
<li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li>
<li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li>
</ol>
<h2 id="u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501_u548C_u4E0D_u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501"><a href="#u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501_u548C_u4E0D_u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501" class="headerlink" title="可重入的自旋锁和不可重入的自旋锁"></a>可重入的自旋锁和不可重入的自旋锁</h2><p>文章开始的时候的那段代码，仔细分析一下就可以看出，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。<br>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。   </p>
<p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Date: 2016年1月4日 下午5:21:23 &lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> medusar</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantSpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="keyword">if</span> (current == cas.get()) &#123; <span class="comment">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span></span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果没获取到锁，则通过CAS自旋</span></span><br><span class="line">		<span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">			<span class="comment">// DO nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread cur = Thread.currentThread();</span><br><span class="line">		<span class="keyword">if</span> (cur == cas.get()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</span></span><br><span class="line">				count--;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。</span></span><br><span class="line">				cas.compareAndSet(cur, <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u81EA_u65CB_u9501_u7684_u5176_u4ED6_u53D8_u79CD"><a href="#u81EA_u65CB_u9501_u7684_u5176_u4ED6_u53D8_u79CD" class="headerlink" title="自旋锁的其他变种"></a>自旋锁的其他变种</h2><h3 id="1-_TicketLock"><a href="#1-_TicketLock" class="headerlink" title="1. TicketLock"></a>1. TicketLock</h3><p>TicketLock主要解决的是公平性的问题。<br>思路：每当有线程获取锁的时候，就给该线程分配一个递增的id，我们称之为排队号，同时，锁对应一个服务号，每当有线程释放锁，服务号就会递增，此时如果服务号与某个线程排队号一致，那么该线程就获得锁，由于排队号是递增的，所以就保证了最先请求获取锁的线程可以最先获取到锁，就实现了公平性。<br>可以想象成银行办理业务排队，排队的每一个顾客都代表一个需要请求锁的线程，而银行服务窗口表示锁，每当有窗口服务完成就把自己的服务号加一，此时在排队的所有顾客中，只有自己的排队号与服务号一致的才可以得到服务。<br>实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *</span><br><span class="line"> * date: 2016年1月4日 下午6:09:16 &lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> Medusar</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketLock</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 服务号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger serviceNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 排队号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger ticketNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * lock:获取锁，如果获取成功，返回当前线程的排队号，获取排队号用于释放锁. &lt;br/&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> currentTicketNum = ticketNum.incrementAndGet();</span><br><span class="line">		<span class="keyword">while</span> (currentTicketNum != serviceNum.get()) &#123;</span><br><span class="line">			<span class="comment">// Do nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> currentTicketNum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * unlock:释放锁，传入当前持有锁的线程的排队号 &lt;br/&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * <span class="doctag">@param</span> ticketnum</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">int</span> ticketnum)</span> </span>&#123;</span><br><span class="line">		serviceNum.compareAndSet(ticketnum, ticketnum + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的实现方式是，线程获取锁之后，将它的排队号返回，等该线程释放锁的时候，需要将该排队号传入。但这样是有风险的，因为这个排队号是可以被修改的，一旦排队号被不小心修改了，那么锁将不能被正确释放。一种更好的实现方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Date: 2016年1月4日 下午6:11:50 &lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> medusar</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketLockV2</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 服务号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger serviceNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 排队号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger ticketNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 新增一个ThreadLocal，用于存储每个线程的排队号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> ThreadLocal&lt;Integer&gt; ticketNumHolder = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> currentTicketNum = ticketNum.incrementAndGet();</span><br><span class="line">		<span class="comment">// 获取锁的时候，将当前线程的排队号保存起来</span></span><br><span class="line">		ticketNumHolder.set(currentTicketNum);</span><br><span class="line">		<span class="keyword">while</span> (currentTicketNum != serviceNum.get()) &#123;</span><br><span class="line">			<span class="comment">// Do nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 释放锁，从ThreadLocal中获取当前线程的排队号</span></span><br><span class="line">		Integer currentTickNum = ticketNumHolder.get();</span><br><span class="line">		serviceNum.compareAndSet(currentTickNum, currentTickNum + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的实现方式是将每个线程的排队号放到了ThreadLocal中。   </p>
<p><strong>TicketLock存在的问题</strong></p>
<blockquote>
<p>多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</p>
</blockquote>
<p>下面介绍的MCSLock和CLHLock就是解决这个问题的。</p>
<h3 id="2-_CLHLock"><a href="#2-_CLHLock" class="headerlink" title="2. CLHLock"></a>2. CLHLock</h3><p>CLH锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋，获得锁。<br>实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * CLH的发明人是：Craig，Landin and Hagersten。</span><br><span class="line"> * 代码来源：http://ifeve.com/java_lock_see2/</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 定义一个节点，默认的lock状态为true</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 尾部节点,只用一个节点即可</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;CLHNode&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class,</span><br><span class="line">			<span class="string">"tail"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 新建节点并将节点与当前线程保存起来</span></span><br><span class="line">		CLHNode node = <span class="keyword">new</span> CLHNode();</span><br><span class="line">		LOCAL.set(node);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将新建的节点设置为尾部节点，并返回旧的节点（原子操作），这里旧的节点实际上就是当前节点的前驱节点</span></span><br><span class="line">		CLHNode preNode = UPDATER.getAndSet(<span class="keyword">this</span>, node);</span><br><span class="line">		<span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 前驱节点不为null表示当锁被其他线程占用，通过不断轮询判断前驱节点的锁标志位等待前驱节点释放锁</span></span><br><span class="line">			<span class="keyword">while</span> (preNode.isLocked) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			preNode = <span class="keyword">null</span>;</span><br><span class="line">			LOCAL.set(node);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果不存在前驱节点，表示该锁没有被其他线程占用，则当前线程获得锁</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取当前线程对应的节点</span></span><br><span class="line">		CLHNode node = LOCAL.get();</span><br><span class="line">		<span class="comment">// 如果tail节点等于node，则将tail节点更新为null，同时将node的lock状态职位false，表示当前线程释放了锁</span></span><br><span class="line">		<span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="keyword">this</span>, node, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			node.isLocked = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_MCSLock"><a href="#3-_MCSLock" class="headerlink" title="3. MCSLock"></a>3. MCSLock</h3><p>MCSLock则是对本地变量的节点进行循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * MCS:发明人名字John Mellor-Crummey和Michael Scott</span><br><span class="line"> * 代码来源：http://ifeve.com/java_lock_see2/</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 节点，记录当前节点的锁状态以及后驱节点</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">volatile</span> MCSNode next;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;MCSNode&gt; NODE = <span class="keyword">new</span> ThreadLocal&lt;MCSNode&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 队列</span></span><br><span class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> MCSNode queue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// queue更新器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class,</span><br><span class="line">			<span class="string">"queue"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建节点并保存到ThreadLocal中</span></span><br><span class="line">		MCSNode currentNode = <span class="keyword">new</span> MCSNode();</span><br><span class="line">		NODE.set(currentNode);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将queue设置为当前节点，并且返回之前的节点</span></span><br><span class="line">		MCSNode preNode = UPDATER.getAndSet(<span class="keyword">this</span>, currentNode);</span><br><span class="line">		<span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果之前节点不为null，表示锁已经被其他线程持有</span></span><br><span class="line"></span><br><span class="line">			preNode.next = currentNode;</span><br><span class="line">			<span class="comment">// 循环判断，直到当前节点的锁标志位为false</span></span><br><span class="line">			<span class="keyword">while</span> (currentNode.isLocked) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		MCSNode currentNode = NODE.get();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// next为null表示没有正在等待获取锁的线程</span></span><br><span class="line">		<span class="keyword">if</span> (currentNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 更新状态并设置queue为null</span></span><br><span class="line">			<span class="keyword">if</span> (UPDATER.compareAndSet(<span class="keyword">this</span>, currentNode, <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="comment">// 如果成功了，表示queue==currentNode,即当前节点后面没有节点了</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果不成功，表示queue!=currentNode,即当前节点后面多了一个节点，表示有线程在等待</span></span><br><span class="line">				<span class="comment">// 如果当前节点的后续节点为null，则需要等待其不为null（参考加锁方法）</span></span><br><span class="line">				<span class="keyword">while</span> (currentNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果不为null，表示有线程在等待获取锁，此时将等待线程对应的节点锁状态更新为false，同时将当前线程的后继节点设为null</span></span><br><span class="line">			currentNode.next.isLocked = <span class="keyword">false</span>;</span><br><span class="line">			currentNode.next = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-_CLHLock__u548C_MCSLock"><a href="#4-_CLHLock__u548C_MCSLock" class="headerlink" title="4. CLHLock 和 MCSLock"></a>4. CLHLock 和 MCSLock</h3><ul>
<li>都是基于链表，不同的是CLHLock是基于隐式链表，没有真正的后续节点属性，MCSLock是显示链表，有一个指向后续节点的属性。</li>
<li>将获取锁的线程状态借助节点(node)保存,每个线程都有一份独立的节点，这样就解决了TicketLock多处理器缓存同步的问题。</li>
</ul>
<h2 id="u81EA_u65CB_u9501_u4E0E_u4E92_u65A5_u9501"><a href="#u81EA_u65CB_u9501_u4E0E_u4E92_u65A5_u9501" class="headerlink" title="自旋锁与互斥锁"></a>自旋锁与互斥锁</h2><ul>
<li>自旋锁与互斥锁都是为了实现保护资源共享的机制。  </li>
<li>无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</li>
<li>获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。</li>
<li>自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。</li>
<li>自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。</li>
<li>自旋锁本身无法保证公平性，同时也无法保证可重入性。</li>
<li>基于自旋锁，可以实现具备公平性和可重入性质的锁。</li>
<li>TicketLock:采用类似银行排号叫好的方式实现自旋锁的公平性，但是由于不停的读取serviceNum，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</li>
<li>CLHLock和MCSLock通过链表的方式避免了减少了处理器缓存同步，极大的提高了性能，区别在于CLHLock是通过轮询其前驱节点的状态，而MCS则是查看当前节点的锁状态。   </li>
<li>CLHLock在<a href="http://cenalulu.github.io/linux/numa/" target="_blank" rel="external">NUMA架构</a>下使用会存在问题。在没有cache的NUMA系统架构中，由于CLHLock是在当前节点的前一个节点上自旋,NUMA架构中处理器访问本地内存的速度高于通过网络访问其他节点的内存，所以CLHLock在NUMA架构上不是最优的自旋锁。</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.searchtb.com/2011/06/spinlock%E5%89%96%E6%9E%90%E4%B8%8E%E6%94%B9%E8%BF%9B.html" target="_blank" rel="external">http://www.searchtb.com/2011/06/spinlock%E5%89%96%E6%9E%90%E4%B8%8E%E6%94%B9%E8%BF%9B.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spinlock" target="_blank" rel="external">https://en.wikipedia.org/wiki/Spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Busy_waiting" target="_blank" rel="external">https://en.wikipedia.org/wiki/Busy_waiting</a></li>
<li><a href="http://blog.csdn.net/chen77716/article/details/6618779" target="_blank" rel="external">http://blog.csdn.net/chen77716/article/details/6618779</a></li>
<li><a href="http://ifeve.com/java_lock_see4/" target="_blank" rel="external">http://ifeve.com/java_lock_see4/</a></li>
<li><a href="http://ifeve.com/java_lock_see2/" target="_blank" rel="external">http://ifeve.com/java_lock_see2/</a></li>
<li><a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="external">http://coderbee.net/index.php/concurrent/20131115/577</a></li>
</ol>

      
    </div>
    
      <div class="article-toc">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u4EC0_u4E48_u662F_u81EA_u65CB_u9501_uFF1F"><span class="toc-number">1.</span> <span class="toc-text">什么是自旋锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java_u5982_u4F55_u5B9E_u73B0_u81EA_u65CB_u9501_uFF1F"><span class="toc-number">2.</span> <span class="toc-text">Java如何实现自旋锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u81EA_u65CB_u9501_u5B58_u5728_u7684_u95EE_u9898"><span class="toc-number">3.</span> <span class="toc-text">自旋锁存在的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u81EA_u65CB_u9501_u7684_u4F18_u70B9"><span class="toc-number">4.</span> <span class="toc-text">自旋锁的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501_u548C_u4E0D_u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501"><span class="toc-number">5.</span> <span class="toc-text">可重入的自旋锁和不可重入的自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u81EA_u65CB_u9501_u7684_u5176_u4ED6_u53D8_u79CD"><span class="toc-number">6.</span> <span class="toc-text">自旋锁的其他变种</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-_TicketLock"><span class="toc-number">6.1.</span> <span class="toc-text">1. TicketLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-_CLHLock"><span class="toc-number">6.2.</span> <span class="toc-text">2. CLHLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-_MCSLock"><span class="toc-number">6.3.</span> <span class="toc-text">3. MCSLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-_CLHLock__u548C_MCSLock"><span class="toc-number">6.4.</span> <span class="toc-text">4. CLHLock 和 MCSLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u81EA_u65CB_u9501_u4E0E_u4E92_u65A5_u9501"><span class="toc-number">7.</span> <span class="toc-text">自旋锁与互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u603B_u7ED3"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u53C2_u8003_u8D44_u6599"><span class="toc-number">9.</span> <span class="toc-text">参考资料</span></a></li></ol>
      </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/锁/">锁</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/broadcast-multicast-unicast/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          广播（broadcast)，组播(multicast)，单播(unicast)的Java实现
        
      </div>
    </a>
  
  
    <a href="/Reentrant-lock/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java中的可重入(Reentrant)锁&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Medusar&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>