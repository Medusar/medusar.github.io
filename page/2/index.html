<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Medusar&#39;s playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Medusar的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Medusar's playground">
<meta property="og:url" content="http://blog.onlycatch.com/page/2/index.html">
<meta property="og:site_name" content="Medusar's playground">
<meta property="og:description" content="Medusar的个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Medusar's playground">
<meta name="twitter:description" content="Medusar的个人博客">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/booklist">Booklist</a>
        
          <a class="main-nav-link" href="/others">Resources</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.onlycatch.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer">
      <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/hello-world/" class="article-date">
  <time datetime="2016-01-19T09:34:37.000Z" itemprop="datePublished">2016-01-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ shit</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    
  </div>
  
</article>


    
      <article id="post-tcp-handshakes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/tcp-handshakes/">TCP三次握手和四次握手</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/tcp-handshakes/" class="article-date">
  <time datetime="2016-01-19T08:33:33.000Z" itemprop="datePublished">2016-01-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP_u8FDE_u63A5_u5EFA_u7ACB_u65F6_u7684_u4E09_u6B21_u63E1_u624B"><a href="#TCP_u8FDE_u63A5_u5EFA_u7ACB_u65F6_u7684_u4E09_u6B21_u63E1_u624B" class="headerlink" title="TCP连接建立时的三次握手"></a>TCP连接建立时的三次握手</h2><p>TCP是面向连接的通信，所以在使用TCP通信之前，必须先建立连接。在连接正式建立之前，需要经过一个被称为“三次握手”（three-way handshake)的过程：</p>
<h3 id="u4E09_u6B21_u63E1_u624B"><a href="#u4E09_u6B21_u63E1_u624B" class="headerlink" title="三次握手"></a>三次握手</h3><p>连接建立的前提是服务端需要事先启动并监听到某个端口。</p>
<ol>
<li>客户端向服务端发送SYN报文</li>
<li>服务端收到SYN报文之后，向客户端发送确认报文ACK和SYN报文</li>
<li>客户端向服务端发送确认报文ACK<br>图解如下：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/three-way-handshake.png" alt="TCP三次握手"></li>
</ol>
<h3 id="u4E3A_u4EC0_u4E48_u9700_u8981_u4E09_u6B21_u63E1_u624B"><a href="#u4E3A_u4EC0_u4E48_u9700_u8981_u4E09_u6B21_u63E1_u624B" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><p>这个问题在网上有很多，但是我想问的是，如果不需要三次，那么需要几次呢？<br>我们可以把TCP连接建立过程想象成两个人通过qq聊天，A和B，A想和B聊天，但是A需要确认B是否能跟自己聊天，这个过程就可以用来模拟TCP连接的建立。</p>
<blockquote>
<p>A:在吗？<br>B:在的。</p>
</blockquote>
<p>首先A向B发送信息”在吗？“，就像TCP连接中的syn。<br>b收到之后，向A回复”在的“，就像TCP连接中的ack+syn。</p>
<p>其实如果是聊天，AB两句话过后就可以谈正事了。其实TCP也是这样，按道理也可以开始数据传输了，第三次就可以携带数据。但是为什么还需要三次握手呢？<br>我们都知道，TCP是提供的是数据的可靠传输。为了达到这个目的，就需要考虑各种异常情况，然后避免异常情况，对于TCP连接的建立来说，三次握手可以避免<strong>已失效的连接请求报文段</strong>突然又传到了服务端，因而产生错误。</p>
<p>假设客户端向服务端发送了请求连接的报文，但是报文丢失了，从而也没收到服务端返回的确认报文。于是客户端再次发送一个请求连接报文，而这次的报文顺利到达了服务端，服务端返回了确认报文。但是如果第一次的报文由于网络原因又到达了服务端，而这个报文已经被认为是失效的了，但是服务端是无法确定的，所以服务端还是会返回给客户端确认报文，同意建立连接，如果不采用三次握手，那么刚才的情况就会建立两个连接，而实际上只需要一个连接，这样就会造成资源浪费。<br>三次握手就解决了上面的这个问题，因为服务端还需要客户端的第二次确认，而对于上面的这种情况，客户端是知道第一个报文是废弃的，所以它就不会发送给服务端确认报文，所以就不会建立第二个连接。</p>
<p>关于三次握手我们可以想象到生活中的好多场景，比如施工的时候，需要一起协作，可能两个人会有如下对话：<br>A:准备好了吗？<br>B:准备好了<br>A:走起！<br>然后AB两人就一起做点什么事情。</p>
<h3 id="TCP_u4E09_u6B21_u63E1_u624B_u7684_u8FC7_u7A0B_u4E2D_u53EF_u4EE5_u643A_u5E26_u6570_u636E_u5417_uFF1F"><a href="#TCP_u4E09_u6B21_u63E1_u624B_u7684_u8FC7_u7A0B_u4E2D_u53EF_u4EE5_u643A_u5E26_u6570_u636E_u5417_uFF1F" class="headerlink" title="TCP三次握手的过程中可以携带数据吗？"></a>TCP三次握手的过程中可以携带数据吗？</h3><p>第一次握手和第二次握手都不能携带数据，但是都需要消耗掉一个序号。<br>第三次握手的ACK报文可以携带数据，但是如果不携带数据则不消耗序号。<br>详细了解可以参考这里：<a href="http://www.tuicool.com/articles/VJjE7bU" target="_blank" rel="external">点击</a></p>
<h2 id="TCP_u8FDE_u63A5_u65AD_u5F00_u65F6_u7684_u56DB_u6B21_u63E1_u624B"><a href="#TCP_u8FDE_u63A5_u65AD_u5F00_u65F6_u7684_u56DB_u6B21_u63E1_u624B" class="headerlink" title="TCP连接断开时的四次握手"></a>TCP连接断开时的四次握手</h2><h3 id="u56DB_u6B21_u63E1_u624B"><a href="#u56DB_u6B21_u63E1_u624B" class="headerlink" title="四次握手"></a>四次握手</h3><p>TCP连接在断开的时候也很复杂，需要四次握手：   </p>
<ol>
<li>主动发起断开请求的一方向被动方发送FIN报文</li>
<li>被动方收到报文后向主动方先发送一个ACK报文</li>
<li>被动方向主动方发送FIN报文，然后等待主动方的确认，收到主动方确认报文后断开连接。</li>
<li>主动方向被动方发送ACK报文后等待两个MSL时间后断开连接。</li>
</ol>
<p>需要注意的是:这里的描述是“主动方”和“被动方”，而不是“客户端”和”服务端”，因为发起连接关闭请求的，可以是客户端，也可以是服务端。</p>
<p>图示：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/four-way-handshake.png" alt="TCP断开时的四次握手"></p>
<p>这个过程可以想象成两个同事中午一起去吃饭，相约楼梯口见。<br>A:吃饭去?<br>B:等一下（B可能有一些事情要继续处理一下）<br>…<br>B:走！（处理完了，B告诉A可以走了）<br>A:走！（A再发一个确认）<br>A发送完最后一条消息之后，等待一会儿（2MSL)，如果B没有任何回应了，可能B已经在路上了，所以自己也就出发去电梯口了。</p>
<h3 id="u4E3A_u4EC0_u4E48_u4E3B_u52A8_u5173_u95ED_u7684_u4E00_u65B9_u6700_u540E_u8981_u7B49_u5F852MSL_u7684_u65F6_u95F4_uFF1F"><a href="#u4E3A_u4EC0_u4E48_u4E3B_u52A8_u5173_u95ED_u7684_u4E00_u65B9_u6700_u540E_u8981_u7B49_u5F852MSL_u7684_u65F6_u95F4_uFF1F" class="headerlink" title="为什么主动关闭的一方最后要等待2MSL的时间？"></a>为什么主动关闭的一方最后要等待2MSL的时间？</h3><ol>
<li>为了保证最后发送的确认报文能够到达被动方，从而可靠地实现TCP全双工连接的终止。因为这个报文有可能会丢失，如果丢失了，被动方就要重传FIN这个报文，并且主动方要能够收到重传的这个报文，而如果重传，就需要等待2MSL的时间（ACK的时间+重传的时间），所以，如果主动方不到2MSL就关闭了，那么就可能收不到被动方重传的报文，就会导致被动方无法正常关闭。</li>
<li>为了防止”已失效的连接请求报文段”出现在本连接中（允许老的重复报文在网络中消失）。主动方发完最后一个ACK报文之后，等待2MSL，就可以使本连接持续时间内所产生的所有报文都在网络中消失，这样就可以在下一次连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h2 id="TCP_u8FDE_u63A5_u671F_u95F4_u5BA2_u6237_u7AEF_u670D_u52A1_u7AEF_u72B6_u6001"><a href="#TCP_u8FDE_u63A5_u671F_u95F4_u5BA2_u6237_u7AEF_u670D_u52A1_u7AEF_u72B6_u6001" class="headerlink" title="TCP连接期间客户端服务端状态"></a>TCP连接期间客户端服务端状态</h2><h3 id="u72B6_u6001_u56FE"><a href="#u72B6_u6001_u56FE" class="headerlink" title="状态图"></a>状态图</h3><p>下面的图很好的解释了在连接建立时，建立后，连接释放时服务端和客户端的状态。<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/tcp-state.gif" alt="TCP状态图"><br>下面的图也很好<br><img src="https://upload.wikimedia.org/wikipedia/commons/a/a2/Tcp_state_diagram_fixed.svg" alt="状态图"></p>
<h3 id="TIME_WAIT_u72B6_u6001"><a href="#TIME_WAIT_u72B6_u6001" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p>TIME_WAIT状态之所以会存在，就是因为上面讲的：1）可靠地关闭TCP连接2）等待老的重复报文消失。<br>在TCP连接关闭的时候，主动关闭的一方会进入时间长达2MSL的TIME_WAIT状态，而这个状态下，连接并没有关闭。所以，如果服务器上TIME_WAIT状态的连接过多的话，可能会造成新的连接建立不了，从而影响服务器响应，可以参考这里：<a href="http://huoding.com/2013/12/31/316" target="_blank" rel="external">http://huoding.com/2013/12/31/316</a></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>《Unix网络编程 卷1：套接字联网API》</li>
<li>《计算机网络（第五版）》</li>
<li><a href="http://blog.csdn.net/wenqian1991/article/details/40110703（推荐）" target="_blank" rel="external">http://blog.csdn.net/wenqian1991/article/details/40110703（推荐）</a></li>
</ol>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/">TCP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

      </footer>
    
  </div>
  
</article>


    
      <article id="post-traffic-hijack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/traffic-hijack/">流量劫持</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/traffic-hijack/" class="article-date">
  <time datetime="2016-01-16T15:23:33.000Z" itemprop="datePublished">2016-01-16</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u6D41_u91CF_u52AB_u6301"><a href="#u6D41_u91CF_u52AB_u6301" class="headerlink" title="流量劫持"></a>流量劫持</h2><h3 id="u4EC0_u4E48_u662F_u6D41_u91CF_u52AB_u6301_uFF1F"><a href="#u4EC0_u4E48_u662F_u6D41_u91CF_u52AB_u6301_uFF1F" class="headerlink" title="什么是流量劫持？"></a>什么是流量劫持？</h3><p>流量劫持，就是通过某种手段得到我们上网的时候传输的数据，然后对这些数据进行篡改或者窥探，以达到劫持者的目的。在我们生活中最常见的应该就属运营商流量劫持了，比如我们流量一个网页的时候，如果我们输错了网址，可能就会跳到一个运营商的提示页面，提示网址错误，同时这个页面里会有运营商的一些广告等信息。<br>由于网络分为很多层，典型的OSI模型，网络分为七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。每一层都有发生流量劫持的可能。下面是常见的一些流量劫持：</p>
<ul>
<li>Hub 嗅探</li>
<li>MAC 欺骗</li>
<li>MAC 冲刷</li>
<li>ARP 攻击</li>
<li>DHCP 钓鱼</li>
<li>DNS 劫持</li>
<li>CDN 入侵</li>
<li>路由器 弱口令</li>
<li>路由器 CSRF</li>
<li>PPPoE 钓鱼</li>
<li>蜜罐代理</li>
<li>WiFi 弱口令</li>
<li>WiFi 伪热点</li>
<li>WiFi 强制断线</li>
<li>WLAN 基站钓鱼</li>
</ul>
<p>根据手段的不同，基本可以分为两类：</p>
<ol>
<li>DNS劫持：通过将通过劫持掉域名的DNS解析结果，将HTTP请求劫持到特定IP上，使得客户端和攻击者的服务器建立TCP连接，而非和目标服务器直接连接，这样攻击者就可以对内容进行窃取或篡改。在极端的情况下甚至攻击者可能伪造目标网站页面进行钓鱼攻击。</li>
<li>直接流量修改：在数据通路上对页面进行固定的内容插入，比如广告弹窗等。在这种情况下，虽然客户端和服务器是直接建立的连接，但是数据内容依然可能遭到野蛮破坏。</li>
</ol>
<h2 id="u6D41_u91CF_u52AB_u6301_u7684_u5371_u5BB3"><a href="#u6D41_u91CF_u52AB_u6301_u7684_u5371_u5BB3" class="headerlink" title="流量劫持的危害"></a>流量劫持的危害</h2><p>不同网络层次上发生的劫持造成的危害可能不太一样，但是都会造成用户信息泄露，隐私被窥探。<br>不同的劫持方式，获得的流量也有所差异。DNS劫持，只能截获通过域名发起的流量，直接使用 IP 地址的通信则不受影响；CDN入侵，只有浏览网页或下载时才有风险，其他场合则毫无问题；而网关被劫持，用户所有流量都难逃魔掌。<br>但流量劫持也有有用的一面，比如我们现在经常用的CDN，就可以算作一种流量劫持，它通过DNS解析，把域名解析到距离用户近的服务器上，减少了资源文件的响应时间。</p>
<h2 id="u5404_u79CD_u6D41_u91CF_u52AB_u6301_u7684_u539F_u7406"><a href="#u5404_u79CD_u6D41_u91CF_u52AB_u6301_u7684_u539F_u7406" class="headerlink" title="各种流量劫持的原理"></a>各种流量劫持的原理</h2><h3 id="Hub_u55C5_u63A2"><a href="#Hub_u55C5_u63A2" class="headerlink" title="Hub嗅探"></a>Hub嗅探</h3><p>Hub的工作原理是通过广播将一个接口收到的数据包群发到所有的接口上，这样任意接口都能获取到所有数据，用户隐私也就无从谈起。<br>这种设备目前唯一可用之处就是旁路嗅探。利用广播的特性，可以非常方便分析其他设备的通信，例如抓取机顶盒的数据包而不影响正常通信。</p>
<h3 id="MAC_u6B3A_u9A97_uFF08_u4EA4_u6362_u673A_uFF09"><a href="#MAC_u6B3A_u9A97_uFF08_u4EA4_u6362_u673A_uFF09" class="headerlink" title="MAC欺骗（交换机）"></a>MAC欺骗（交换机）</h3><p>交换机的工作原理与Hub不同，交换机可以绑定MAC地址和接口，数据包只发送到一个终端。但是如果没有事先配置好MAC地址和接口，而是采用自动学习的方式，即根据某个接口发出的包，自动关联该包的源地址到此接口。那么就可以被黑客通过伪造某个用户的MAC地址，而导致交换机将该用户的所有数据都发到黑客机器上。同时，被劫持的用户将无法上网。</p>
<h3 id="MAC_u51B2_u5237_uFF08_u4EA4_u6362_u673A_uFF09"><a href="#MAC_u51B2_u5237_uFF08_u4EA4_u6362_u673A_uFF09" class="headerlink" title="MAC冲刷（交换机）"></a>MAC冲刷（交换机）</h3><p>如果交换机发现了一个之前没有遇到过的MAC地址，那么就会将数据包广播到所有的接口。由于交换机的硬件配置有限，显然不可能无限多的记录地址对应条目。我们不停伪造不重复的源地址，交换机里的记录表很快就会填满，甚至覆盖原有的学习记录，用户的数据包无法正常转发，只能广播到所有接口上了。</p>
<h3 id="ARP_u653B_u51FB"><a href="#ARP_u653B_u51FB" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><p>ARP：地址解析协议，即根据IP地址，解析出对应的MAC地址。主机A为了获取主机B的对应的MAC地址，需要广播ARP数据包，包中包含了主机B的IP地址，ARP数据包会被同一链路上的所有主机和路由器接收，主机B收到数据包之后发现自己的IP地址与ARP数据包中的IP地址一致，就将自己的MAC地址响应给主机A。<br>ARP攻击就是通过冒充主机B，将自己的MAC地址抢在主机B之前发送给主机A，这样，发送到主机B的IP地址的数据就会被错误的发送给冒充方。</p>
<h3 id="DHCP_u9493_u9C7C"><a href="#DHCP_u9493_u9C7C" class="headerlink" title="DHCP钓鱼"></a>DHCP钓鱼</h3><p>DHCP（Dynamic Host Configuration Protocol):动态主机配置协议。作用是为主机动态分配IP地址。DHCP的工作机制简单来说就是需要分配IP地址的主机向DHCP服务器广播发送报文（目的地址是255.255.255.255，由于自己还没有IP地址，所以将源地址设置为0.0.0.0），在本网络上的所有主机都能收到这个广播的数据包，但是只有DHCP服务器才对此广播报文进行回答，然后该机器分配一个IP地址。如果存在多个DHCP服务器，则分别予以回复；用户则选择最先收到的。<br>DHCP钓鱼就是利用这个机制，如果一个黑客自己也启动了DHCP服务器，那么就可以收到客户主机的DHCP请求报文，如果黑客在真正的DHCP服务器返回数据之前返回一个IP地址，那么客户主机的所有数据就可以被黑客控制。</p>
<h3 id="DNS_u52AB_u6301"><a href="#DNS_u52AB_u6301" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>DNS的作用就是将域名转换成IP地址。DNS劫持就是将某个域名解析到黑客指定的IP地址，而如果黑客在此IP地址所在机器上设置了HTTP代理，那么用户将几乎看不出任何破绽，但是黑客就可以获取所有数据流量。</p>
<h3 id="CDN_u5165_u4FB5"><a href="#CDN_u5165_u4FB5" class="headerlink" title="CDN入侵"></a>CDN入侵</h3><p>CDN主要用来缓存网站的静态数据文件，以提高网站加载速度，分担网站压力。如果CDN服务器被入侵，那么落到CDN服务器上的请求响应内容就可以被篡改。有些CDN厂商不太靠谱，为了省流量不按套路出牌，超过了缓存时间也不更新，甚至还有忽略URL问号后面的参数，导致程序猿们在资源更新的问题上头疼不已。</p>
<h2 id="HTTPS_u4E0E_u6D41_u91CF_u52AB_u6301"><a href="#HTTPS_u4E0E_u6D41_u91CF_u52AB_u6301" class="headerlink" title="HTTPS与流量劫持"></a>HTTPS与流量劫持</h2><p>对于通过HTTP协议通讯的应用来说，发生流量劫持的根本原因是<strong>HTTP协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验</strong>。没有办法校验通信对方的身份，所以DNS劫持就大行其道。而无法对数据完整性进行校验旧导致了直接数据内容的篡改。而HTTPS却能解决这两个问题。<br>因为HTTPS的证书认证能够解决无法对通信对方的身份认证的问题，而内容加密传输则达到了对数据完整性校验的目的。</p>
<h3 id="HTTPS_u539F_u7406_u7B80_u4ECB"><a href="#HTTPS_u539F_u7406_u7B80_u4ECB" class="headerlink" title="HTTPS原理简介"></a>HTTPS原理简介</h3><p>HTTPS是在HTTP与TCP层之间增加了安全层，安全层是通过SSL以及其现代替代协议TLS来实现的。<br>HTTPS在请求开始之前客户端和服务器端有一个握手机制，握手的主要作用有两个：</p>
<ol>
<li>服务端认证：客户端通过判断服务端的证书是否合法有效，以决定是否信任该服务端。</li>
<li>协商秘钥：客户端服务端协商确定一个秘钥，用于数据传输过程中对数据进行加密。<br>握手过程的解释图：<br><img src="http://www.fenesky.com/images/TLS.svg" alt="tls握手图"></li>
</ol>
<p>关于HTTPS握手，可以参考下面两篇文章</p>
<ol>
<li><a href="http://www.fenesky.com/blog/2014/07/19/how-https-works.html" target="_blank" rel="external">http://www.fenesky.com/blog/2014/07/19/how-https-works.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>流量劫持可能发生在网络通讯中的多个层次。</li>
<li>流量劫持大致可以分为DNS劫持和直接内容修改两种，虽然实施的手段不同，但本质都是一样的。</li>
<li>之所以能够发生流量劫持，原因有两个：1）无法对通信双方身份做认证2）无法对数据的完整性进行校验。HTTPS能解决这个问题，但仅限于HTTP协议应用。</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://yq.aliyun.com/articles/2666" target="_blank" rel="external">http://yq.aliyun.com/articles/2666</a> （非常推荐）</li>
<li><a href="http://div.io/topic/907" target="_blank" rel="external">http://div.io/topic/907</a></li>
<li><a href="http://www.huxiu.com/article/135293/1.html" target="_blank" rel="external">http://www.huxiu.com/article/135293/1.html</a></li>
<li><a href="https://www.wosign.cn/News/Https_SSLStrip.htm" target="_blank" rel="external">https://www.wosign.cn/News/Https_SSLStrip.htm</a></li>
<li><a href="http://fex.baidu.com/blog/2014/04/traffic-hijack/(非常推荐" target="_blank" rel="external">http://fex.baidu.com/blog/2014/04/traffic-hijack/(非常推荐</a>)</li>
<li><a href="http://fex.baidu.com/blog/2014/04/traffic-hijack-2/(非常推荐" target="_blank" rel="external">http://fex.baidu.com/blog/2014/04/traffic-hijack-2/(非常推荐</a>)</li>
</ol>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/https/">https</a></li></ul>

      </footer>
    
  </div>
  
</article>


    
      <article id="post-xargs-in-linux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/xargs-in-linux/">[Linux]xargs命令</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/xargs-in-linux/" class="article-date">
  <time datetime="2016-01-14T14:45:19.000Z" itemprop="datePublished">2016-01-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="xargs_u547D_u4EE4_u7684_u4F5C_u7528"><a href="#xargs_u547D_u4EE4_u7684_u4F5C_u7528" class="headerlink" title="xargs命令的作用"></a>xargs命令的作用</h2><p>像很多人一样，我一开始的时候也迫切想知道这个命令的作用，但是到目前为止，我的确是没有用过这个命令。但是我发现别人在用这个命令，于是我便想知道这个命令的作用，于是我使用了<code>man xargs</code>。<br>它给我的解释是：<code>xargs - build and execute command lines from standard input</code>，就是从构建并且执行来自标准输入中的命令行。<br>看不懂？没错，我相信每个人刚接触这个命令的说明的收都看不懂。而且的确，这个命令也很让人迷惑。我们还是先从例子开始看吧。</p>
<h2 id="xargs_u4F7F_u7528_u4E3E_u4F8B"><a href="#xargs_u4F7F_u7528_u4E3E_u4F8B" class="headerlink" title="xargs使用举例"></a>xargs使用举例</h2><h3 id="u8BFB_u53D6_u8F93_u5165_u6570_u636E_uFF0C_u91CD_u65B0_u683C_u5F0F_u5316_u540E_u8F93_u51FA"><a href="#u8BFB_u53D6_u8F93_u5165_u6570_u636E_uFF0C_u91CD_u65B0_u683C_u5F0F_u5316_u540E_u8F93_u51FA" class="headerlink" title="读取输入数据，重新格式化后输出"></a>读取输入数据，重新格式化后输出</h3><p>假设我们有一个文本文件，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt</span><br><span class="line">a b c d e f g h</span><br><span class="line">i j k l m n o p q</span><br><span class="line">r s t u v w x y z</span><br></pre></td></tr></table></figure></p>
<p>data.txt中的文件是换行显示的。</p>
<ul>
<li><p>多行输入变成单行输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt |xargs</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>
</li>
<li><p>-n 控制多行输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt |xargs -n4</span><br><span class="line">a b c d</span><br><span class="line">e f g h</span><br><span class="line">i j k l</span><br><span class="line">m n o p</span><br><span class="line">q r s t</span><br><span class="line">u v w x</span><br><span class="line">y z</span><br></pre></td></tr></table></figure>
</li>
<li><p>-d 指定分隔符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'testAtestAtestAtest'</span>|xargs <span class="operator">-d</span>A</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">test</span> <span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># -d 与-n 一起使用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'testAtestAtestAtest'</span>|xargs <span class="operator">-d</span>A -n2</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="u8BFB_u53D6stdin_2C_u5C06_u683C_u5F0F_u5316_u540E_u7684_u53C2_u6570_u4F20_u9012_u7ED9_u67D0_u4E9B_u547D_u4EE4"><a href="#u8BFB_u53D6stdin_2C_u5C06_u683C_u5F0F_u5316_u540E_u7684_u53C2_u6570_u4F20_u9012_u7ED9_u67D0_u4E9B_u547D_u4EE4" class="headerlink" title="读取stdin,将格式化后的参数传递给某些命令"></a>读取stdin,将格式化后的参数传递给某些命令</h3><ol>
<li><p>当你尝试用rm 删除太多的文件，你可能得到一个错误信息：/bin/rm Argument list too long. 用xargs 去避免这个问题<br><code>find ~ -name ‘*.log’ -print0 | xargs -0 rm -f</code></p>
</li>
<li><p>获得/etc/ 下所有<em>.conf 结尾的文件列表，有几种不同的方法能得到相同的结果，下面的例子仅仅是示范怎么实用xargs ，在这个例子中实用 xargs将find 命令的输出传递给ls -l<br>`find /etc -name “</em>.conf” | xargs ls –l`</p>
</li>
<li><p>假如你有一个文件包含了很多你希望下载的URL, 你能够使用xargs 下载所有链接<br><code>cat url-list.txt | xargs wget –c</code></p>
</li>
<li><p>查找所有的jpg 文件，并且压缩它<br><code>find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz</code></p>
</li>
<li><p>拷贝所有的图片文件到一个外部的硬盘驱动<br><code>ls *.jpg | xargs -n1 -i cp {} /external-hard-drive/directory</code></p>
</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>In general xargs is used like this<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog | xargs utility</span><br></pre></td></tr></table></figure></p>
<p>where prog is expected to output one or more newline/space separated results. The trick is that xargs does not! nessarly call utility once for each result, instead it splits the result list into sublists and calls utility for every sublist. If you want to force xargs to call utility for every single result you will need to invoke it with xargs -L1.</p>
<p>Note that xargs promises you that the sublist sent to utility is shorter than <em>ARG_MAX</em> (this is how it avoids those dreaded Argument list to long errors). You can get the current value of <em>ARG_MAX</em> using getconf ARG_MAX</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://man.linuxde.net/xargs" target="_blank" rel="external">http://man.linuxde.net/xargs</a></li>
<li><a href="http://unix.stackexchange.com/questions/24954/when-is-xargs-needed" target="_blank" rel="external">http://unix.stackexchange.com/questions/24954/when-is-xargs-needed</a></li>
<li><a href="https://en.wikipedia.org/wiki/Xargs" target="_blank" rel="external">https://en.wikipedia.org/wiki/Xargs</a></li>
<li><a href="http://stackoverflow.com/questions/1898044/understanding-the-unix-command-xargs" target="_blank" rel="external">http://stackoverflow.com/questions/1898044/understanding-the-unix-command-xargs</a></li>
</ol>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux命令/">Linux命令</a></li></ul>

      </footer>
    
  </div>
  
</article>


    
      <article id="post-differences-between-301-302" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/differences-between-301-302/">HTTP响应码301和302的区别</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/differences-between-301-302/" class="article-date">
  <time datetime="2016-01-14T14:16:50.000Z" itemprop="datePublished">2016-01-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>301：永久重定向<br>302：临时重定向<br>302重定向与网址劫持:即A网站将自己302重定向到B网站，某些搜索引擎会收录A网站的网址，而显示的却是B网站的内容。   </p>
<p>以下内容转自：<a href="http://www.jameswxx.com/web/301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="external">http://www.jameswxx.com/web/301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB/</a><br>原文写的清晰明了，保存一份。</p>
<h2 id="u4EC0_u4E48_u662F301_u8F6C_u5411_3F_u4EC0_u4E48_u662F301_u91CD_u5B9A_u5411_3F"><a href="#u4EC0_u4E48_u662F301_u8F6C_u5411_3F_u4EC0_u4E48_u662F301_u91CD_u5B9A_u5411_3F" class="headerlink" title="什么是301转向?什么是301重定向?"></a>什么是301转向?什么是301重定向?</h2><p>301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。</p>
<h2 id="u4EC0_u4E48_u662F302_u91CD_u5B9A_u5411_3F"><a href="#u4EC0_u4E48_u662F302_u91CD_u5B9A_u5411_3F" class="headerlink" title="什么是302重定向?"></a>什么是302重定向?</h2><p>302重定向又称之为302代表暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向(temporary redirect)，一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。</p>
<h2 id="301_u91CD_u5B9A_u5411_u4E0E302_u91CD_u5B9A_u5411_u7684_u533A_u522B"><a href="#301_u91CD_u5B9A_u5411_u4E0E302_u91CD_u5B9A_u5411_u7684_u533A_u522B" class="headerlink" title="301重定向与302重定向的区别"></a>301重定向与302重定向的区别</h2><p>302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>
<h2 id="u4E3A_u4EC0_u4E48302__u91CD_u5B9A_u5411_u548C_u7F51_u5740_u52AB_u6301_u6709_u5173_u8054"><a href="#u4E3A_u4EC0_u4E48302__u91CD_u5B9A_u5411_u548C_u7F51_u5740_u52AB_u6301_u6709_u5173_u8054" class="headerlink" title="为什么302 重定向和网址劫持有关联"></a>为什么302 重定向和网址劫持有关联</h2><p>从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。</p>
<p>比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL 劫持的可能性。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p>
<p>302 重定向所造成的网址URL劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的数据中心转换中，302 重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络/">网络</a></li></ul>

      </footer>
    
  </div>
  
</article>


    
      <article id="post-queue-and-stack-implements" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/queue-and-stack-implements/">队列与栈的互相实现</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/queue-and-stack-implements/" class="article-date">
  <time datetime="2016-01-14T14:00:32.000Z" itemprop="datePublished">2016-01-14</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u5982_u4F55_u4F7F_u7528LIFO_u7684_u6808_u5B9E_u73B0_u961F_u5217FIFO_u7684_u529F_u80FD_uFF1F"><a href="#u5982_u4F55_u4F7F_u7528LIFO_u7684_u6808_u5B9E_u73B0_u961F_u5217FIFO_u7684_u529F_u80FD_uFF1F" class="headerlink" title="如何使用LIFO的栈实现队列FIFO的功能？"></a>如何使用LIFO的栈实现队列FIFO的功能？</h2><p>思路：将一个栈中的所有元素依次取出并放入另外一个栈，那么第二个栈中的元素出栈顺序就与第一个栈中元素的入栈顺序一致。<br>其实可以将栈想象成一个木桶，栈中的元素想象成大饼，如果我们将一个桶中的饼倒入另一个桶中，那么第二个桶中最上面的饼就是第一个桶中最下面的那张。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueByStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Stack&lt;String&gt; putStack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;String&gt; popStack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">		putStack.push(data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!putStack.isEmpty()) &#123;</span><br><span class="line">			popStack.push(putStack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> popStack.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5982_u4F55_u4F7F_u7528FIFO_u7684_u961F_u5217_u5B9E_u73B0LIFO_u7684_u529F_u80FD_uFF1F"><a href="#u5982_u4F55_u4F7F_u7528FIFO_u7684_u961F_u5217_u5B9E_u73B0LIFO_u7684_u529F_u80FD_uFF1F" class="headerlink" title="如何使用FIFO的队列实现LIFO的功能？"></a>如何使用FIFO的队列实现LIFO的功能？</h2><p>思路：每次存入元素的时候，都要想办法保证最后加入的元素是放在队列头部的，这样才能保证取的时候是按照LIFO的顺序。<br>可以借助汉诺塔问题思考一下。</p>
<p>下面是我写的第一个版本的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackByQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; tmpQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">			String poll = queue.poll();</span><br><span class="line">			tmpQueue.add(poll);</span><br><span class="line">		&#125;</span><br><span class="line">		queue.add(data);</span><br><span class="line">		<span class="keyword">while</span> (!tmpQueue.isEmpty()) &#123;</span><br><span class="line">			queue.add(tmpQueue.poll());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> queue.poll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后来发现效率不高，于是有了下面的升级版本(空间换时间)：<br>思路：以空间换时间，增加了一个变量，用于标记当前正在使用的队列。好处是减少了每次数据元素的拷贝。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackByQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; tmpQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> queueInUse = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (queueInUse) &#123;</span><br><span class="line">			tmpQueue.add(data);</span><br><span class="line">			switchQueue(tmpQueue, queue);</span><br><span class="line">			queueInUse = <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			queue.add(data);</span><br><span class="line">			switchQueue(queue, tmpQueue);</span><br><span class="line">			queueInUse = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">switchQueue</span><span class="params">(Queue&lt;String&gt; dest, Queue&lt;String&gt; source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!source.isEmpty()) &#123;</span><br><span class="line">			dest.add(source.poll());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (queueInUse) &#123;</span><br><span class="line">			<span class="keyword">return</span> queue.poll();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> tmpQueue.poll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

      </footer>
    
  </div>
  
</article>


    
      <article id="post-how-is-null-differs-from-equals-null-in-sql" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/how-is-null-differs-from-equals-null-in-sql/">SQL中= null与is null的区别</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/how-is-null-differs-from-equals-null-in-sql/" class="article-date">
  <time datetime="2016-01-13T14:32:24.000Z" itemprop="datePublished">2016-01-13</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>类似下面的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">field</span> = <span class="literal">null</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">field</span> <span class="keyword">IS</span> <span class="literal">null</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>第一行SQL将不会返回任何内容，而第二行将会返回field字段为NULL的行。</p>
<p>原因如下：</p>
<blockquote>
<p>在SQL中，null值与另外一个值（包括null值）的逻辑比较（=，！=，&lt;&gt;等），返回的结果也是null，而这个null值在where子句中是被当做false来看待的。null表示”未知“，所以比较的结果也是”未知“。   </p>
</blockquote>
<p>所以，上面的第一条SQL就不会返回任何内容。</p>
<p>如果在SQL中，需要判断某个字段是否为NULL，需要用IS NULL或者 IS NOT NULL,而不能使用=null或者！=null或者&lt;&gt;null。</p>
<p>参考资料：<br><a href="http://jackyrong.iteye.com/blog/2076933" target="_blank" rel="external">http://jackyrong.iteye.com/blog/2076933</a><br><a href="http://stackoverflow.com/questions/9581745/sql-is-null-and-null" target="_blank" rel="external">http://stackoverflow.com/questions/9581745/sql-is-null-and-null</a><br><a href="http://www.w3schools.com/sql/sql_null_values.asp" target="_blank" rel="external">http://www.w3schools.com/sql/sql_null_values.asp</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQl/">MySQl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/">SQL</a></li></ul>

      </footer>
    
  </div>
  
</article>


    
      <article id="post-java-thread-communication" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/java-thread-communication/">java线程间通信</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/java-thread-communication/" class="article-date">
  <time datetime="2016-01-10T07:16:25.000Z" itemprop="datePublished">2016-01-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u5171_u4EAB_u5185_u5B58"><a href="#u5171_u4EAB_u5185_u5B58" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存在java多线程中的应用是很频繁的，最简单的例子就是共享变量，即多个线程都读或者写一个变量的值。</p>
<h3 id="volatile_u548Csynchronized_u5173_u952E_u5B57"><a href="#volatile_u548Csynchronized_u5173_u952E_u5B57" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h3><p>volatile关键字：保证了内存可见性，能够保证多个线程在读取volatile修饰的变量时，读取到的数据都是最新的。<br>volatile的写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主存。<br>volatile的读：当读一个volatile变量时，JMM会把线程对应的本地内存置为无效，然后从主存中读取共享变量。</p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

      </footer>
    
  </div>
  
</article>


    
      <article id="post-thread-state-and-analysis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/thread-state-and-analysis/">java中线程的状态以及线程栈分析</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/thread-state-and-analysis/" class="article-date">
  <time datetime="2016-01-10T04:18:38.000Z" itemprop="datePublished">2016-01-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="java_u4E2D_u7EBF_u7A0B_u7684_u72B6_u6001"><a href="#java_u4E2D_u7EBF_u7A0B_u7684_u72B6_u6001" class="headerlink" title="java中线程的状态"></a>java中线程的状态</h2><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态。线程刚刚被创建，并且start()方法还未被调用</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态。表示线程正在java虚拟机中执行，但是可能正在等待操作系统的其他资源，比如CPU</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态。表示线程正在等待监视器锁。表示线程正在等待获取监视器锁，以便进入同步方法或者同步代码快，也有可能是从wait（）方法被唤醒而等待再次进入同步方法或者同步代码块</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态。表示当前线程需要等待其他线程执行一些特殊操作，比如当前线程调用了a.wait()方法，它正在等待其他线程调用a.notify或a.notifyAll方法;如果当前线程调用了threada.join(),那么它在等待threada执行完成</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>超时等待。与WAITING的不同在于，该状态有超时时间</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<p>详细介绍：参考Thread内部类:State</p>
<p>WAITING与TIMED_WAITING:<br>调用以下三个方法会进入WAITING状态：</p>
<ul>
<li>Object.wait() 不设置超时时间</li>
<li>Thread.join() 不设置超时时间</li>
<li>LockSupport.park() 不设置超时时间<br>调用下面的方法会进入TIMED_WAITING状态：</li>
<li>Object.wait(time)</li>
<li>Thread.join(time)</li>
<li>Thread.sleep(time)</li>
<li>LockSupport.parkNanos(time)</li>
<li>LockSupport.parkUntil(time)</li>
</ul>
<h2 id="u901A_u8FC7jstack_u67E5_u770B_u7EBF_u7A0B_u72B6_u6001"><a href="#u901A_u8FC7jstack_u67E5_u770B_u7EBF_u7A0B_u72B6_u6001" class="headerlink" title="通过jstack查看线程状态"></a>通过jstack查看线程状态</h2><p>jstack 是一个可以用来打印java进程中的线程堆栈信息的工具。一般都位于jdk安装目录的bin目录下。<br>一般，jstack都用来检测死锁，以及分析当前程序运行状态。</p>
<h3 id="u4F7F_u7528_u65B9_u5F0F"><a href="#u4F7F_u7528_u65B9_u5F0F" class="headerlink" title="使用方式"></a>使用方式</h3><p>jstack [options] pid<br>pid:即进程id，可以通过jps命令查看<br>options:可选选项。一般常用的是-l和-m，-l用于打印详细的堆栈信息，包括当前线程获得到的同步器(AbstractOwnableSynchronizer)。-m则会打印包含C++或C的堆栈信息。</p>
<p>例如：<br>命令：<code>jstack 10968</code> 则会把进程号为10968的进程所包含的线程信息打印出来。<br>其中的部分结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fab88009800 nid=0x2add waiting on condition [0x00007fab8ee92000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">	at test.DeadLockTest.main(DeadLockTest.java:17)</span><br></pre></td></tr></table></figure></p>
<p>命令：<code>jstack -l 10968</code>则会包含当前线程获取到的同步器。<br>其中的部分结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fab88009800 nid=0x2add waiting on condition [0x00007fab8ee92000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">	at test.DeadLockTest.main(DeadLockTest.java:17)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure></p>
<p>可以看到，带-l参数的，在线程信息后面有个’ Locked ownable synchronizers:’信息。</p>
<p>关于jstack的使用，下面两篇文章写的很不错，非常建议一看:</p>
<ol>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps" target="_blank" rel="external">java-thread-dumps</a></li>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps-2" target="_blank" rel="external">java-thread-dumps-2</a></li>
</ol>
<h3 id="u4E0D_u540C_u7EBF_u7A0B_u72B6_u6001_u5728jstack_u4FE1_u606F_u4E2D_u5F62_u5F0F"><a href="#u4E0D_u540C_u7EBF_u7A0B_u72B6_u6001_u5728jstack_u4FE1_u606F_u4E2D_u5F62_u5F0F" class="headerlink" title="不同线程状态在jstack信息中形式"></a>不同线程状态在jstack信息中形式</h3><p>我们来看一下，当线程处于不同状态的时候，通过jstack看到的是什么样子的。</p>
<h4 id="WAITING_u72B6_u6001"><a href="#WAITING_u72B6_u6001" class="headerlink" title="WAITING状态"></a>WAITING状态</h4><p>通过上面的讲解我们知道，线程进入waiting状态可以通过三种方式：1.Object.wait,2.Thread.join,3.LockSupport.park ，那么我们分别来看下，当程序分别通过这三种方式进入WAITING状态的时候，对应的jstack信息是怎样的。</p>
<p>1.Object.wait方式<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// Object.wait</span></span><br><span class="line">		<span class="keyword">synchronized</span> (WaitingTest.class) &#123;</span><br><span class="line">			WaitingTest.class.wait();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack 结果(省略其他部分，下同):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f384c009800 nid=0x2d9c in Object.wait() [0x00007f385268b000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6ddb9a0</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br><span class="line">	at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddb9a0</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br></pre></td></tr></table></figure></p>
<p>2.Thread.join方式<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// Thread.join</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"run"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span> * <span class="number">300</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前线程调用thread线程的join方法</span></span><br><span class="line">		thread.join();</span><br><span class="line">		<span class="comment">// 只有thread的run方法执行完成之后，才会执行输出</span></span><br><span class="line">		System.out.println(<span class="string">"Current thread running"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f88cc009800 nid=0x2f10 in Object.wait() [0x00007f88d5b73000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6ddddf8</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1245</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddddf8</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1319</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>3.LockSupport.park方式<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		LockSupport.park();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f6efc009800 nid=0x2f88 waiting on condition [0x00007f6f034dd000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">304</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h4 id="TIMED_WAITING"><a href="#TIMED_WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>1.Object.wait(time)<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (WaitingTest.class) &#123;</span><br><span class="line">			WaitingTest.class.wait(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007fd598009800 nid=0x301b in Object.wait() [0x00007fd59eea0000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6ddb9b8</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">9</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddb9b8</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>2.Thread.join(time)<br>代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// Thread.join</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"run"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span> * <span class="number">300</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前线程调用thread线程的join方法</span></span><br><span class="line">		thread.join(<span class="number">1000</span> * <span class="number">200</span>);</span><br><span class="line">		<span class="comment">// 只有thread的run方法执行完成之后，才会执行输出</span></span><br><span class="line">		System.out.println(<span class="string">"Current thread running"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f024c009800 nid=0x365c in Object.wait() [0x00007f0254768000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6dddf40</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1253</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6dddf40</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>3.Thread.sleep<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	Thread.currentThread().sleep(<span class="number">1000</span> * <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f54a8009800 nid=0x36eb waiting on condition [0x00007f54ae463000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>4.LockSupport.parkNanos(time) 和 LockSupport.parkUntil(time) 两个方法类似<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	LockSupport.parkNanos(Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007eff98009800 nid=0x37b6 waiting on condition [0x00007effa0141000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:<span class="number">338</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h4 id="BLOCKED_u72B6_u6001"><a href="#BLOCKED_u72B6_u6001" class="headerlink" title="BLOCKED状态"></a>BLOCKED状态</h4><p>BLOCKED状态，表示线程正在等待监视器锁。我们可以通过一个死锁的例子来分析。<br>例子很简单，程序中有两个Waiter线程，WaiterA和WaitB，它们都需要获取两个锁：lock_1和lock_2,但是它们获取锁的顺序不同，因此导致了死锁。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object lock_1 = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object lock_2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> WaiterA().start();</span><br><span class="line">		<span class="keyword">new</span> WaiterB().start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaiterA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 先获取lock_1,然后再获取lock_2</span></span><br><span class="line">			<span class="keyword">synchronized</span> (lock_1) &#123;</span><br><span class="line">				System.out.println(<span class="string">"lock1 get,wait to get lock2"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">synchronized</span> (lock_2) &#123;</span><br><span class="line">					System.out.println(<span class="string">"lock2 get"</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaiterB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 先获取lock_2,然后再获取lock_1</span></span><br><span class="line">			<span class="keyword">synchronized</span> (lock_2) &#123;</span><br><span class="line">				System.out.println(<span class="string">"lock2 get,wait to get lock1"</span>);</span><br><span class="line">				<span class="keyword">synchronized</span> (lock_1) &#123;</span><br><span class="line">					System.out.println(<span class="string">"lock1 get"</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Thread-1"</span> <span class="comment">#10 prio=5 os_prio=0 tid=0x00007f0d800dc800 nid=0x39da waiting for monitor entry [0x00007f0d47bfa000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at test.WaitingTest$WaiterB.run(WaitingTest.java:<span class="number">47</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="string">"Thread-0"</span> <span class="comment">#9 prio=5 os_prio=0 tid=0x00007f0d800da800 nid=0x39d9 waiting for monitor entry [0x00007f0d47cfb000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at test.WaitingTest$WaiterA.run(WaitingTest.java:<span class="number">27</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，上面Thread-1 和Thread-0的状态都是Blocked，原因是它们都在等待监视器锁，而Thread-1 已经获取到了锁0x00000000d6ddc520，正在等待获取0x00000000d6ddc510锁，而0x00000000d6ddc510锁已经被Thread-0获取到了，Thread-0反过来又正在等待获取0x00000000d6ddc520，而这个锁又被Thread-1获取了。<br>在jstack的最后，还有如下信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f0d50004ed8</span> (object <span class="number">0x00000000d6ddc510</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held by <span class="string">"Thread-0"</span></span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f0d500062c8</span> (object <span class="number">0x00000000d6ddc520</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held by <span class="string">"Thread-1"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">	at test.WaitingTest$WaiterB.run(WaitingTest.java:<span class="number">47</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">	at test.WaitingTest$WaiterA.run(WaitingTest.java:<span class="number">27</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure></p>
<p>就是说，已经发现了一个死锁，还有就是关于死锁的详细说明。</p>
<h4 id="RUNNABLE_u72B6_u6001"><a href="#RUNNABLE_u72B6_u6001" class="headerlink" title="RUNNABLE状态"></a>RUNNABLE状态</h4><p>我们写一个BIO的server端，server端绑定一个端口，并通过accept()方法等待客户端链接。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">		ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Socket socket = serverSocket.accept();</span><br><span class="line">			<span class="comment">// do something else</span></span><br><span class="line">			<span class="comment">// ....</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f4b58009800 nid=0x3ab8 runnable [0x00007f4b5ff64000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class="line">	at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class="number">409</span>)</span><br><span class="line">	at java.net.ServerSocket.implAccept(ServerSocket.java:<span class="number">545</span>)</span><br><span class="line">	at java.net.ServerSocket.accept(ServerSocket.java:<span class="number">513</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，此时虽然程序在等待客户端接入，但是程序状态依然是RUNNABLE的。</p>
<h4 id="TERMINATED_u548CNEW_u72B6_u6001"><a href="#TERMINATED_u548CNEW_u72B6_u6001" class="headerlink" title="TERMINATED和NEW状态"></a>TERMINATED和NEW状态</h4><p>这两个状态分别表示线程生命终结和生命开始，在jstack中没有对应的信息显示。</p>
<h4 id="u603B_u7ED3_uFF1A"><a href="#u603B_u7ED3_uFF1A" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>WAITING和TIMED_WAITING的主要不同就在于后者在等待的时候设置了超时时间</li>
<li>通过Object.wait，Thread.join两种方式进入的WAITING或者TIMED_WAITING,通过jstack查看显示的都是wait on monitor,而通过其他方式（Thread.sleep,LockSupport等）进入的WAITING或者TIMED_WAITING,通过jstack查看显示的都是waiting on condition。</li>
<li>BLOCKED状态，通过jstack查看，显示的是waiting for monitor entry，注意与WAITING和TIMED_WAITING的区别。</li>
</ol>
<h2 id="java_u7EBF_u7A0B_u72B6_u6001_u4E4B_u95F4_u7684_u8F6C_u6362"><a href="#java_u7EBF_u7A0B_u72B6_u6001_u4E4B_u95F4_u7684_u8F6C_u6362" class="headerlink" title="java线程状态之间的转换"></a>java线程状态之间的转换</h2><p>java线程通过不同的方法调用进入不同的状态，下面图描述的很清楚：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/state-machine-example-java-6-thread-states.png" alt="java线程状态转换UML"></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps" target="_blank" rel="external">https://sites.google.com/site/threaddumps/java-thread-dumps</a></li>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps-2" target="_blank" rel="external">https://sites.google.com/site/threaddumps/java-thread-dumps-2</a></li>
<li>图片来源：<a href="http://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html" target="_blank" rel="external">http://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html</a></li>
</ol>
<p>顺便推荐个很好的网站：<br>Java中的UML图：<a href="http://www.uml-diagrams.org/examples/java-uml-examples.html" target="_blank" rel="external">http://www.uml-diagrams.org/examples/java-uml-examples.html</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Troubleshooting-Tools/">Troubleshooting Tools</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jstack/">jstack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程/">线程</a></li></ul>

      </footer>
    
  </div>
  
</article>


    
      <article id="post-what-if-exception-occurs-in-threadpool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/what-if-exception-occurs-in-threadpool/">Java线程池异常处理最佳实践</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/what-if-exception-occurs-in-threadpool/" class="article-date">
  <time datetime="2016-01-07T13:37:30.000Z" itemprop="datePublished">2016-01-07</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>问题描述：<br>假设我们有一个线程池，由于程序需要，我们向该线程池中提交了好多任务，但是这些任务都没有对异常进行try catch处理，并且运行的时候都抛出了异常。这会对线程池的运行带来什么影响？</p>
</blockquote>
<p>正确答案是：没有影响。<br>想一下，如果是你开发了一个线程池供开发者使用，你会不会对这种情况做处理？想想也是肯定的，不然你提供给别人使用的东西就是有问题的，欠考虑的。而且java线程池的主要开发人员是大名鼎鼎的Doug Lea，你觉得他开发的代码怎么会允许出现这种问题？</p>
<h2 id="u95EE_u9898_u5206_u6790"><a href="#u95EE_u9898_u5206_u6790" class="headerlink" title="问题分析"></a>问题分析</h2><p>接下来我们来看一下java中的线程池是如何运行我们提交的任务的，详细流程比较复杂，这里我们不关注，我们只关注任务执行的部分。java中的线程池用的是ThreadPoolExecutor，真正执行代码的部分是runWorker方法：<code>final void runWorker(Worker w)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略无关部分</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    beforeExecute(wt, task);  </span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run();  <span class="comment">//执行程序逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123; <span class="comment">//捕获RuntimeException</span></span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error x) &#123; <span class="comment">//捕获Error</span></span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;   <span class="comment">//捕获Throwable</span></span><br><span class="line">        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterExecute(task, thrown);  <span class="comment">//运行完成，进行后续处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    task = <span class="keyword">null</span>;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略无关部分</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，程序会捕获包括Error在内的所有异常，并且在程序最后，将出现过的异常和当前任务传递给afterExecute方法。</p>
<p>而ThreadPoolExecutor中的afterExecute方法是没有任何实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，默认情况下，线程池会捕获任务抛出的所有异常，但是不做任何处理。</p>
<h2 id="u5B58_u5728_u95EE_u9898"><a href="#u5B58_u5728_u95EE_u9898" class="headerlink" title="存在问题"></a>存在问题</h2><p>想象下ThreadPoolExecutor这种处理方式会有什么问题？<br>这样做能够保证我们提交的任务抛出了异常不会影响其他任务的执行，同时也不会对用来执行该任务的线程产生任何影响。<br>问题就在<code>afterExecute</code>方法上，这个方法没有做任何处理，所以如果我们的任务抛出了异常，我们也无法立刻感知到。即使感知到了，也无法查看异常信息。</p>
<p>所以，作为一名好的开发者，是不应该允许这种情况出现的。</p>
<h2 id="u5982_u4F55_u907F_u514D_u8FD9_u79CD_u95EE_u9898"><a href="#u5982_u4F55_u907F_u514D_u8FD9_u79CD_u95EE_u9898" class="headerlink" title="如何避免这种问题"></a>如何避免这种问题</h2><p>思路很简单。</p>
<ol>
<li>在提交的任务中将异常捕获并处理，不抛给线程池。</li>
<li>异常抛给线程池，但是我们要及时处理抛出的异常。</li>
</ol>
<p>第一种思路很简单，就是我们提交任务的时候，将所有可能的异常都Catch住，并且自己处理，任务的大致代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//处理所有的业务逻辑</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="comment">//打印日志等</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//其他处理</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>说白了就是把业务逻辑都trycatch起来。<br>但是这种思路的缺点就是：1）所有的不同任务类型都要trycatch，增加了代码量。2）不存在checkedexception的地方也需要都trycatch起来，代码丑陋。</p>
<p>第二种思路就可以避免上面的两个问题。<br>第二种思路又有以下几种实现方式：</p>
<ol>
<li>自定义线程池，继承ThreadPoolExecutor并复写其<code>afterExecute(Runnable r, Throwable t)</code>方法。</li>
<li>实现Thread.UncaughtExceptionHandler接口，实现<code>void uncaughtException(Thread t, Throwable e);</code>方法，并将该handler传递给线程池的ThreadFactory</li>
<li>采用Future模式，将返回结果以及异常放到Future中，在Future中处理</li>
<li>继承ThreadGroup，覆盖其uncaughtException方法。（与第二种方式类似，因为ThreadGroup类本身就实现了Thread.UncaughtExceptionHandler接口)</li>
</ol>
<p>下面是以上几种方式的代码</p>
<h3 id="u65B9_u5F0F1"><a href="#u65B9_u5F0F1" class="headerlink" title="方式1"></a>方式1</h3><p>自定义线程池：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The values have been hard-coded for brevity</span></span><br><span class="line">  ExecutorService pool = <span class="keyword">new</span> CustomThreadPoolExecutor(</span><br><span class="line">      <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... Constructor ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CustomThreadPoolExecutor</span><span class="params">(</span><br><span class="line">      <span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">      TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Exception occurred, forward to handler</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... Perform task-specific cleanup actions</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.terminated();</span><br><span class="line">    <span class="comment">// ... Perform final clean-up actions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u65B9_u5F0F2"><a href="#u65B9_u5F0F2" class="headerlink" title="方式2"></a>方式2</h3><p>实现Thread.UncaughtExceptionHandler接口，实现<code>void uncaughtException(Thread t, Throwable e);</code>方法，并将该handler传递给线程池的ThreadFactory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory factory =</span><br><span class="line">      <span class="keyword">new</span> ExceptionThreadFactory(<span class="keyword">new</span> MyExceptionHandler());</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService pool =</span><br><span class="line">      Executors.newFixedThreadPool(<span class="number">10</span>, factory);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Task()); <span class="comment">// Task is a runnable class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory defaultFactory =</span><br><span class="line">        Executors.defaultThreadFactory();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread.UncaughtExceptionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExceptionThreadFactory</span><span class="params">(</span><br><span class="line">        Thread.UncaughtExceptionHandler handler)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable run)</span> </span>&#123;</span><br><span class="line">      Thread thread = defaultFactory.newThread(run);</span><br><span class="line">      thread.setUncaughtExceptionHandler(handler);</span><br><span class="line">      <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ExceptionReporter</span></span><br><span class="line">      <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Recovery or logging code</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u65B9_u5F0F3"><a href="#u65B9_u5F0F3" class="headerlink" title="方式3"></a>方式3</h3><p>继承ThreadGroup，覆盖其uncaughtException方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadGroup</span> <span class="keyword">extends</span> <span class="title">ThreadGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThreadGroup</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + thread.getName()</span><br><span class="line">              + <span class="string">" died, exception was: "</span>);</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadGroup workerThreads =</span><br><span class="line">      <span class="keyword">new</span> MyThreadGroup(<span class="string">"Worker Threads"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(workerThreads, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> WorkerThread(<span class="string">"Worker Thread"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>确实这种方式与上面通过ThreadFactory来指定UncaughtExceptionHandler是一样的，只是代码逻辑不同，但原理上都是一样的，即给线程池中的每个线程都指定一个UncaughtExceptionHandler。</p>
<p><strong> 注意：上面三种方式针对的都是通过execute(xx)的方式提交任务，如果你提交任务用的是submit()方法，那么上面的三种方式都将不起作用,而应该使用下面的方式 </strong></p>
<h3 id="u65B9_u5F0F4"><a href="#u65B9_u5F0F4" class="headerlink" title="方式4"></a>方式4</h3><p>如果提交任务的时候使用的方法是submit，那么该方法将返回一个Future对象，所有的异常以及处理结果都可以通过future对象获取。<br>采用Future模式，将返回结果以及异常放到Future中，在Future中处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Future&lt;?&gt; future = pool.submit(<span class="keyword">new</span> Task());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      future.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt(); <span class="comment">// Reset interrupted status</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      Throwable exception = e.getCause();</span><br><span class="line">      <span class="comment">// Forward to exception reporter</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>java线程池会捕获任务抛出的异常和错误，但不做任何处理</li>
<li>好的程序设计应该考虑到对于类异常的处理</li>
<li>处理线程池中的异常有两种思路：<br>1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池<br>2）由线程池统一处理</li>
<li>对于execute方法提交的线程，有两种处理方式<br>1）自定义线程池并实现afterExecute方法<br>2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。</li>
<li>对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。</li>
</ol>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程池/">线程池</a></li></ul>

      </footer>
    
  </div>
  
</article>


    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
      </nav>
    </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Medusar&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>