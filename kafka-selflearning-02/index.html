<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kafka学习笔记之高性能设计 - Medusar&#39;s playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Kafka在设计过程中的为了追求高性能而做的一些处理">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka学习笔记之高性能设计">
<meta property="og:url" content="http://blog.onlycatch.com/kafka-selflearning-02/index.html">
<meta property="og:site_name" content="Medusar's playground">
<meta property="og:description" content="Kafka在设计过程中的为了追求高性能而做的一些处理">
<meta property="og:updated_time" content="2016-01-25T13:15:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kafka学习笔记之高性能设计">
<meta name="twitter:description" content="Kafka在设计过程中的为了追求高性能而做的一些处理">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo" href="/"></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/booklist">Booklist</a>
        
          <a class="main-nav-link" href="/others">Resources</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.onlycatch.com"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-kafka-selflearning-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Kafka学习笔记之高性能设计
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/kafka-selflearning-02/" class="article-date">
  <time datetime="2016-01-25T12:03:52.000Z" itemprop="datePublished">2016-01-25</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">编程</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u6301_u4E45_u5316"><a href="#u6301_u4E45_u5316" class="headerlink" title="持久化"></a>持久化</h2><p>kafka非常依赖文件系统进行消息存储和缓存。大部分人会认为“磁盘很慢”，所以很多人会怀疑持久化是否能够提供很好的性能。实际上磁盘速度的快慢与磁盘的使用方式有着很大关系，设计好的磁盘结构通常会很快。</p>
<p>对于磁盘的线性读写操作在很多系统中都进行了大量优化，在某些情况下，对于磁盘的顺序访问甚至比对于内存的随机访问还要快！</p>
<p>很多现代操作系统都大量使用主存做磁盘缓存，一个现代操作系统可以将内存中的所有剩余空间用作磁盘缓存，而当内存回收的时候几乎没有性能损失。所有的磁盘读写都会经过这个统一的缓存。哪怕使用directI/O，这个特性也很难被关闭，所以如果某个进程维护了一份进程内缓存，那么这部分数据很可能也在操作系统的页面缓存中存在。</p>
<p>由于kafka是基于JVM的，并且任何与java内存使用打过交道的人都知道两件事：</p>
<ol>
<li>对象的内存开销非常高，通常是实际要存储数据大小的两倍</li>
<li>随着数据的增加，java的垃圾收集也会越来越频繁并且缓慢<br>基于此，使用文件系统，同时依赖页面缓存就比使用其他数据结构和维护内存缓存更有吸引力：</li>
<li>不使用进程内缓存，就腾出了内存空间，可以用来存放页面缓存的空间几乎可以翻倍。</li>
<li>如果kafka重启，进行内缓存就会丢失，但是使用操作系统的页面缓存依然可以继续使用。</li>
</ol>
<p>kafka如此频繁利用页面缓存，如果内存大小不够了怎么办？kafka会将数据写入到持久化日志中而不是刷新到磁盘。实际上它只是转移到了内核的页面缓存。</p>
<h2 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="http://kafka.apache.org/documentation.html#design_constanttime" target="_blank" rel="external">http://kafka.apache.org/documentation.html#design_constanttime</a></p>
<h2 id="u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C_u548C_u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D"><a href="#u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C_u548C_u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D" class="headerlink" title="大量的小IO操作和大量的字节拷贝"></a>大量的小IO操作和大量的字节拷贝</h2><p>除了上面说的磁盘读写影响性能之外，另外两个影响性能的就是：</p>
<ol>
<li>大量的IO操作</li>
<li>大量的字节拷贝</li>
</ol>
<h3 id="u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C"><a href="#u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C" class="headerlink" title="大量的小IO操作"></a>大量的小IO操作</h3><p>对于消息服务端来说，写操作是很频繁的，为了避免这个问题，kafka的协议是基于一种“消息集合”的抽象，它允许网络请求将消息集中发送而不是每次发送一条消息。服务端同样，也是一次性将一组消息写入日志，消费者也是每次取一大块。</p>
<p>这样做能够产生更大的网络数据包，更大的连续磁盘操作以及连续的内存块，这些都使得kafka更容易将大量随机消息编程线性的写操作。</p>
<h3 id="u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D"><a href="#u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D" class="headerlink" title="大量的字节拷贝"></a>大量的字节拷贝</h3><p>kafka消费者，生产者还有服务端使用的日志格式都是一样的。这样做的好处就是能够为网络传输数据块提供最大的优化。</p>
<p>一般来讲，将文件中的数据转移到Socket需要经过以下几步：</p>
<ol>
<li>操作系统将数据从磁盘读到内核空间的页面缓存中</li>
<li>应用程序从内核空间将数据读取到用户空间</li>
<li>应用程序将数据重新写入到内核空间中的socket缓存中</li>
<li>操作系统将数据从socket缓存中拷贝到网卡缓存中（网卡缓存中的数据将被发送到网络中）</li>
</ol>
<p>上面的过程经过了四次拷贝和两次系统调用，明显这是不高效的。<br>通过使用sendfile API,允许操作系统直接从页面缓存将数据发送到网络，就减少了不必要的拷贝，只有最后一步：将数据拷贝到网卡缓存是必须的。</p>
<p>假设某个Topic有多个消费者，使用上面的零拷贝技术，数据只会被拷贝一次进入页面缓存，每次消费都可以被重复使用。这样就避免了每次读的时候都将数据存到内存中然后拷贝到内核空间。</p>
<h2 id="u7AEF_u5230_u7AEF_u6279_u91CF_u538B_u7F29"><a href="#u7AEF_u5230_u7AEF_u6279_u91CF_u538B_u7F29" class="headerlink" title="端到端批量压缩"></a>端到端批量压缩</h2><p>在很多情况下，系统的瓶颈不是CPU而是带宽。所以数据压缩就很重要。<br>可以每个消息都压缩，但是压缩率相对很低。所以kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩。<br>kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩。<br>kafka支持Gzip和Snappy压缩协议。</p>
<h2 id="u751F_u4EA7_u8005"><a href="#u751F_u4EA7_u8005" class="headerlink" title="生产者"></a>生产者</h2><h3 id="u8D1F_u8F7D_u5747_u8861"><a href="#u8D1F_u8F7D_u5747_u8861" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>生产者直接将数据发送到broker中，中间不会经过任何路由层。<br>为了达到这个目的，所有的kafka节点都能在任何时候回答是否服务器可以用以及主题分区的leader机器在哪里等问题，以便于生产者正确的发送数据。</p>
<p>生产者客户端控制着消息发往哪个分区。可以通过随机负载均衡或者其他分区语义功能来实现。kafka提供了分区语义接口允许用户指定一个用户哈希分析的字段。</p>
<h3 id="u5F02_u6B65_u53D1_u9001"><a href="#u5F02_u6B65_u53D1_u9001" class="headerlink" title="异步发送"></a>异步发送</h3><p>为了实现批量发送，kafka需要在内存中积累数据，以便于在单次请求中发送足够大的数据。可以通过配置消息数量不超过某个值或者等待时间不超过某个值来进行控制。</p>
<h2 id="u6D88_u8D39_u8005"><a href="#u6D88_u8D39_u8005" class="headerlink" title="消费者"></a>消费者</h2><p>消费者通过指定log的offset来获取消息，每次取回一块以指定的offset开始的消息块。</p>
<h3 id="u63A8_vs-__u62C9"><a href="#u63A8_vs-__u62C9" class="headerlink" title="推 vs. 拉"></a>推 vs. 拉</h3><p>在kafka中，消息是被消费者推到broker的，然后被生产者拉过来。<br>一些以日志为中心的系统，比如Scibe和Flume则允许将数据推向下游。</p>
<p>推和拉各有利弊，推模式中，由于是broker控制数据传输速度，目标是以尽可能提高消费者的消息消费率，push模式中，如果消费者消费速度跟不上推的速度，消费者就处于过载状态。而使用拉模式，消费者可以根据自己的处理能力控制拉取消息的速度。</p>
<p>传统拉模式的缺点是：如果服务端没有消息，消费者将会进入循环等待，直到新的数据到达。为了避免这个问题，kafka提供了配置参数，允许消费者请求进入long poll 等待，直到有数据到达。（。。。表示不太懂）</p>
<h3 id="u6D88_u8D39_u8005_u4F4D_u7F6E"><a href="#u6D88_u8D39_u8005_u4F4D_u7F6E" class="headerlink" title="消费者位置"></a>消费者位置</h3><p>在很多消息系统中，服务端是需要维护消息的消费状态的，即当消息投递给消费者之后，服务端要么立即记录下来，要么等待消费端的确认。</p>
<p>如果broker每次将消息投递出去就将消息状态置为“已消费”，那么如果消费者没有成功消费该消息（可能消费者宕机了或者请求超时了等），那消息就相当于丢失了。为了避免这个问题，很多系统增加了确认机制，当消息发送出去的时候，被置为“已发送”状态而不是“已消费”，当收到消费者的确认信息之后，才将消息状态置为“已消费”。</p>
<p>但这会有新的问题，首先，如果消费者消费了消息但是在发送确认信息之前出错了，那么消息将会被消费两次。其次是性能问题，这样一来broker就必须维护很多状态（每条信息一组状态）。另外还需要处理很多其他问题，例如:消息发送出去了但是没有收到确认该怎么办？</p>
<p>kafka的做法是这样的：<br>Topic被分成多个完全有序的分区，任何时候，任意一个分区都只有一个消费者消费。这意味着在每个分区中的消费者位置都是一个整数：下一个即将消费的offset值。这样就使得消息确认变得很容易。<br>另外还有一个好处：消费者可以故意将offset置为一个很老的值，然后重新消费数据。</p>
<h3 id="u79BB_u7EBF_u6570_u636E_u52A0_u8F7D"><a href="#u79BB_u7EBF_u6570_u636E_u52A0_u8F7D" class="headerlink" title="离线数据加载"></a>离线数据加载</h3><h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>kafka使用文件系统作为持久化介质，为了提高速度采用了顺序读写磁盘的方式。</li>
<li>kafka使用了页面缓存而不是进程内缓存，即可以提高缓存空间又能保证重启的时候缓存不是小。</li>
<li>kafka的写操作使用了sendfile API，它允许在文件描述符之间传输数据，从而减少了不必要的拷贝，提高了效率。</li>
<li>kafka支持批量消息压缩，从而降低对网络带宽的占用。</li>
<li>生产者负载均衡是在客户端实现，生产者直接将数据发送到broker中</li>
<li>kafka中，生产者推数据到broker中，消费者从broker中拉取数据</li>
<li>kafka分区和offset降低了消息状态维护的成本</li>
</ol>
<h2 id="u53C2_u8003_u6587_u6863"><a href="#u53C2_u8003_u6587_u6863" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://kafka.apache.org/documentation.html#design" target="_blank" rel="external">kafka设计</a></li>
<li><a href="http://umeng.baijia.baidu.com/article/227913" target="_blank" rel="external">kafka高性能吞吐揭秘</a></li>
<li><a href="https://www.varnish-cache.org/trac/wiki/ArchitectNotes" target="_blank" rel="external">Vanish的以页面缓存为中心的设计</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">sendfile API</a></li>
<li><a href="https://www.ibm.com/developerworks/linux/library/j-zerocopy/" target="_blank" rel="external">零拷贝</a></li>
</ol>

      
    </div>
    
      <div class="article-toc">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u6301_u4E45_u5316"><span class="toc-number">1.</span> <span class="toc-text">持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6570_u636E_u7ED3_u6784"><span class="toc-number">2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C_u548C_u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D"><span class="toc-number">3.</span> <span class="toc-text">大量的小IO操作和大量的字节拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C"><span class="toc-number">3.1.</span> <span class="toc-text">大量的小IO操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D"><span class="toc-number">3.2.</span> <span class="toc-text">大量的字节拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7AEF_u5230_u7AEF_u6279_u91CF_u538B_u7F29"><span class="toc-number">4.</span> <span class="toc-text">端到端批量压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u751F_u4EA7_u8005"><span class="toc-number">5.</span> <span class="toc-text">生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u8D1F_u8F7D_u5747_u8861"><span class="toc-number">5.1.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5F02_u6B65_u53D1_u9001"><span class="toc-number">5.2.</span> <span class="toc-text">异步发送</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6D88_u8D39_u8005"><span class="toc-number">6.</span> <span class="toc-text">消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u63A8_vs-__u62C9"><span class="toc-number">6.1.</span> <span class="toc-text">推 vs. 拉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6D88_u8D39_u8005_u4F4D_u7F6E"><span class="toc-number">6.2.</span> <span class="toc-text">消费者位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u79BB_u7EBF_u6570_u636E_u52A0_u8F7D"><span class="toc-number">6.3.</span> <span class="toc-text">离线数据加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u603B_u7ED3"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u53C2_u8003_u6587_u6863"><span class="toc-number">8.</span> <span class="toc-text">参考文档</span></a></li></ol>
      </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kafka/">Kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据/">大数据</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/kafka-selflearning-00/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          Kafka学习笔记之初见
        
      </div>
    </a>
  
  
    <a href="/kafka-selflearning-01/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Kafka学习笔记之基础概念及原理&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>

</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Medusar&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>