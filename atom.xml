<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Medusar's playground]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.onlycatch.com/"/>
  <updated>2016-01-25T12:08:30.000Z</updated>
  <id>http://blog.onlycatch.com/</id>
  
  <author>
    <name><![CDATA[Medusar]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Kafka学习笔记之初见]]></title>
    <link href="http://blog.onlycatch.com/kafka-selflearning-00/"/>
    <id>http://blog.onlycatch.com/kafka-selflearning-00/</id>
    <published>2016-01-25T12:07:48.000Z</published>
    <updated>2016-01-25T12:08:30.000Z</updated>
    <content type="html"><![CDATA[<p>kafka是一个高性能的分布式消息系统。高水平扩展和高吞吐量。支持动态扩容，由LinkedIn用Scala编写而成。</p>
<h2 id="kafka_u4E0E_u5176_u4ED6_u6D88_u606F_u7CFB_u7EDF_u5BF9_u6BD4"><a href="#kafka_u4E0E_u5176_u4ED6_u6D88_u606F_u7CFB_u7EDF_u5BF9_u6BD4" class="headerlink" title="kafka与其他消息系统对比"></a>kafka与其他消息系统对比</h2><p>flume,storm,spark,elesticsearch都能与kafka集成。<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/kafka.png" alt="kafka与其他消息系统的对比"></p>
<ol>
<li>kafka使用的协议为仿AMQP协议。</li>
<li>kafka不支持事务，activeMQ支持</li>
<li>kafka支持动态扩容，集群，负载均衡。</li>
</ol>
<p><a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol" target="_blank" rel="external">AMQP协议</a>:<a href="http://langyu.iteye.com/blog/759663" target="_blank" rel="external">http://langyu.iteye.com/blog/759663</a></p>
<h2 id="kafka_u7684_u6D88_u8D39_u8005_u7F16_u7A0B_u6A21_u578B"><a href="#kafka_u7684_u6D88_u8D39_u8005_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="kafka的消费者编程模型"></a>kafka的消费者编程模型</h2><ol>
<li>分区消费模型</li>
<li>组消费模型<h3 id="u5206_u533A_u6D88_u8D39_u6A21_u578B"><a href="#u5206_u533A_u6D88_u8D39_u6A21_u578B" class="headerlink" title="分区消费模型"></a>分区消费模型</h3>缺点：</li>
<li>需要自己处理各种异常情况</li>
<li>需要自己管理消息偏移量以实现消息传递的各种语义</li>
</ol>
<h3 id="u6D88_u606F_u4F20_u9012_u7684_u8BED_u4E49"><a href="#u6D88_u606F_u4F20_u9012_u7684_u8BED_u4E49" class="headerlink" title="消息传递的语义"></a>消息传递的语义</h3><ol>
<li>至少一次：发送者向消费者至少发送一次（可能会重复）</li>
<li>至多一次：发送者向消费者至多发送一次（可能会丢）</li>
<li>有且仅有一次：发送者与消费者的关系一对一。<h3 id="u7EC4_u6D88_u8D39_u6A21_u578B"><a href="#u7EC4_u6D88_u8D39_u6A21_u578B" class="headerlink" title="组消费模型"></a>组消费模型</h3></li>
<li>不需要自己处理异常情况，不需要自己管理offset</li>
<li>只能实现默认的kafka至少一次的消息传递语义</li>
</ol>
<h2 id="kafka_u7684_u751F_u4EA7_u8005_u7F16_u7A0B_u6A21_u578B"><a href="#kafka_u7684_u751F_u4EA7_u8005_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="kafka的生产者编程模型"></a>kafka的生产者编程模型</h2><h3 id="u540C_u6B65_u751F_u4EA7_u6A21_u578B"><a href="#u540C_u6B65_u751F_u4EA7_u6A21_u578B" class="headerlink" title="同步生产模型"></a>同步生产模型</h3><p>生产者发送消息后需要等待kafka集群的确认消息，直到收到确认消息或者超过最大投递次数。</p>
<p>特点：</p>
<ol>
<li>低消息丢失率</li>
<li>高消息重复率（网络原因导致回复确认没收到）</li>
<li>高延迟<h3 id="u5F02_u6B65_u751F_u4EA7_u6A21_u578B"><a href="#u5F02_u6B65_u751F_u4EA7_u6A21_u578B" class="headerlink" title="异步生产模型"></a>异步生产模型</h3>生产者先把消息发送到客户端的缓冲队列，队列中的消息会被打包一起发送到kafka服务器。<br>特点：</li>
<li>高消息丢失率（无确认机制，发送端队列满）</li>
<li>高发送性能</li>
<li>低延迟</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[kafka入门简介]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://blog.onlycatch.com/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://blog.onlycatch.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka学习笔记之高性能设计]]></title>
    <link href="http://blog.onlycatch.com/kafka-selflearning-02/"/>
    <id>http://blog.onlycatch.com/kafka-selflearning-02/</id>
    <published>2016-01-25T12:03:52.000Z</published>
    <updated>2016-01-25T13:15:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6301_u4E45_u5316"><a href="#u6301_u4E45_u5316" class="headerlink" title="持久化"></a>持久化</h2><p>kafka非常依赖文件系统进行消息存储和缓存。大部分人会认为“磁盘很慢”，所以很多人会怀疑持久化是否能够提供很好的性能。实际上磁盘速度的快慢与磁盘的使用方式有着很大关系，设计好的磁盘结构通常会很快。</p>
<p>对于磁盘的线性读写操作在很多系统中都进行了大量优化，在某些情况下，对于磁盘的顺序访问甚至比对于内存的随机访问还要快！</p>
<p>很多现代操作系统都大量使用主存做磁盘缓存，一个现代操作系统可以将内存中的所有剩余空间用作磁盘缓存，而当内存回收的时候几乎没有性能损失。所有的磁盘读写都会经过这个统一的缓存。哪怕使用directI/O，这个特性也很难被关闭，所以如果某个进程维护了一份进程内缓存，那么这部分数据很可能也在操作系统的页面缓存中存在。</p>
<p>由于kafka是基于JVM的，并且任何与java内存使用打过交道的人都知道两件事：</p>
<ol>
<li>对象的内存开销非常高，通常是实际要存储数据大小的两倍</li>
<li>随着数据的增加，java的垃圾收集也会越来越频繁并且缓慢<br>基于此，使用文件系统，同时依赖页面缓存就比使用其他数据结构和维护内存缓存更有吸引力：</li>
<li>不使用进程内缓存，就腾出了内存空间，可以用来存放页面缓存的空间几乎可以翻倍。</li>
<li>如果kafka重启，进行内缓存就会丢失，但是使用操作系统的页面缓存依然可以继续使用。</li>
</ol>
<p>kafka如此频繁利用页面缓存，如果内存大小不够了怎么办？kafka会将数据写入到持久化日志中而不是刷新到磁盘。实际上它只是转移到了内核的页面缓存。</p>
<h2 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="http://kafka.apache.org/documentation.html#design_constanttime" target="_blank" rel="external">http://kafka.apache.org/documentation.html#design_constanttime</a></p>
<h2 id="u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C_u548C_u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D"><a href="#u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C_u548C_u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D" class="headerlink" title="大量的小IO操作和大量的字节拷贝"></a>大量的小IO操作和大量的字节拷贝</h2><p>除了上面说的磁盘读写影响性能之外，另外两个影响性能的就是：</p>
<ol>
<li>大量的IO操作</li>
<li>大量的字节拷贝</li>
</ol>
<h3 id="u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C"><a href="#u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C" class="headerlink" title="大量的小IO操作"></a>大量的小IO操作</h3><p>对于消息服务端来说，写操作是很频繁的，为了避免这个问题，kafka的协议是基于一种“消息集合”的抽象，它允许网络请求将消息集中发送而不是每次发送一条消息。服务端同样，也是一次性将一组消息写入日志，消费者也是每次取一大块。</p>
<p>这样做能够产生更大的网络数据包，更大的连续磁盘操作以及连续的内存块，这些都使得kafka更容易将大量随机消息编程线性的写操作。</p>
<h3 id="u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D"><a href="#u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D" class="headerlink" title="大量的字节拷贝"></a>大量的字节拷贝</h3><p>kafka消费者，生产者还有服务端使用的日志格式都是一样的。这样做的好处就是能够为网络传输数据块提供最大的优化。</p>
<p>一般来讲，将文件中的数据转移到Socket需要经过以下几步：</p>
<ol>
<li>操作系统将数据从磁盘读到内核空间的页面缓存中</li>
<li>应用程序从内核空间将数据读取到用户空间</li>
<li>应用程序将数据重新写入到内核空间中的socket缓存中</li>
<li>操作系统将数据从socket缓存中拷贝到网卡缓存中（网卡缓存中的数据将被发送到网络中）</li>
</ol>
<p>上面的过程经过了四次拷贝和两次系统调用，明显这是不高效的。<br>通过使用sendfile API,允许操作系统直接从页面缓存将数据发送到网络，就减少了不必要的拷贝，只有最后一步：将数据拷贝到网卡缓存是必须的。</p>
<p>假设某个Topic有多个消费者，使用上面的零拷贝技术，数据只会被拷贝一次进入页面缓存，每次消费都可以被重复使用。这样就避免了每次读的时候都将数据存到内存中然后拷贝到内核空间。</p>
<h2 id="u7AEF_u5230_u7AEF_u6279_u91CF_u538B_u7F29"><a href="#u7AEF_u5230_u7AEF_u6279_u91CF_u538B_u7F29" class="headerlink" title="端到端批量压缩"></a>端到端批量压缩</h2><p>在很多情况下，系统的瓶颈不是CPU而是带宽。所以数据压缩就很重要。<br>可以每个消息都压缩，但是压缩率相对很低。所以kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩。<br>kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩。<br>kafka支持Gzip和Snappy压缩协议。</p>
<h2 id="u751F_u4EA7_u8005"><a href="#u751F_u4EA7_u8005" class="headerlink" title="生产者"></a>生产者</h2><h3 id="u8D1F_u8F7D_u5747_u8861"><a href="#u8D1F_u8F7D_u5747_u8861" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>生产者直接将数据发送到broker中，中间不会经过任何路由层。<br>为了达到这个目的，所有的kafka节点都能在任何时候回答是否服务器可以用以及主题分区的leader机器在哪里等问题，以便于生产者正确的发送数据。</p>
<p>生产者客户端控制着消息发往哪个分区。可以通过随机负载均衡或者其他分区语义功能来实现。kafka提供了分区语义接口允许用户指定一个用户哈希分析的字段。</p>
<h3 id="u5F02_u6B65_u53D1_u9001"><a href="#u5F02_u6B65_u53D1_u9001" class="headerlink" title="异步发送"></a>异步发送</h3><p>为了实现批量发送，kafka需要在内存中积累数据，以便于在单次请求中发送足够大的数据。可以通过配置消息数量不超过某个值或者等待时间不超过某个值来进行控制。</p>
<h2 id="u6D88_u8D39_u8005"><a href="#u6D88_u8D39_u8005" class="headerlink" title="消费者"></a>消费者</h2><p>消费者通过指定log的offset来获取消息，每次取回一块以指定的offset开始的消息块。</p>
<h3 id="u63A8_vs-__u62C9"><a href="#u63A8_vs-__u62C9" class="headerlink" title="推 vs. 拉"></a>推 vs. 拉</h3><p>在kafka中，消息是被消费者推到broker的，然后被生产者拉过来。<br>一些以日志为中心的系统，比如Scibe和Flume则允许将数据推向下游。</p>
<p>推和拉各有利弊，推模式中，由于是broker控制数据传输速度，目标是以尽可能提高消费者的消息消费率，push模式中，如果消费者消费速度跟不上推的速度，消费者就处于过载状态。而使用拉模式，消费者可以根据自己的处理能力控制拉取消息的速度。</p>
<p>传统拉模式的缺点是：如果服务端没有消息，消费者将会进入循环等待，直到新的数据到达。为了避免这个问题，kafka提供了配置参数，允许消费者请求进入long poll 等待，直到有数据到达。（。。。表示不太懂）</p>
<h3 id="u6D88_u8D39_u8005_u4F4D_u7F6E"><a href="#u6D88_u8D39_u8005_u4F4D_u7F6E" class="headerlink" title="消费者位置"></a>消费者位置</h3><p>在很多消息系统中，服务端是需要维护消息的消费状态的，即当消息投递给消费者之后，服务端要么立即记录下来，要么等待消费端的确认。</p>
<p>如果broker每次将消息投递出去就将消息状态置为“已消费”，那么如果消费者没有成功消费该消息（可能消费者宕机了或者请求超时了等），那消息就相当于丢失了。为了避免这个问题，很多系统增加了确认机制，当消息发送出去的时候，被置为“已发送”状态而不是“已消费”，当收到消费者的确认信息之后，才将消息状态置为“已消费”。</p>
<p>但这会有新的问题，首先，如果消费者消费了消息但是在发送确认信息之前出错了，那么消息将会被消费两次。其次是性能问题，这样一来broker就必须维护很多状态（每条信息一组状态）。另外还需要处理很多其他问题，例如:消息发送出去了但是没有收到确认该怎么办？</p>
<p>kafka的做法是这样的：<br>Topic被分成多个完全有序的分区，任何时候，任意一个分区都只有一个消费者消费。这意味着在每个分区中的消费者位置都是一个整数：下一个即将消费的offset值。这样就使得消息确认变得很容易。<br>另外还有一个好处：消费者可以故意将offset置为一个很老的值，然后重新消费数据。</p>
<h3 id="u79BB_u7EBF_u6570_u636E_u52A0_u8F7D"><a href="#u79BB_u7EBF_u6570_u636E_u52A0_u8F7D" class="headerlink" title="离线数据加载"></a>离线数据加载</h3><h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>kafka使用文件系统作为持久化介质，为了提高速度采用了顺序读写磁盘的方式。</li>
<li>kafka使用了页面缓存而不是进程内缓存，即可以提高缓存空间又能保证重启的时候缓存不是小。</li>
<li>kafka的写操作使用了sendfile API，它允许在文件描述符之间传输数据，从而减少了不必要的拷贝，提高了效率。</li>
<li>kafka支持批量消息压缩，从而降低对网络带宽的占用。</li>
<li>生产者负载均衡是在客户端实现，生产者直接将数据发送到broker中</li>
<li>kafka中，生产者推数据到broker中，消费者从broker中拉取数据</li>
<li>kafka分区和offset降低了消息状态维护的成本</li>
</ol>
<h2 id="u53C2_u8003_u6587_u6863"><a href="#u53C2_u8003_u6587_u6863" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://kafka.apache.org/documentation.html#design" target="_blank" rel="external">kafka设计</a></li>
<li><a href="http://umeng.baijia.baidu.com/article/227913" target="_blank" rel="external">kafka高性能吞吐揭秘</a></li>
<li><a href="https://www.varnish-cache.org/trac/wiki/ArchitectNotes" target="_blank" rel="external">Vanish的以页面缓存为中心的设计</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">sendfile API</a></li>
<li><a href="https://www.ibm.com/developerworks/linux/library/j-zerocopy/" target="_blank" rel="external">零拷贝</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Kafka在设计过程中的为了追求高性能而做的一些处理]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://blog.onlycatch.com/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://blog.onlycatch.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka学习笔记之基础概念及原理]]></title>
    <link href="http://blog.onlycatch.com/kafka-selflearning-01/"/>
    <id>http://blog.onlycatch.com/kafka-selflearning-01/</id>
    <published>2016-01-25T12:02:11.000Z</published>
    <updated>2016-01-25T12:03:19.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u7EC4_u4EF6_u6982_u5FF5"><a href="#u7EC4_u4EF6_u6982_u5FF5" class="headerlink" title="组件概念"></a>组件概念</h3><p>Topic:消息分类<br>Producer:发布消息到kafka集群<br>consumer:订阅Topic并且处理消息<br>broker:组成kafka集群的服务器</p>
<p>kafka客户端与服务端通信是通过TCP协议实现的。</p>
<h3 id="u6570_u636E_u5B58_u50A8"><a href="#u6570_u636E_u5B58_u50A8" class="headerlink" title="数据存储"></a>数据存储</h3><p>一个kafka集群通常包含多个代理（broker)，为了负载均衡，将话题分为多个分区，每个代理存储一个或多个分区。多个producer和comsumer可以同时生产和获取消息。</p>
<p><img src="http://kafka.apache.org/images/log_anatomy.png" alt="kafka分区"><br>如上图：每个Topic对应多个分区，每个分区是一个有序的消息序列，新提交的消息被添加在序列尾部。</p>
<p>每个分区对应一个逻辑日志，物理上，一个日志为相同大小的一组分段文件。每次生产者发布消息到一个分区，代理就将消息追加到最后一个段文件中。当发布的消息数量达到设定值或者经过一段时间之后，段文件真正写入磁盘。写入完成后，消息公开给消费者（只有同步到磁盘之后才会通知消费者？？）。</p>
<p>kafka中的消息没有消息id，而是通过offset(偏移量)来确定消息的位置。这样就避免了维护消息ID到实际消息地址的开销。消费者向代理异步发出拉请求，每个拉请求都包含要消费的消息偏移量。</p>
<p>如图：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/%40%2Fima%2F0609012.png" alt="kafka存储结构"></p>
<h3 id="u4F7F_u7528_u5206_u533A_u5B58_u50A8_u6709_u4EC0_u4E48_u597D_u5904_uFF1F"><a href="#u4F7F_u7528_u5206_u533A_u5B58_u50A8_u6709_u4EC0_u4E48_u597D_u5904_uFF1F" class="headerlink" title="使用分区存储有什么好处？"></a>使用分区存储有什么好处？</h3><ol>
<li>允许超过单机允许大小的日志文件存在</li>
<li>多个分区可以提高并行度</li>
</ol>
<h3 id="u5206_u5E03_u5F0F"><a href="#u5206_u5E03_u5F0F" class="headerlink" title="分布式"></a>分布式</h3><p>分区日志分布在kafka集群中的多台机器上，每台机器处理一部分分区。每个分区在多台机器上进行备份以增加容错性。</p>
<p>每个分区只有一个leader机器，0台或者多台follower机器。leader机器处理对该分区的所有读写请求，follower机器负责同步leader机器的数据。如果leader挂掉了，剩下的followers将自动选一台leader。</p>
<p>一台机器作为A分区的follower可以作为B分区的leader，这样就实现了集群内负载均衡。</p>
<h3 id="u6570_u636E_u4F20_u8F93"><a href="#u6570_u636E_u4F20_u8F93" class="headerlink" title="数据传输"></a>数据传输</h3><p>kafka利用sendfile API从代理的日志段文件中分发字节给消费者。<br>sendfile API:<a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man2/sendfile.2.html</a><br>它可以直接在两个文件的描述符之间传输数据，sendfile(）可以将一个文件描述符表示的文件中的数据拷贝到另外的文件描述符中，由于拷贝是在内核中进行的，所以比组合使用read()和write()要快很多，因为后者read和write数据需要经过用户空间。</p>
<h3 id="kafka_u4EE3_u7406_uFF08broker_uFF09"><a href="#kafka_u4EE3_u7406_uFF08broker_uFF09" class="headerlink" title="kafka代理（broker）"></a>kafka代理（broker）</h3><p>kafka代理是无状态的，消费者需要自己维护已消费的状态信息。<br>代理删除消息：代理由于无状态，故它不知道消费者是否已经使用了该消息。Kafka使用基于时间的SLA应用于保留策略。当消息在代理中超过一定时间后，将会被自动删除。</p>
<p>kafka集群会维护所有发布的消息，无论是否被消费过，直到消息过期。过期时间是可以配置的。比如：某个日志被设置为两天，那么消息发布之后两天之内，它都是可以被消费的，但是两天之后，kafka将把消息丢弃以腾出空间。<br>kafka的性能是不受存储数据大小的影响的，所以维护大量数据并不是问题。</p>
<h3 id="zookeeper_u4E0Ekafka"><a href="#zookeeper_u4E0Ekafka" class="headerlink" title="zookeeper与kafka"></a>zookeeper与kafka</h3><p>ZooKeeper在kafka中被用于管理、协调Kafka代理。每个Kafka代理都通过ZooKeeper协调其它Kafka代理。当Kafka系统中新增了代理或者某个代理故障失效时，ZooKeeper服务将通知生产者和消费者。生产者和消费者据此开始与其它代理协调工作。<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/%40%2Fima%2Fkafka_zk.png" alt="zk在kafka中的应用"></p>
<h3 id="u6D88_u8D39_u8005_u7EC4"><a href="#u6D88_u8D39_u8005_u7EC4" class="headerlink" title="消费者组"></a>消费者组</h3><p>传统消息系统有两种模型：队列模型和发布-订阅模型。<br>队列模型：队列中的每条消息只会发到众多消费者中的一个。<br>发布订阅模型：消息会被广播到所有的消费者。</p>
<p>kafka将消费者抽象出来了“消费者组”的概念，这个概念能够同时实现上述两种模型的功能。</p>
<p>每个消费者属于一个组，消息会被发送到每个组中的某一个消费者实例。<br>注意：每个组中的某一个消费者实例。意思就是，假如我有2个组，A和B，然后有一条消息，这条消息会被发往A和B两个组，但是每个组中只有一个消费者实例能够收到该条消息。所以就有了如下变种：</p>
<p>如果所有的消费者都属于一个组，那么就相当于实现了队列模型。<br>如果每个消费者都属于不同的组，那么就相当于实现了发布-订阅模型。</p>
<h3 id="u6D88_u606F_u987A_u5E8F_u4FDD_u8BC1"><a href="#u6D88_u606F_u987A_u5E8F_u4FDD_u8BC1" class="headerlink" title="消息顺序保证"></a>消息顺序保证</h3><p>kafka提供了很高的消息顺序保证。</p>
<p>传统的消息系统服务器，在服务端按存储顺序维护消息，但是消息发送给消费者是通过异步发送的，所以消息实际到达消费者的顺序就可能与服务端维护的顺序不一致。很多消息系统对此采用的办法就是只允许一个进程消费消息，这样虽然能够保证消息的顺序性，但是却丢失了并发性。</p>
<p>kafka通过将Topic进行分区，很好的提高了并发性，它既能提供顺序保证又能在多个消费者之间做到负载均衡。它是通过绑定主题分区与消费者组中的消费者，从而保证每个分区只能被分区中的一个消费者所消费。这样就能够保证被指定的消费者是唯一一个读取指定分区的消费者，并且该消费者按顺序消费数据。由于存在多个分区，所以仍然不必担心负载均衡的问题。</p>
<p>简单来说就是：kafka是通过保证某一个分区是只被每个组中的一个消费者消费，控制的只是单个分区中消息的顺序。如果你要保证整个Topic的消息顺序，那只需要将分区数设置为1就可以了。</p>
<h3 id="kafka_u63D0_u4F9B_u7684_u4FDD_u8BC1"><a href="#kafka_u63D0_u4F9B_u7684_u4FDD_u8BC1" class="headerlink" title="kafka提供的保证"></a>kafka提供的保证</h3><ul>
<li>生产者发送到某个特定Topic分区的消息将会按照它们的发送顺序依次追加。就是说，如果M1和M2是由同一个生产者发送的消息，M1是先发送的，那么M1在日志中的offset就会比M2低很多。</li>
<li>消费者实例看到消息的顺序与它们在日志中的存储顺序一致。</li>
<li>对于备份因子为N的一个消息主题，可以允许N-1台服务器宕机而不会丢失任何已经提交到日志中的消息。</li>
</ul>
<h3 id="kafka_u7684_u5E94_u7528_u573A_u666F"><a href="#kafka_u7684_u5E94_u7528_u573A_u666F" class="headerlink" title="kafka的应用场景"></a>kafka的应用场景</h3><ol>
<li>消息系统</li>
<li>网站活动追踪</li>
<li>日志收集</li>
<li>流处理（与Storm配合使用）</li>
<li>事件源</li>
<li>日志提交（Bookeeper)</li>
</ol>
<h3 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.infoq.com/cn/articles/apache-kafka" target="_blank" rel="external">Apache Kafka：下一代分布式消息系统</a></li>
<li><a href="http://kafka.apache.org/documentation.html#uses" target="_blank" rel="external">Kafka官方文档</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[kafka的基本概念以及原理解释，学习记录，有点乱。]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://blog.onlycatch.com/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://blog.onlycatch.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dubbo启动脚本学习]]></title>
    <link href="http://blog.onlycatch.com/how-linux-commands-used-in-dubbo/"/>
    <id>http://blog.onlycatch.com/how-linux-commands-used-in-dubbo/</id>
    <published>2016-01-25T11:59:07.000Z</published>
    <updated>2016-01-25T12:00:10.000Z</updated>
    <content type="html"><![CDATA[<p>Dubbod启动的脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`</span><br><span class="line">BIN_DIR=`<span class="built_in">pwd</span>`</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">DEPLOY_DIR=`<span class="built_in">pwd</span>`</span><br><span class="line">CONF_DIR=<span class="variable">$DEPLOY_DIR</span>/conf</span><br><span class="line"></span><br><span class="line">SERVER_NAME=`sed <span class="string">'/dubbo.application.name/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br><span class="line">SERVER_PROTOCOL=`sed <span class="string">'/dubbo.protocol.name/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br><span class="line">SERVER_PORT=`sed <span class="string">'/dubbo.protocol.port/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br><span class="line">LOGS_FILE=`sed <span class="string">'/dubbo.log4j.file/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$SERVER_NAME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    SERVER_NAME=`hostname`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">PIDS=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$CONF_DIR</span>"</span> |awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$PIDS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ERROR: The <span class="variable">$SERVER_NAME</span> already started!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"PID: <span class="variable">$PIDS</span>"</span></span><br><span class="line">    <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$SERVER_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    SERVER_PORT_COUNT=`netstat -tln | grep <span class="variable">$SERVER_PORT</span> | wc <span class="operator">-l</span>`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$SERVER_PORT_COUNT</span> <span class="operator">-gt</span> <span class="number">0</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"ERROR: The <span class="variable">$SERVER_NAME</span> port <span class="variable">$SERVER_PORT</span> already used!"</span></span><br><span class="line">        <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">LOGS_DIR=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$LOGS_FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    LOGS_DIR=`dirname <span class="variable">$LOGS_FILE</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    LOGS_DIR=<span class="variable">$DEPLOY_DIR</span>/logs</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="variable">$LOGS_DIR</span> ]; <span class="keyword">then</span></span><br><span class="line">    mkdir <span class="variable">$LOGS_DIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">STDOUT_FILE=<span class="variable">$LOGS_DIR</span>/stdout.log</span><br><span class="line"></span><br><span class="line">LIB_DIR=<span class="variable">$DEPLOY_DIR</span>/lib</span><br><span class="line">LIB_JARS=`ls <span class="variable">$LIB_DIR</span>|grep .jar|awk <span class="string">'&#123;print "'</span><span class="variable">$LIB_DIR</span><span class="string">'/"$0&#125;'</span>|tr <span class="string">"\n"</span> <span class="string">":"</span>`</span><br><span class="line"></span><br><span class="line">JAVA_OPTS=<span class="string">" -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true "</span></span><br><span class="line">JAVA_DEBUG_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"debug"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_DEBUG_OPTS=<span class="string">" -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">JAVA_JMX_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"jmx"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_JMX_OPTS=<span class="string">" -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">JAVA_MEM_OPTS=<span class="string">""</span></span><br><span class="line">BITS=`java -version <span class="number">2</span>&gt;&amp;<span class="number">1</span> | grep -i <span class="number">64</span>-bit`</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$BITS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_MEM_OPTS=<span class="string">" -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 "</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    JAVA_MEM_OPTS=<span class="string">" -server -Xms1g -Xmx1g -XX:PermSize=128m -XX:SurvivorRatio=2 -XX:+UseParallelGC "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"Starting the <span class="variable">$SERVER_NAME</span> ...\c"</span></span><br><span class="line">nohup java <span class="variable">$JAVA_OPTS</span> <span class="variable">$JAVA_MEM_OPTS</span> <span class="variable">$JAVA_DEBUG_OPTS</span> <span class="variable">$JAVA_JMX_OPTS</span> -classpath <span class="variable">$CONF_DIR</span>:<span class="variable">$LIB_JARS</span> com.alibaba.dubbo.container.Main &gt; <span class="variable">$STDOUT_FILE</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"></span><br><span class="line">COUNT=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$COUNT</span> <span class="operator">-lt</span> <span class="number">1</span> ]; <span class="keyword">do</span>    </span><br><span class="line">    <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">".\c"</span></span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$SERVER_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$SERVER_PROTOCOL</span>"</span> == <span class="string">"dubbo"</span> ]; <span class="keyword">then</span></span><br><span class="line">    	    COUNT=`<span class="built_in">echo</span> status | nc -i <span class="number">1</span> <span class="number">127.0</span>.<span class="number">0.1</span> <span class="variable">$SERVER_PORT</span> | grep -c OK`</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            COUNT=`netstat -an | grep <span class="variable">$SERVER_PORT</span> | wc <span class="operator">-l</span>`</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	COUNT=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$DEPLOY_DIR</span>"</span> | awk <span class="string">'&#123;print $2&#125;'</span> | wc <span class="operator">-l</span>`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$COUNT</span> <span class="operator">-gt</span> <span class="number">0</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"OK!"</span></span><br><span class="line">PIDS=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$DEPLOY_DIR</span>"</span> | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID: <span class="variable">$PIDS</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"STDOUT: <span class="variable">$STDOUT_FILE</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>下面是简单的解释：</p>
<p>startserver.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`</span><br></pre></td></tr></table></figure></p>
<p>$0当前Shell程序的文件名<br>dirname $0，获取当前Shell程序的路径<br>cd <code>dirname $0</code>，进入当前Shell程序的目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SERVER_NAME=`sed <span class="string">'/dubbo.application.name/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br></pre></td></tr></table></figure>
<p><code>sed &#39;/dubbo.application.name/!d;s/.*=//&#39; ../conf/dubbo.properties</code> 从conf/dubbo.properties文件中截取dubbo.application.name对应的值</p>
<p><code>sed &#39;/dubbo.application.name/!d&#39; dubbo.properties</code> 从dubbo.properties文件中查找包含dubbo.application.name的行，<code>!d</code>表示不删除，这样执行完的结果是：<br><code>ubbo.application.name=my-server</code></p>
<p>后面的：<code>;s/.*=//</code> 表示替换，即将所得数据中的 ‘.*=’部分，替换成掉。<br>结果：<br><code>my-server</code> 即，只有我的服务名称了</p>
<p><code>tr -d &#39;\r&#39;</code> 将回车符号删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$SERVER_NAME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    SERVER_NAME=`hostname`</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if  [ -z $string  ]             如果string 为空</p>
<p><code>hostname</code> 显示当前系统的hostname</p>
<blockquote>
<p>hostname - show or set the system’s host name<br>       domainname - show or set the system’s NIS/YP domain name<br>       dnsdomainname - show the system’s DNS domain name<br>       nisdomainname - show or set system’s NIS/YP domain name<br>       ypdomainname - show or set the system’s NIS/YP domain name</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PIDS=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$CONF_DIR</span>"</span> |awk <span class="string">'&#123;print $2&#125;'</span>`</span><br></pre></td></tr></table></figure>
<p><code>ps -f | grep java | grep &quot;$CONF_DIR&quot;</code> 根据配置文件路径定位到当前服务的进程id。格式如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root     <span class="number">25867</span>     <span class="number">1</span>  <span class="number">0</span> Jan04 ?        <span class="number">00</span>:<span class="number">37</span>:<span class="number">35</span> java -Djava.awt.headless=<span class="literal">true</span> -Djava.net.preferIPv4Stack=<span class="literal">true</span> -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=<span class="number">128</span>m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompa...</span><br></pre></td></tr></table></figure></p>
<p>此时调用<code>awk &#39;{print $2}&#39;</code>，则将第二列打印出来，正好是当前进行的进程id。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$PIDS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ERROR: The <span class="variable">$SERVER_NAME</span> already started!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"PID: <span class="variable">$PIDS</span>"</span></span><br><span class="line">    <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if  [ -n $string  ]             如果string 非空(非0），返回0(true)<br>若果当前进程存在，则输出：已经启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$SERVER_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    SERVER_PORT_COUNT=`netstat -tln | grep <span class="variable">$SERVER_PORT</span> | wc <span class="operator">-l</span>`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$SERVER_PORT_COUNT</span> <span class="operator">-gt</span> <span class="number">0</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"ERROR: The <span class="variable">$SERVER_NAME</span> port <span class="variable">$SERVER_PORT</span> already used!"</span></span><br><span class="line">        <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>如果端口号不为空，则通过<br><code>netstat -tln | grep $SERVER_PORT | wc -l</code> 来统计当前已经占用该端口的数量<br>如果数量大于0.则提示端口被占用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOGS_DIR=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$LOGS_FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    LOGS_DIR=`dirname <span class="variable">$LOGS_FILE</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    LOGS_DIR=<span class="variable">$DEPLOY_DIR</span>/logs</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="variable">$LOGS_DIR</span> ]; <span class="keyword">then</span></span><br><span class="line">    mkdir <span class="variable">$LOGS_DIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if [ ! -d $LOGS_DIR ] 如果日志目录不存在，就创建该目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIB_DIR=<span class="variable">$DEPLOY_DIR</span>/lib</span><br><span class="line">LIB_JARS=`ls <span class="variable">$LIB_DIR</span>|grep .jar|awk <span class="string">'&#123;print "'</span><span class="variable">$LIB_DIR</span><span class="string">'/"$0&#125;'</span>|tr <span class="string">"\n"</span> <span class="string">":"</span>`</span><br></pre></td></tr></table></figure>
<p>获取lib目录下的jar包。</p>
<p><code>ls $LIB_DIR|grep .jar|</code> 获取lib目录下的所有.jar文件名称。<br><code>awk &#39;{print &quot;&#39;$LIB_DIR&#39;/&quot;$0}</code> 将上面的jar文件名称，拼接上lib的路径然后输出。</p>
<p><code>tr &quot;\n&quot; &quot;:&quot;</code> 将换行符替换成冒号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">" -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true "</span></span><br><span class="line">JAVA_DEBUG_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"debug"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_DEBUG_OPTS=<span class="string">" -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">JAVA_JMX_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"jmx"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_JMX_OPTS=<span class="string">" -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">JAVA_MEM_OPTS=<span class="string">""</span></span><br><span class="line">BITS=`java -version <span class="number">2</span>&gt;&amp;<span class="number">1</span> | grep -i <span class="number">64</span>-bit`</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$BITS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_MEM_OPTS=<span class="string">" -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 "</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    JAVA_MEM_OPTS=<span class="string">" -server -Xms1g -Xmx1g -XX:PermSize=128m -XX:SurvivorRatio=2 -XX:+UseParallelGC "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"Starting the <span class="variable">$SERVER_NAME</span> ...\c"</span></span><br><span class="line">nohup java <span class="variable">$JAVA_OPTS</span> <span class="variable">$JAVA_MEM_OPTS</span> <span class="variable">$JAVA_DEBUG_OPTS</span> <span class="variable">$JAVA_JMX_OPTS</span> -classpath <span class="variable">$CONF_DIR</span>:<span class="variable">$LIB_JARS</span> com.alibaba.dubbo.container.Main &gt; <span class="variable">$STDOUT_FILE</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p><code>java -version 2&gt;&amp;1 | grep -i 64-bit</code>这里，首先将java版本号信息输出到标准输出，然后查找’64-bit’信息，目的就是判断jdk版本是否为64位。</p>
<p><code>nohup java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp;</code> 通过java命令启动服务，同时将其作为后台任务执行。</p>
<p>关于 <code>2&gt;&amp;1</code> 可以看：<a href="http://blog.sina.com.cn/s/blog_4aae007d010192qc.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4aae007d010192qc.html</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">COUNT=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$COUNT</span> <span class="operator">-lt</span> <span class="number">1</span> ]; <span class="keyword">do</span>   </span><br><span class="line">    <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">".\c"</span></span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$SERVER_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$SERVER_PROTOCOL</span>"</span> == <span class="string">"dubbo"</span> ]; <span class="keyword">then</span></span><br><span class="line">            COUNT=`<span class="built_in">echo</span> status | nc -i <span class="number">1</span> <span class="number">127.0</span>.<span class="number">0.1</span> <span class="variable">$SERVER_PORT</span> | grep -c OK`</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            COUNT=`netstat -an | grep <span class="variable">$SERVER_PORT</span> | wc <span class="operator">-l</span>`</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        COUNT=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$DEPLOY_DIR</span>"</span> | awk <span class="string">'&#123;print $2&#125;'</span> | wc <span class="operator">-l</span>`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$COUNT</span> <span class="operator">-gt</span> <span class="number">0</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>echo -e &quot;.\c&quot;</code><br><code>echo status | nc -i 1 127.0.0.1 $SERVER_PORT | grep -c OK</code></p>
<p>grep -c 阻止正常的结果输出，转而输出匹配的结果数量，这里就是输出OK的个数。</p>
]]></content>
    <summary type="html">
    <![CDATA[Dubbo启动脚本中的一些比较复杂的linux命令的使用介绍]]>
    
    </summary>
    
      <category term="Dubbo" scheme="http://blog.onlycatch.com/tags/Dubbo/"/>
    
      <category term="linux" scheme="http://blog.onlycatch.com/tags/linux/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Murmur哈希算法]]></title>
    <link href="http://blog.onlycatch.com/murmurhash/"/>
    <id>http://blog.onlycatch.com/murmurhash/</id>
    <published>2016-01-25T11:51:27.000Z</published>
    <updated>2016-01-25T11:56:37.000Z</updated>
    <content type="html"><![CDATA[<p>在看<a href="http://redisbook.com/preview/dict/hash_algorithm.html" target="_blank" rel="external">redis哈希</a>的时候发现了这个算法。</p>
<h2 id="u4F5C_u7528"><a href="#u4F5C_u7528" class="headerlink" title="作用"></a>作用</h2><p>MurmurHash是一种非加密型哈希函数。与其他流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好。</p>
<p>最早发明与2008年，目前的版本是MurmurHash3,可以产生32位或者128位的哈希值。其名字来自于MUltiply and Rotate,因为要经过多次MUltiply and Rotate，所以叫Murmur.</p>
<h2 id="u5B9E_u73B0"><a href="#u5B9E_u73B0" class="headerlink" title="实现"></a>实现</h2><p>在java中，Guava的Hashing类中提供了多个版本的实现。<br><a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/Murmur3_32HashFunction.java" target="_blank" rel="external">32位版本</a><br><a href="https://github.com/google/guava/blob/master/guava%2Fsrc%2Fcom%2Fgoogle%2Fcommon%2Fhash%2FMurmur3_128HashFunction.java" target="_blank" rel="external">128位版本</a></p>
<p>另外，很多应用广泛的开源产品也使用了MurmurHash<br><a href="https://github.com/xetorthio/jedis/blob/master/src/main/java/redis/clients/util/MurmurHash.java" target="_blank" rel="external">jedis的MurmurHash</a><br><a href="https://github.com/xetorthio/jedis/blob/master/src/main/java/redis/clients/util/MurmurHash.java" target="_blank" rel="external">cassandra的MurmurHash实现</a><br><a href="https://github.com/apache/hbase/blob/a545d71295e582398b2689ed09d2167d7f118cec/hbase-common/src/main/java/org/apache/hadoop/hbase/util/MurmurHash3.java" target="_blank" rel="external">Hbase中的Murmurhash</a><br><a href="https://lucene.apache.org/core/4_8_0/codecs/org/apache/lucene/codecs/bloom/MurmurHash2.html" target="_blank" rel="external">Lucene中的murmurhsah</a></p>
<h2 id="u76F8_u5173_u6587_u6863"><a href="#u76F8_u5173_u6587_u6863" class="headerlink" title="相关文档"></a>相关文档</h2><ol>
<li><a href="http://redisbook.com/preview/dict/hash_algorithm.html" target="_blank" rel="external">redis hash</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="external">murmur哈希wiki</a></li>
<li><a href="http://calvin1978.blogcn.com/articles/murmur.html" target="_blank" rel="external">陌生但默默一统江湖的MurmurHash</a></li>
<li><a href="http://openwares.net/misc/murmurhash%E7%AE%97%E6%B3%95.html" target="_blank" rel="external">murmurhash算法</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[一种非加密哈希算法，2008年发明，一杯应用于Redis，HBase，Cassandra等项目]]>
    
    </summary>
    
      <category term="哈希算法" scheme="http://blog.onlycatch.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://blog.onlycatch.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[密码学综述]]></title>
    <link href="http://blog.onlycatch.com/cryptology/"/>
    <id>http://blog.onlycatch.com/cryptology/</id>
    <published>2016-01-25T11:49:15.000Z</published>
    <updated>2016-01-25T11:55:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5BC6_u7801_u5B66_u7B97_u6CD5_u7684_u5206_u7C7B"><a href="#u5BC6_u7801_u5B66_u7B97_u6CD5_u7684_u5206_u7C7B" class="headerlink" title="密码学算法的分类"></a>密码学算法的分类</h2><ul>
<li>消息编码：base64</li>
<li>消息摘要：MD类，SHA类，MAC</li>
<li>对称密码: DES,3DES,AES</li>
<li>非对称密码：RSA，DH秘钥交换</li>
<li>数字签名：RSASignature，DSASignature</li>
</ul>
<h2 id="u5BC6_u7801_u5B665_u5143_u7956"><a href="#u5BC6_u7801_u5B665_u5143_u7956" class="headerlink" title="密码学5元祖"></a>密码学5元祖</h2><p>（明文，密文，加密算法，解密算法，密钥）<br>加密算法和解密算法都是公开的。使用保密的加密算法和解密算法是不够安全的，而且也很难做到保密工作）</p>
<p>安全性完全依赖于秘钥。</p>
<p>密码与密钥<br>密码=秘钥+规则<br>秘钥才是需要保证绝密的。</p>
<h2 id="u5BF9_u79F0_u5BC6_u7801_u4E0E_u975E_u5BF9_u79F0_u5BC6_u7801"><a href="#u5BF9_u79F0_u5BC6_u7801_u4E0E_u975E_u5BF9_u79F0_u5BC6_u7801" class="headerlink" title="对称密码与非对称密码"></a>对称密码与非对称密码</h2><p>对称密码：加密和解密使用相同的秘钥<br>非对称：加密和解密是用不同的秘钥。</p>
<p>两者不能相互取代，也无法区分哪个更安全。是否更安全主要取决于秘钥的长度以及破译密文所需要的计算量。</p>
<h2 id="java_u4E2D_u7684_u7C7B"><a href="#java_u4E2D_u7684_u7C7B" class="headerlink" title="java中的类"></a>java中的类</h2><ol>
<li>消息编码：BASE64Encoder,BASE64Decoder</li>
<li>消息摘要：MessageDigest</li>
<li>对称密码：KeyGenerator，SecretKey，Cipher</li>
<li>非对称密码：KeyPairGenerator,KeyFactory,KeyPair,PublicKey,PrivateKey,Cipher</li>
<li>数字签名：Signature</li>
</ol>
<h2 id="Base64_u7684_u7F16_u7A0B_u4F7F_u7528"><a href="#Base64_u7684_u7F16_u7A0B_u4F7F_u7528" class="headerlink" title="Base64的编程使用"></a>Base64的编程使用</h2><h3 id="Base64_u7B97_u6CD5_u5B9A_u4E49"><a href="#Base64_u7B97_u6CD5_u5B9A_u4E49" class="headerlink" title="Base64算法定义"></a>Base64算法定义</h3><p>是一种基于64个字符的编码算法，以任意8位字节序列组合的描述形式，这种形式不容易直接识别。<br>Base64秘钥：就是Base64字符映射表。</p>
<h3 id="Base64_u7F16_u7A0B_u4F7F_u7528"><a href="#Base64_u7F16_u7A0B_u4F7F_u7528" class="headerlink" title="Base64编程使用"></a>Base64编程使用</h3><p><img src="http://7xo4v8.com1.z0.glb.clouddn.com/base64.png" alt="Base64编程使用"></p>
<p>jdk本身没有自带，需要导入sun提供的BASE64相关jar包。</p>
<h3 id="Base64_u7B97_u6CD5_u7684_u5B9E_u9645_u5E94_u7528"><a href="#Base64_u7B97_u6CD5_u7684_u5B9E_u9645_u5E94_u7528" class="headerlink" title="Base64算法的实际应用"></a>Base64算法的实际应用</h3><p>最早被用在电子邮件中，由于邮件只允许传输ASCII码，所以需要用Base64编码。通过telnet远程登录邮箱可以看到使用Base64编码的账号和密码等信息。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p>极客学院课程</p>
]]></content>
    <summary type="html">
    <![CDATA[密码学相关信息]]>
    
    </summary>
    
      <category term="密码学" scheme="http://blog.onlycatch.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://blog.onlycatch.com/hello-world/"/>
    <id>http://blog.onlycatch.com/hello-world/</id>
    <published>2016-01-19T09:34:37.000Z</published>
    <updated>2016-01-19T09:34:37.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ shit</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Hexo 使用举例]]>
    
    </summary>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP三次握手和四次握手]]></title>
    <link href="http://blog.onlycatch.com/tcp-handshakes/"/>
    <id>http://blog.onlycatch.com/tcp-handshakes/</id>
    <published>2016-01-19T08:33:33.000Z</published>
    <updated>2016-01-23T14:55:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="TCP_u8FDE_u63A5_u5EFA_u7ACB_u65F6_u7684_u4E09_u6B21_u63E1_u624B"><a href="#TCP_u8FDE_u63A5_u5EFA_u7ACB_u65F6_u7684_u4E09_u6B21_u63E1_u624B" class="headerlink" title="TCP连接建立时的三次握手"></a>TCP连接建立时的三次握手</h2><p>TCP是面向连接的通信，所以在使用TCP通信之前，必须先建立连接。在连接正式建立之前，需要经过一个被称为“三次握手”（three-way handshake)的过程：</p>
<h3 id="u4E09_u6B21_u63E1_u624B"><a href="#u4E09_u6B21_u63E1_u624B" class="headerlink" title="三次握手"></a>三次握手</h3><p>连接建立的前提是服务端需要事先启动并监听到某个端口。</p>
<ol>
<li>客户端向服务端发送SYN报文</li>
<li>服务端收到SYN报文之后，向客户端发送确认报文ACK和SYN报文</li>
<li>客户端向服务端发送确认报文ACK<br>图解如下：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/three-way-handshake.png" alt="TCP三次握手"></li>
</ol>
<h3 id="u4E3A_u4EC0_u4E48_u9700_u8981_u4E09_u6B21_u63E1_u624B"><a href="#u4E3A_u4EC0_u4E48_u9700_u8981_u4E09_u6B21_u63E1_u624B" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><p>这个问题在网上有很多，但是我想问的是，如果不需要三次，那么需要几次呢？<br>我们可以把TCP连接建立过程想象成两个人通过qq聊天，A和B，A想和B聊天，但是A需要确认B是否能跟自己聊天，这个过程就可以用来模拟TCP连接的建立。</p>
<blockquote>
<p>A:在吗？<br>B:在的。</p>
</blockquote>
<p>首先A向B发送信息”在吗？“，就像TCP连接中的syn。<br>b收到之后，向A回复”在的“，就像TCP连接中的ack+syn。</p>
<p>其实如果是聊天，AB两句话过后就可以谈正事了。其实TCP也是这样，按道理也可以开始数据传输了，第三次就可以携带数据。但是为什么还需要三次握手呢？<br>我们都知道，TCP是提供的是数据的可靠传输。为了达到这个目的，就需要考虑各种异常情况，然后避免异常情况，对于TCP连接的建立来说，三次握手可以避免<strong>已失效的连接请求报文段</strong>突然又传到了服务端，因而产生错误。</p>
<p>假设客户端向服务端发送了请求连接的报文，但是报文丢失了，从而也没收到服务端返回的确认报文。于是客户端再次发送一个请求连接报文，而这次的报文顺利到达了服务端，服务端返回了确认报文。但是如果第一次的报文由于网络原因又到达了服务端，而这个报文已经被认为是失效的了，但是服务端是无法确定的，所以服务端还是会返回给客户端确认报文，同意建立连接，如果不采用三次握手，那么刚才的情况就会建立两个连接，而实际上只需要一个连接，这样就会造成资源浪费。<br>三次握手就解决了上面的这个问题，因为服务端还需要客户端的第二次确认，而对于上面的这种情况，客户端是知道第一个报文是废弃的，所以它就不会发送给服务端确认报文，所以就不会建立第二个连接。</p>
<p>关于三次握手我们可以想象到生活中的好多场景，比如施工的时候，需要一起协作，可能两个人会有如下对话：<br>A:准备好了吗？<br>B:准备好了<br>A:走起！<br>然后AB两人就一起做点什么事情。</p>
<h3 id="TCP_u4E09_u6B21_u63E1_u624B_u7684_u8FC7_u7A0B_u4E2D_u53EF_u4EE5_u643A_u5E26_u6570_u636E_u5417_uFF1F"><a href="#TCP_u4E09_u6B21_u63E1_u624B_u7684_u8FC7_u7A0B_u4E2D_u53EF_u4EE5_u643A_u5E26_u6570_u636E_u5417_uFF1F" class="headerlink" title="TCP三次握手的过程中可以携带数据吗？"></a>TCP三次握手的过程中可以携带数据吗？</h3><p>第一次握手和第二次握手都不能携带数据，但是都需要消耗掉一个序号。<br>第三次握手的ACK报文可以携带数据，但是如果不携带数据则不消耗序号。<br>详细了解可以参考这里：<a href="http://www.tuicool.com/articles/VJjE7bU" target="_blank" rel="external">点击</a></p>
<h2 id="TCP_u8FDE_u63A5_u65AD_u5F00_u65F6_u7684_u56DB_u6B21_u63E1_u624B"><a href="#TCP_u8FDE_u63A5_u65AD_u5F00_u65F6_u7684_u56DB_u6B21_u63E1_u624B" class="headerlink" title="TCP连接断开时的四次握手"></a>TCP连接断开时的四次握手</h2><h3 id="u56DB_u6B21_u63E1_u624B"><a href="#u56DB_u6B21_u63E1_u624B" class="headerlink" title="四次握手"></a>四次握手</h3><p>TCP连接在断开的时候也很复杂，需要四次握手：   </p>
<ol>
<li>主动发起断开请求的一方向被动方发送FIN报文</li>
<li>被动方收到报文后向主动方先发送一个ACK报文</li>
<li>被动方向主动方发送FIN报文，然后等待主动方的确认，收到主动方确认报文后断开连接。</li>
<li>主动方向被动方发送ACK报文后等待两个MSL时间后断开连接。</li>
</ol>
<p>需要注意的是:这里的描述是“主动方”和“被动方”，而不是“客户端”和”服务端”，因为发起连接关闭请求的，可以是客户端，也可以是服务端。</p>
<p>图示：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/four-way-handshake.png" alt="TCP断开时的四次握手"></p>
<p>这个过程可以想象成两个同事中午一起去吃饭，相约楼梯口见。<br>A:吃饭去?<br>B:等一下（B可能有一些事情要继续处理一下）<br>…<br>B:走！（处理完了，B告诉A可以走了）<br>A:走！（A再发一个确认）<br>A发送完最后一条消息之后，等待一会儿（2MSL)，如果B没有任何回应了，可能B已经在路上了，所以自己也就出发去电梯口了。</p>
<h3 id="u4E3A_u4EC0_u4E48_u4E3B_u52A8_u5173_u95ED_u7684_u4E00_u65B9_u6700_u540E_u8981_u7B49_u5F852MSL_u7684_u65F6_u95F4_uFF1F"><a href="#u4E3A_u4EC0_u4E48_u4E3B_u52A8_u5173_u95ED_u7684_u4E00_u65B9_u6700_u540E_u8981_u7B49_u5F852MSL_u7684_u65F6_u95F4_uFF1F" class="headerlink" title="为什么主动关闭的一方最后要等待2MSL的时间？"></a>为什么主动关闭的一方最后要等待2MSL的时间？</h3><ol>
<li>为了保证最后发送的确认报文能够到达被动方，从而可靠地实现TCP全双工连接的终止。因为这个报文有可能会丢失，如果丢失了，被动方就要重传FIN这个报文，并且主动方要能够收到重传的这个报文，而如果重传，就需要等待2MSL的时间（ACK的时间+重传的时间），所以，如果主动方不到2MSL就关闭了，那么就可能收不到被动方重传的报文，就会导致被动方无法正常关闭。</li>
<li>为了防止”已失效的连接请求报文段”出现在本连接中（允许老的重复报文在网络中消失）。主动方发完最后一个ACK报文之后，等待2MSL，就可以使本连接持续时间内所产生的所有报文都在网络中消失，这样就可以在下一次连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h2 id="TCP_u8FDE_u63A5_u671F_u95F4_u5BA2_u6237_u7AEF_u670D_u52A1_u7AEF_u72B6_u6001"><a href="#TCP_u8FDE_u63A5_u671F_u95F4_u5BA2_u6237_u7AEF_u670D_u52A1_u7AEF_u72B6_u6001" class="headerlink" title="TCP连接期间客户端服务端状态"></a>TCP连接期间客户端服务端状态</h2><h3 id="u72B6_u6001_u56FE"><a href="#u72B6_u6001_u56FE" class="headerlink" title="状态图"></a>状态图</h3><p>下面的图很好的解释了在连接建立时，建立后，连接释放时服务端和客户端的状态。<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/tcp-state.gif" alt="TCP状态图"><br>下面的图也很好<br><img src="https://upload.wikimedia.org/wikipedia/commons/a/a2/Tcp_state_diagram_fixed.svg" alt="状态图"></p>
<h3 id="TIME_WAIT_u72B6_u6001"><a href="#TIME_WAIT_u72B6_u6001" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p>TIME_WAIT状态之所以会存在，就是因为上面讲的：1）可靠地关闭TCP连接2）等待老的重复报文消失。<br>在TCP连接关闭的时候，主动关闭的一方会进入时间长达2MSL的TIME_WAIT状态，而这个状态下，连接并没有关闭。所以，如果服务器上TIME_WAIT状态的连接过多的话，可能会造成新的连接建立不了，从而影响服务器响应，可以参考这里：<a href="http://huoding.com/2013/12/31/316" target="_blank" rel="external">http://huoding.com/2013/12/31/316</a></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>《Unix网络编程 卷1：套接字联网API》</li>
<li>《计算机网络（第五版）》</li>
<li><a href="http://blog.csdn.net/wenqian1991/article/details/40110703（推荐）" target="_blank" rel="external">http://blog.csdn.net/wenqian1991/article/details/40110703（推荐）</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[TCP连接建立时的三次握手以及连接断开时的四次握手，以及过程中客户端与服务端各自的状态。]]>
    
    </summary>
    
      <category term="TCP" scheme="http://blog.onlycatch.com/tags/TCP/"/>
    
      <category term="基础" scheme="http://blog.onlycatch.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="网络" scheme="http://blog.onlycatch.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[流量劫持]]></title>
    <link href="http://blog.onlycatch.com/traffic-hijack/"/>
    <id>http://blog.onlycatch.com/traffic-hijack/</id>
    <published>2016-01-16T15:23:33.000Z</published>
    <updated>2016-01-19T09:32:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6D41_u91CF_u52AB_u6301"><a href="#u6D41_u91CF_u52AB_u6301" class="headerlink" title="流量劫持"></a>流量劫持</h2><h3 id="u4EC0_u4E48_u662F_u6D41_u91CF_u52AB_u6301_uFF1F"><a href="#u4EC0_u4E48_u662F_u6D41_u91CF_u52AB_u6301_uFF1F" class="headerlink" title="什么是流量劫持？"></a>什么是流量劫持？</h3><p>流量劫持，就是通过某种手段得到我们上网的时候传输的数据，然后对这些数据进行篡改或者窥探，以达到劫持者的目的。在我们生活中最常见的应该就属运营商流量劫持了，比如我们流量一个网页的时候，如果我们输错了网址，可能就会跳到一个运营商的提示页面，提示网址错误，同时这个页面里会有运营商的一些广告等信息。<br>由于网络分为很多层，典型的OSI模型，网络分为七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。每一层都有发生流量劫持的可能。下面是常见的一些流量劫持：</p>
<ul>
<li>Hub 嗅探</li>
<li>MAC 欺骗</li>
<li>MAC 冲刷</li>
<li>ARP 攻击</li>
<li>DHCP 钓鱼</li>
<li>DNS 劫持</li>
<li>CDN 入侵</li>
<li>路由器 弱口令</li>
<li>路由器 CSRF</li>
<li>PPPoE 钓鱼</li>
<li>蜜罐代理</li>
<li>WiFi 弱口令</li>
<li>WiFi 伪热点</li>
<li>WiFi 强制断线</li>
<li>WLAN 基站钓鱼</li>
</ul>
<p>根据手段的不同，基本可以分为两类：</p>
<ol>
<li>DNS劫持：通过将通过劫持掉域名的DNS解析结果，将HTTP请求劫持到特定IP上，使得客户端和攻击者的服务器建立TCP连接，而非和目标服务器直接连接，这样攻击者就可以对内容进行窃取或篡改。在极端的情况下甚至攻击者可能伪造目标网站页面进行钓鱼攻击。</li>
<li>直接流量修改：在数据通路上对页面进行固定的内容插入，比如广告弹窗等。在这种情况下，虽然客户端和服务器是直接建立的连接，但是数据内容依然可能遭到野蛮破坏。</li>
</ol>
<h2 id="u6D41_u91CF_u52AB_u6301_u7684_u5371_u5BB3"><a href="#u6D41_u91CF_u52AB_u6301_u7684_u5371_u5BB3" class="headerlink" title="流量劫持的危害"></a>流量劫持的危害</h2><p>不同网络层次上发生的劫持造成的危害可能不太一样，但是都会造成用户信息泄露，隐私被窥探。<br>不同的劫持方式，获得的流量也有所差异。DNS劫持，只能截获通过域名发起的流量，直接使用 IP 地址的通信则不受影响；CDN入侵，只有浏览网页或下载时才有风险，其他场合则毫无问题；而网关被劫持，用户所有流量都难逃魔掌。<br>但流量劫持也有有用的一面，比如我们现在经常用的CDN，就可以算作一种流量劫持，它通过DNS解析，把域名解析到距离用户近的服务器上，减少了资源文件的响应时间。</p>
<h2 id="u5404_u79CD_u6D41_u91CF_u52AB_u6301_u7684_u539F_u7406"><a href="#u5404_u79CD_u6D41_u91CF_u52AB_u6301_u7684_u539F_u7406" class="headerlink" title="各种流量劫持的原理"></a>各种流量劫持的原理</h2><h3 id="Hub_u55C5_u63A2"><a href="#Hub_u55C5_u63A2" class="headerlink" title="Hub嗅探"></a>Hub嗅探</h3><p>Hub的工作原理是通过广播将一个接口收到的数据包群发到所有的接口上，这样任意接口都能获取到所有数据，用户隐私也就无从谈起。<br>这种设备目前唯一可用之处就是旁路嗅探。利用广播的特性，可以非常方便分析其他设备的通信，例如抓取机顶盒的数据包而不影响正常通信。</p>
<h3 id="MAC_u6B3A_u9A97_uFF08_u4EA4_u6362_u673A_uFF09"><a href="#MAC_u6B3A_u9A97_uFF08_u4EA4_u6362_u673A_uFF09" class="headerlink" title="MAC欺骗（交换机）"></a>MAC欺骗（交换机）</h3><p>交换机的工作原理与Hub不同，交换机可以绑定MAC地址和接口，数据包只发送到一个终端。但是如果没有事先配置好MAC地址和接口，而是采用自动学习的方式，即根据某个接口发出的包，自动关联该包的源地址到此接口。那么就可以被黑客通过伪造某个用户的MAC地址，而导致交换机将该用户的所有数据都发到黑客机器上。同时，被劫持的用户将无法上网。</p>
<h3 id="MAC_u51B2_u5237_uFF08_u4EA4_u6362_u673A_uFF09"><a href="#MAC_u51B2_u5237_uFF08_u4EA4_u6362_u673A_uFF09" class="headerlink" title="MAC冲刷（交换机）"></a>MAC冲刷（交换机）</h3><p>如果交换机发现了一个之前没有遇到过的MAC地址，那么就会将数据包广播到所有的接口。由于交换机的硬件配置有限，显然不可能无限多的记录地址对应条目。我们不停伪造不重复的源地址，交换机里的记录表很快就会填满，甚至覆盖原有的学习记录，用户的数据包无法正常转发，只能广播到所有接口上了。</p>
<h3 id="ARP_u653B_u51FB"><a href="#ARP_u653B_u51FB" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><p>ARP：地址解析协议，即根据IP地址，解析出对应的MAC地址。主机A为了获取主机B的对应的MAC地址，需要广播ARP数据包，包中包含了主机B的IP地址，ARP数据包会被同一链路上的所有主机和路由器接收，主机B收到数据包之后发现自己的IP地址与ARP数据包中的IP地址一致，就将自己的MAC地址响应给主机A。<br>ARP攻击就是通过冒充主机B，将自己的MAC地址抢在主机B之前发送给主机A，这样，发送到主机B的IP地址的数据就会被错误的发送给冒充方。</p>
<h3 id="DHCP_u9493_u9C7C"><a href="#DHCP_u9493_u9C7C" class="headerlink" title="DHCP钓鱼"></a>DHCP钓鱼</h3><p>DHCP（Dynamic Host Configuration Protocol):动态主机配置协议。作用是为主机动态分配IP地址。DHCP的工作机制简单来说就是需要分配IP地址的主机向DHCP服务器广播发送报文（目的地址是255.255.255.255，由于自己还没有IP地址，所以将源地址设置为0.0.0.0），在本网络上的所有主机都能收到这个广播的数据包，但是只有DHCP服务器才对此广播报文进行回答，然后该机器分配一个IP地址。如果存在多个DHCP服务器，则分别予以回复；用户则选择最先收到的。<br>DHCP钓鱼就是利用这个机制，如果一个黑客自己也启动了DHCP服务器，那么就可以收到客户主机的DHCP请求报文，如果黑客在真正的DHCP服务器返回数据之前返回一个IP地址，那么客户主机的所有数据就可以被黑客控制。</p>
<h3 id="DNS_u52AB_u6301"><a href="#DNS_u52AB_u6301" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>DNS的作用就是将域名转换成IP地址。DNS劫持就是将某个域名解析到黑客指定的IP地址，而如果黑客在此IP地址所在机器上设置了HTTP代理，那么用户将几乎看不出任何破绽，但是黑客就可以获取所有数据流量。</p>
<h3 id="CDN_u5165_u4FB5"><a href="#CDN_u5165_u4FB5" class="headerlink" title="CDN入侵"></a>CDN入侵</h3><p>CDN主要用来缓存网站的静态数据文件，以提高网站加载速度，分担网站压力。如果CDN服务器被入侵，那么落到CDN服务器上的请求响应内容就可以被篡改。有些CDN厂商不太靠谱，为了省流量不按套路出牌，超过了缓存时间也不更新，甚至还有忽略URL问号后面的参数，导致程序猿们在资源更新的问题上头疼不已。</p>
<h2 id="HTTPS_u4E0E_u6D41_u91CF_u52AB_u6301"><a href="#HTTPS_u4E0E_u6D41_u91CF_u52AB_u6301" class="headerlink" title="HTTPS与流量劫持"></a>HTTPS与流量劫持</h2><p>对于通过HTTP协议通讯的应用来说，发生流量劫持的根本原因是<strong>HTTP协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验</strong>。没有办法校验通信对方的身份，所以DNS劫持就大行其道。而无法对数据完整性进行校验旧导致了直接数据内容的篡改。而HTTPS却能解决这两个问题。<br>因为HTTPS的证书认证能够解决无法对通信对方的身份认证的问题，而内容加密传输则达到了对数据完整性校验的目的。</p>
<h3 id="HTTPS_u539F_u7406_u7B80_u4ECB"><a href="#HTTPS_u539F_u7406_u7B80_u4ECB" class="headerlink" title="HTTPS原理简介"></a>HTTPS原理简介</h3><p>HTTPS是在HTTP与TCP层之间增加了安全层，安全层是通过SSL以及其现代替代协议TLS来实现的。<br>HTTPS在请求开始之前客户端和服务器端有一个握手机制，握手的主要作用有两个：</p>
<ol>
<li>服务端认证：客户端通过判断服务端的证书是否合法有效，以决定是否信任该服务端。</li>
<li>协商秘钥：客户端服务端协商确定一个秘钥，用于数据传输过程中对数据进行加密。<br>握手过程的解释图：<br><img src="http://www.fenesky.com/images/TLS.svg" alt="tls握手图"></li>
</ol>
<p>关于HTTPS握手，可以参考下面两篇文章</p>
<ol>
<li><a href="http://www.fenesky.com/blog/2014/07/19/how-https-works.html" target="_blank" rel="external">http://www.fenesky.com/blog/2014/07/19/how-https-works.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>流量劫持可能发生在网络通讯中的多个层次。</li>
<li>流量劫持大致可以分为DNS劫持和直接内容修改两种，虽然实施的手段不同，但本质都是一样的。</li>
<li>之所以能够发生流量劫持，原因有两个：1）无法对通信双方身份做认证2）无法对数据的完整性进行校验。HTTPS能解决这个问题，但仅限于HTTP协议应用。</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://yq.aliyun.com/articles/2666" target="_blank" rel="external">http://yq.aliyun.com/articles/2666</a> （非常推荐）</li>
<li><a href="http://div.io/topic/907" target="_blank" rel="external">http://div.io/topic/907</a></li>
<li><a href="http://www.huxiu.com/article/135293/1.html" target="_blank" rel="external">http://www.huxiu.com/article/135293/1.html</a></li>
<li><a href="https://www.wosign.cn/News/Https_SSLStrip.htm" target="_blank" rel="external">https://www.wosign.cn/News/Https_SSLStrip.htm</a></li>
<li><a href="http://fex.baidu.com/blog/2014/04/traffic-hijack/(非常推荐" target="_blank" rel="external">http://fex.baidu.com/blog/2014/04/traffic-hijack/(非常推荐</a>)</li>
<li><a href="http://fex.baidu.com/blog/2014/04/traffic-hijack-2/(非常推荐" target="_blank" rel="external">http://fex.baidu.com/blog/2014/04/traffic-hijack-2/(非常推荐</a>)</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[流量劫持入门知识]]>
    
    </summary>
    
      <category term="http" scheme="http://blog.onlycatch.com/tags/http/"/>
    
      <category term="https" scheme="http://blog.onlycatch.com/tags/https/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Linux]xargs命令]]></title>
    <link href="http://blog.onlycatch.com/xargs-in-linux/"/>
    <id>http://blog.onlycatch.com/xargs-in-linux/</id>
    <published>2016-01-14T14:45:19.000Z</published>
    <updated>2016-01-17T14:29:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="xargs_u547D_u4EE4_u7684_u4F5C_u7528"><a href="#xargs_u547D_u4EE4_u7684_u4F5C_u7528" class="headerlink" title="xargs命令的作用"></a>xargs命令的作用</h2><p>像很多人一样，我一开始的时候也迫切想知道这个命令的作用，但是到目前为止，我的确是没有用过这个命令。但是我发现别人在用这个命令，于是我便想知道这个命令的作用，于是我使用了<code>man xargs</code>。<br>它给我的解释是：<code>xargs - build and execute command lines from standard input</code>，就是从构建并且执行来自标准输入中的命令行。<br>看不懂？没错，我相信每个人刚接触这个命令的说明的收都看不懂。而且的确，这个命令也很让人迷惑。我们还是先从例子开始看吧。</p>
<h2 id="xargs_u4F7F_u7528_u4E3E_u4F8B"><a href="#xargs_u4F7F_u7528_u4E3E_u4F8B" class="headerlink" title="xargs使用举例"></a>xargs使用举例</h2><h3 id="u8BFB_u53D6_u8F93_u5165_u6570_u636E_uFF0C_u91CD_u65B0_u683C_u5F0F_u5316_u540E_u8F93_u51FA"><a href="#u8BFB_u53D6_u8F93_u5165_u6570_u636E_uFF0C_u91CD_u65B0_u683C_u5F0F_u5316_u540E_u8F93_u51FA" class="headerlink" title="读取输入数据，重新格式化后输出"></a>读取输入数据，重新格式化后输出</h3><p>假设我们有一个文本文件，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt</span><br><span class="line">a b c d e f g h</span><br><span class="line">i j k l m n o p q</span><br><span class="line">r s t u v w x y z</span><br></pre></td></tr></table></figure></p>
<p>data.txt中的文件是换行显示的。</p>
<ul>
<li><p>多行输入变成单行输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt |xargs</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>
</li>
<li><p>-n 控制多行输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt |xargs -n4</span><br><span class="line">a b c d</span><br><span class="line">e f g h</span><br><span class="line">i j k l</span><br><span class="line">m n o p</span><br><span class="line">q r s t</span><br><span class="line">u v w x</span><br><span class="line">y z</span><br></pre></td></tr></table></figure>
</li>
<li><p>-d 指定分隔符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'testAtestAtestAtest'</span>|xargs <span class="operator">-d</span>A</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">test</span> <span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># -d 与-n 一起使用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'testAtestAtestAtest'</span>|xargs <span class="operator">-d</span>A -n2</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="u8BFB_u53D6stdin_2C_u5C06_u683C_u5F0F_u5316_u540E_u7684_u53C2_u6570_u4F20_u9012_u7ED9_u67D0_u4E9B_u547D_u4EE4"><a href="#u8BFB_u53D6stdin_2C_u5C06_u683C_u5F0F_u5316_u540E_u7684_u53C2_u6570_u4F20_u9012_u7ED9_u67D0_u4E9B_u547D_u4EE4" class="headerlink" title="读取stdin,将格式化后的参数传递给某些命令"></a>读取stdin,将格式化后的参数传递给某些命令</h3><ol>
<li><p>当你尝试用rm 删除太多的文件，你可能得到一个错误信息：/bin/rm Argument list too long. 用xargs 去避免这个问题<br><code>find ~ -name ‘*.log’ -print0 | xargs -0 rm -f</code></p>
</li>
<li><p>获得/etc/ 下所有<em>.conf 结尾的文件列表，有几种不同的方法能得到相同的结果，下面的例子仅仅是示范怎么实用xargs ，在这个例子中实用 xargs将find 命令的输出传递给ls -l<br>`find /etc -name “</em>.conf” | xargs ls –l`</p>
</li>
<li><p>假如你有一个文件包含了很多你希望下载的URL, 你能够使用xargs 下载所有链接<br><code>cat url-list.txt | xargs wget –c</code></p>
</li>
<li><p>查找所有的jpg 文件，并且压缩它<br><code>find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz</code></p>
</li>
<li><p>拷贝所有的图片文件到一个外部的硬盘驱动<br><code>ls *.jpg | xargs -n1 -i cp {} /external-hard-drive/directory</code></p>
</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>In general xargs is used like this<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog | xargs utility</span><br></pre></td></tr></table></figure></p>
<p>where prog is expected to output one or more newline/space separated results. The trick is that xargs does not! nessarly call utility once for each result, instead it splits the result list into sublists and calls utility for every sublist. If you want to force xargs to call utility for every single result you will need to invoke it with xargs -L1.</p>
<p>Note that xargs promises you that the sublist sent to utility is shorter than <em>ARG_MAX</em> (this is how it avoids those dreaded Argument list to long errors). You can get the current value of <em>ARG_MAX</em> using getconf ARG_MAX</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://man.linuxde.net/xargs" target="_blank" rel="external">http://man.linuxde.net/xargs</a></li>
<li><a href="http://unix.stackexchange.com/questions/24954/when-is-xargs-needed" target="_blank" rel="external">http://unix.stackexchange.com/questions/24954/when-is-xargs-needed</a></li>
<li><a href="https://en.wikipedia.org/wiki/Xargs" target="_blank" rel="external">https://en.wikipedia.org/wiki/Xargs</a></li>
<li><a href="http://stackoverflow.com/questions/1898044/understanding-the-unix-command-xargs" target="_blank" rel="external">http://stackoverflow.com/questions/1898044/understanding-the-unix-command-xargs</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[linux中，xargs命令的应用]]>
    
    </summary>
    
      <category term="Linux" scheme="http://blog.onlycatch.com/tags/Linux/"/>
    
      <category term="Linux命令" scheme="http://blog.onlycatch.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP响应码301和302的区别]]></title>
    <link href="http://blog.onlycatch.com/differences-between-301-302/"/>
    <id>http://blog.onlycatch.com/differences-between-301-302/</id>
    <published>2016-01-14T14:16:50.000Z</published>
    <updated>2016-01-14T14:24:59.000Z</updated>
    <content type="html"><![CDATA[<p>301：永久重定向<br>302：临时重定向<br>302重定向与网址劫持:即A网站将自己302重定向到B网站，某些搜索引擎会收录A网站的网址，而显示的却是B网站的内容。   </p>
<p>以下内容转自：<a href="http://www.jameswxx.com/web/301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="external">http://www.jameswxx.com/web/301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB/</a><br>原文写的清晰明了，保存一份。</p>
<h2 id="u4EC0_u4E48_u662F301_u8F6C_u5411_3F_u4EC0_u4E48_u662F301_u91CD_u5B9A_u5411_3F"><a href="#u4EC0_u4E48_u662F301_u8F6C_u5411_3F_u4EC0_u4E48_u662F301_u91CD_u5B9A_u5411_3F" class="headerlink" title="什么是301转向?什么是301重定向?"></a>什么是301转向?什么是301重定向?</h2><p>301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。</p>
<h2 id="u4EC0_u4E48_u662F302_u91CD_u5B9A_u5411_3F"><a href="#u4EC0_u4E48_u662F302_u91CD_u5B9A_u5411_3F" class="headerlink" title="什么是302重定向?"></a>什么是302重定向?</h2><p>302重定向又称之为302代表暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向(temporary redirect)，一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。</p>
<h2 id="301_u91CD_u5B9A_u5411_u4E0E302_u91CD_u5B9A_u5411_u7684_u533A_u522B"><a href="#301_u91CD_u5B9A_u5411_u4E0E302_u91CD_u5B9A_u5411_u7684_u533A_u522B" class="headerlink" title="301重定向与302重定向的区别"></a>301重定向与302重定向的区别</h2><p>302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>
<h2 id="u4E3A_u4EC0_u4E48302__u91CD_u5B9A_u5411_u548C_u7F51_u5740_u52AB_u6301_u6709_u5173_u8054"><a href="#u4E3A_u4EC0_u4E48302__u91CD_u5B9A_u5411_u548C_u7F51_u5740_u52AB_u6301_u6709_u5173_u8054" class="headerlink" title="为什么302 重定向和网址劫持有关联"></a>为什么302 重定向和网址劫持有关联</h2><p>从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。</p>
<p>比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL 劫持的可能性。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p>
<p>302 重定向所造成的网址URL劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的数据中心转换中，302 重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[HTTP响应状态码301和302的区别]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.onlycatch.com/tags/HTTP/"/>
    
      <category term="网络" scheme="http://blog.onlycatch.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[队列与栈的互相实现]]></title>
    <link href="http://blog.onlycatch.com/queue-and-stack-implements/"/>
    <id>http://blog.onlycatch.com/queue-and-stack-implements/</id>
    <published>2016-01-14T14:00:32.000Z</published>
    <updated>2016-01-14T14:14:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5982_u4F55_u4F7F_u7528LIFO_u7684_u6808_u5B9E_u73B0_u961F_u5217FIFO_u7684_u529F_u80FD_uFF1F"><a href="#u5982_u4F55_u4F7F_u7528LIFO_u7684_u6808_u5B9E_u73B0_u961F_u5217FIFO_u7684_u529F_u80FD_uFF1F" class="headerlink" title="如何使用LIFO的栈实现队列FIFO的功能？"></a>如何使用LIFO的栈实现队列FIFO的功能？</h2><p>思路：将一个栈中的所有元素依次取出并放入另外一个栈，那么第二个栈中的元素出栈顺序就与第一个栈中元素的入栈顺序一致。<br>其实可以将栈想象成一个木桶，栈中的元素想象成大饼，如果我们将一个桶中的饼倒入另一个桶中，那么第二个桶中最上面的饼就是第一个桶中最下面的那张。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueByStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Stack&lt;String&gt; putStack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;String&gt; popStack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">		putStack.push(data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!putStack.isEmpty()) &#123;</span><br><span class="line">			popStack.push(putStack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> popStack.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5982_u4F55_u4F7F_u7528FIFO_u7684_u961F_u5217_u5B9E_u73B0LIFO_u7684_u529F_u80FD_uFF1F"><a href="#u5982_u4F55_u4F7F_u7528FIFO_u7684_u961F_u5217_u5B9E_u73B0LIFO_u7684_u529F_u80FD_uFF1F" class="headerlink" title="如何使用FIFO的队列实现LIFO的功能？"></a>如何使用FIFO的队列实现LIFO的功能？</h2><p>思路：每次存入元素的时候，都要想办法保证最后加入的元素是放在队列头部的，这样才能保证取的时候是按照LIFO的顺序。<br>可以借助汉诺塔问题思考一下。</p>
<p>下面是我写的第一个版本的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackByQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; tmpQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">			String poll = queue.poll();</span><br><span class="line">			tmpQueue.add(poll);</span><br><span class="line">		&#125;</span><br><span class="line">		queue.add(data);</span><br><span class="line">		<span class="keyword">while</span> (!tmpQueue.isEmpty()) &#123;</span><br><span class="line">			queue.add(tmpQueue.poll());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> queue.poll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后来发现效率不高，于是有了下面的升级版本(空间换时间)：<br>思路：以空间换时间，增加了一个变量，用于标记当前正在使用的队列。好处是减少了每次数据元素的拷贝。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackByQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; tmpQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> queueInUse = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (queueInUse) &#123;</span><br><span class="line">			tmpQueue.add(data);</span><br><span class="line">			switchQueue(tmpQueue, queue);</span><br><span class="line">			queueInUse = <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			queue.add(data);</span><br><span class="line">			switchQueue(queue, tmpQueue);</span><br><span class="line">			queueInUse = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">switchQueue</span><span class="params">(Queue&lt;String&gt; dest, Queue&lt;String&gt; source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!source.isEmpty()) &#123;</span><br><span class="line">			dest.add(source.poll());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (queueInUse) &#123;</span><br><span class="line">			<span class="keyword">return</span> queue.poll();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> tmpQueue.poll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[如何使用FIFO队列实现LIFO的栈功能？又如何使用LIFO的栈实现FIFO功能呢？]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.onlycatch.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="面试" scheme="http://blog.onlycatch.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL中= null与is null的区别]]></title>
    <link href="http://blog.onlycatch.com/how-is-null-differs-from-equals-null-in-sql/"/>
    <id>http://blog.onlycatch.com/how-is-null-differs-from-equals-null-in-sql/</id>
    <published>2016-01-13T14:32:24.000Z</published>
    <updated>2016-01-14T14:36:43.000Z</updated>
    <content type="html"><![CDATA[<p>类似下面的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">field</span> = <span class="literal">null</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">field</span> <span class="keyword">IS</span> <span class="literal">null</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>第一行SQL将不会返回任何内容，而第二行将会返回field字段为NULL的行。</p>
<p>原因如下：</p>
<blockquote>
<p>在SQL中，null值与另外一个值（包括null值）的逻辑比较（=，！=，&lt;&gt;等），返回的结果也是null，而这个null值在where子句中是被当做false来看待的。null表示”未知“，所以比较的结果也是”未知“。   </p>
</blockquote>
<p>所以，上面的第一条SQL就不会返回任何内容。</p>
<p>如果在SQL中，需要判断某个字段是否为NULL，需要用IS NULL或者 IS NOT NULL,而不能使用=null或者！=null或者&lt;&gt;null。</p>
<p>参考资料：<br><a href="http://jackyrong.iteye.com/blog/2076933" target="_blank" rel="external">http://jackyrong.iteye.com/blog/2076933</a><br><a href="http://stackoverflow.com/questions/9581745/sql-is-null-and-null" target="_blank" rel="external">http://stackoverflow.com/questions/9581745/sql-is-null-and-null</a><br><a href="http://www.w3schools.com/sql/sql_null_values.asp" target="_blank" rel="external">http://www.w3schools.com/sql/sql_null_values.asp</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Why in SQL SELECT * FROM table WHERE field = null does not match records with null field?]]>
    
    </summary>
    
      <category term="MySQl" scheme="http://blog.onlycatch.com/tags/MySQl/"/>
    
      <category term="SQL" scheme="http://blog.onlycatch.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java线程间通信]]></title>
    <link href="http://blog.onlycatch.com/java-thread-communication/"/>
    <id>http://blog.onlycatch.com/java-thread-communication/</id>
    <published>2016-01-10T07:16:25.000Z</published>
    <updated>2016-01-23T15:17:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5171_u4EAB_u5185_u5B58"><a href="#u5171_u4EAB_u5185_u5B58" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存在java多线程中的应用是很频繁的，最简单的例子就是共享变量，即多个线程都读或者写一个变量的值。</p>
<h3 id="volatile_u548Csynchronized_u5173_u952E_u5B57"><a href="#volatile_u548Csynchronized_u5173_u952E_u5B57" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h3><p>volatile关键字：保证了内存可见性，能够保证多个线程在读取volatile修饰的变量时，读取到的数据都是最新的。<br>volatile的写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主存。<br>volatile的读：当读一个volatile变量时，JMM会把线程对应的本地内存置为无效，然后从主存中读取共享变量。</p>
]]></content>
    <summary type="html">
    <![CDATA[曾经面试的时候被问过这样一个问题，当时我的答案是：共享内存，信号量，消息队列。如今已经距离那次面试过去半年多了，我也成长了很多，现在让我再回过头来看看这个问题。]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.onlycatch.com/tags/java/"/>
    
      <category term="多线程" scheme="http://blog.onlycatch.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java中线程的状态以及线程栈分析]]></title>
    <link href="http://blog.onlycatch.com/thread-state-and-analysis/"/>
    <id>http://blog.onlycatch.com/thread-state-and-analysis/</id>
    <published>2016-01-10T04:18:38.000Z</published>
    <updated>2016-01-10T15:06:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="java_u4E2D_u7EBF_u7A0B_u7684_u72B6_u6001"><a href="#java_u4E2D_u7EBF_u7A0B_u7684_u72B6_u6001" class="headerlink" title="java中线程的状态"></a>java中线程的状态</h2><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态。线程刚刚被创建，并且start()方法还未被调用</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态。表示线程正在java虚拟机中执行，但是可能正在等待操作系统的其他资源，比如CPU</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态。表示线程正在等待监视器锁。表示线程正在等待获取监视器锁，以便进入同步方法或者同步代码快，也有可能是从wait（）方法被唤醒而等待再次进入同步方法或者同步代码块</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态。表示当前线程需要等待其他线程执行一些特殊操作，比如当前线程调用了a.wait()方法，它正在等待其他线程调用a.notify或a.notifyAll方法;如果当前线程调用了threada.join(),那么它在等待threada执行完成</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>超时等待。与WAITING的不同在于，该状态有超时时间</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<p>详细介绍：参考Thread内部类:State</p>
<p>WAITING与TIMED_WAITING:<br>调用以下三个方法会进入WAITING状态：</p>
<ul>
<li>Object.wait() 不设置超时时间</li>
<li>Thread.join() 不设置超时时间</li>
<li>LockSupport.park() 不设置超时时间<br>调用下面的方法会进入TIMED_WAITING状态：</li>
<li>Object.wait(time)</li>
<li>Thread.join(time)</li>
<li>Thread.sleep(time)</li>
<li>LockSupport.parkNanos(time)</li>
<li>LockSupport.parkUntil(time)</li>
</ul>
<h2 id="u901A_u8FC7jstack_u67E5_u770B_u7EBF_u7A0B_u72B6_u6001"><a href="#u901A_u8FC7jstack_u67E5_u770B_u7EBF_u7A0B_u72B6_u6001" class="headerlink" title="通过jstack查看线程状态"></a>通过jstack查看线程状态</h2><p>jstack 是一个可以用来打印java进程中的线程堆栈信息的工具。一般都位于jdk安装目录的bin目录下。<br>一般，jstack都用来检测死锁，以及分析当前程序运行状态。</p>
<h3 id="u4F7F_u7528_u65B9_u5F0F"><a href="#u4F7F_u7528_u65B9_u5F0F" class="headerlink" title="使用方式"></a>使用方式</h3><p>jstack [options] pid<br>pid:即进程id，可以通过jps命令查看<br>options:可选选项。一般常用的是-l和-m，-l用于打印详细的堆栈信息，包括当前线程获得到的同步器(AbstractOwnableSynchronizer)。-m则会打印包含C++或C的堆栈信息。</p>
<p>例如：<br>命令：<code>jstack 10968</code> 则会把进程号为10968的进程所包含的线程信息打印出来。<br>其中的部分结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fab88009800 nid=0x2add waiting on condition [0x00007fab8ee92000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">	at test.DeadLockTest.main(DeadLockTest.java:17)</span><br></pre></td></tr></table></figure></p>
<p>命令：<code>jstack -l 10968</code>则会包含当前线程获取到的同步器。<br>其中的部分结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fab88009800 nid=0x2add waiting on condition [0x00007fab8ee92000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">	at test.DeadLockTest.main(DeadLockTest.java:17)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure></p>
<p>可以看到，带-l参数的，在线程信息后面有个’ Locked ownable synchronizers:’信息。</p>
<p>关于jstack的使用，下面两篇文章写的很不错，非常建议一看:</p>
<ol>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps" target="_blank" rel="external">java-thread-dumps</a></li>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps-2" target="_blank" rel="external">java-thread-dumps-2</a></li>
</ol>
<h3 id="u4E0D_u540C_u7EBF_u7A0B_u72B6_u6001_u5728jstack_u4FE1_u606F_u4E2D_u5F62_u5F0F"><a href="#u4E0D_u540C_u7EBF_u7A0B_u72B6_u6001_u5728jstack_u4FE1_u606F_u4E2D_u5F62_u5F0F" class="headerlink" title="不同线程状态在jstack信息中形式"></a>不同线程状态在jstack信息中形式</h3><p>我们来看一下，当线程处于不同状态的时候，通过jstack看到的是什么样子的。</p>
<h4 id="WAITING_u72B6_u6001"><a href="#WAITING_u72B6_u6001" class="headerlink" title="WAITING状态"></a>WAITING状态</h4><p>通过上面的讲解我们知道，线程进入waiting状态可以通过三种方式：1.Object.wait,2.Thread.join,3.LockSupport.park ，那么我们分别来看下，当程序分别通过这三种方式进入WAITING状态的时候，对应的jstack信息是怎样的。</p>
<p>1.Object.wait方式<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// Object.wait</span></span><br><span class="line">		<span class="keyword">synchronized</span> (WaitingTest.class) &#123;</span><br><span class="line">			WaitingTest.class.wait();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack 结果(省略其他部分，下同):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f384c009800 nid=0x2d9c in Object.wait() [0x00007f385268b000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6ddb9a0</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br><span class="line">	at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddb9a0</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br></pre></td></tr></table></figure></p>
<p>2.Thread.join方式<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// Thread.join</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"run"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span> * <span class="number">300</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前线程调用thread线程的join方法</span></span><br><span class="line">		thread.join();</span><br><span class="line">		<span class="comment">// 只有thread的run方法执行完成之后，才会执行输出</span></span><br><span class="line">		System.out.println(<span class="string">"Current thread running"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f88cc009800 nid=0x2f10 in Object.wait() [0x00007f88d5b73000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6ddddf8</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1245</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddddf8</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1319</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>3.LockSupport.park方式<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		LockSupport.park();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f6efc009800 nid=0x2f88 waiting on condition [0x00007f6f034dd000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">304</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h4 id="TIMED_WAITING"><a href="#TIMED_WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>1.Object.wait(time)<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (WaitingTest.class) &#123;</span><br><span class="line">			WaitingTest.class.wait(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007fd598009800 nid=0x301b in Object.wait() [0x00007fd59eea0000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6ddb9b8</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">9</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddb9b8</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>2.Thread.join(time)<br>代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// Thread.join</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"run"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span> * <span class="number">300</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前线程调用thread线程的join方法</span></span><br><span class="line">		thread.join(<span class="number">1000</span> * <span class="number">200</span>);</span><br><span class="line">		<span class="comment">// 只有thread的run方法执行完成之后，才会执行输出</span></span><br><span class="line">		System.out.println(<span class="string">"Current thread running"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f024c009800 nid=0x365c in Object.wait() [0x00007f0254768000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6dddf40</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1253</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6dddf40</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>3.Thread.sleep<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	Thread.currentThread().sleep(<span class="number">1000</span> * <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f54a8009800 nid=0x36eb waiting on condition [0x00007f54ae463000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>4.LockSupport.parkNanos(time) 和 LockSupport.parkUntil(time) 两个方法类似<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	LockSupport.parkNanos(Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007eff98009800 nid=0x37b6 waiting on condition [0x00007effa0141000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:<span class="number">338</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h4 id="BLOCKED_u72B6_u6001"><a href="#BLOCKED_u72B6_u6001" class="headerlink" title="BLOCKED状态"></a>BLOCKED状态</h4><p>BLOCKED状态，表示线程正在等待监视器锁。我们可以通过一个死锁的例子来分析。<br>例子很简单，程序中有两个Waiter线程，WaiterA和WaitB，它们都需要获取两个锁：lock_1和lock_2,但是它们获取锁的顺序不同，因此导致了死锁。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object lock_1 = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object lock_2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> WaiterA().start();</span><br><span class="line">		<span class="keyword">new</span> WaiterB().start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaiterA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 先获取lock_1,然后再获取lock_2</span></span><br><span class="line">			<span class="keyword">synchronized</span> (lock_1) &#123;</span><br><span class="line">				System.out.println(<span class="string">"lock1 get,wait to get lock2"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">synchronized</span> (lock_2) &#123;</span><br><span class="line">					System.out.println(<span class="string">"lock2 get"</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaiterB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 先获取lock_2,然后再获取lock_1</span></span><br><span class="line">			<span class="keyword">synchronized</span> (lock_2) &#123;</span><br><span class="line">				System.out.println(<span class="string">"lock2 get,wait to get lock1"</span>);</span><br><span class="line">				<span class="keyword">synchronized</span> (lock_1) &#123;</span><br><span class="line">					System.out.println(<span class="string">"lock1 get"</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Thread-1"</span> <span class="comment">#10 prio=5 os_prio=0 tid=0x00007f0d800dc800 nid=0x39da waiting for monitor entry [0x00007f0d47bfa000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at test.WaitingTest$WaiterB.run(WaitingTest.java:<span class="number">47</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="string">"Thread-0"</span> <span class="comment">#9 prio=5 os_prio=0 tid=0x00007f0d800da800 nid=0x39d9 waiting for monitor entry [0x00007f0d47cfb000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at test.WaitingTest$WaiterA.run(WaitingTest.java:<span class="number">27</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，上面Thread-1 和Thread-0的状态都是Blocked，原因是它们都在等待监视器锁，而Thread-1 已经获取到了锁0x00000000d6ddc520，正在等待获取0x00000000d6ddc510锁，而0x00000000d6ddc510锁已经被Thread-0获取到了，Thread-0反过来又正在等待获取0x00000000d6ddc520，而这个锁又被Thread-1获取了。<br>在jstack的最后，还有如下信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f0d50004ed8</span> (object <span class="number">0x00000000d6ddc510</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held by <span class="string">"Thread-0"</span></span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f0d500062c8</span> (object <span class="number">0x00000000d6ddc520</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held by <span class="string">"Thread-1"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">	at test.WaitingTest$WaiterB.run(WaitingTest.java:<span class="number">47</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">	at test.WaitingTest$WaiterA.run(WaitingTest.java:<span class="number">27</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure></p>
<p>就是说，已经发现了一个死锁，还有就是关于死锁的详细说明。</p>
<h4 id="RUNNABLE_u72B6_u6001"><a href="#RUNNABLE_u72B6_u6001" class="headerlink" title="RUNNABLE状态"></a>RUNNABLE状态</h4><p>我们写一个BIO的server端，server端绑定一个端口，并通过accept()方法等待客户端链接。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">		ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Socket socket = serverSocket.accept();</span><br><span class="line">			<span class="comment">// do something else</span></span><br><span class="line">			<span class="comment">// ....</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f4b58009800 nid=0x3ab8 runnable [0x00007f4b5ff64000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class="line">	at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class="number">409</span>)</span><br><span class="line">	at java.net.ServerSocket.implAccept(ServerSocket.java:<span class="number">545</span>)</span><br><span class="line">	at java.net.ServerSocket.accept(ServerSocket.java:<span class="number">513</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，此时虽然程序在等待客户端接入，但是程序状态依然是RUNNABLE的。</p>
<h4 id="TERMINATED_u548CNEW_u72B6_u6001"><a href="#TERMINATED_u548CNEW_u72B6_u6001" class="headerlink" title="TERMINATED和NEW状态"></a>TERMINATED和NEW状态</h4><p>这两个状态分别表示线程生命终结和生命开始，在jstack中没有对应的信息显示。</p>
<h4 id="u603B_u7ED3_uFF1A"><a href="#u603B_u7ED3_uFF1A" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>WAITING和TIMED_WAITING的主要不同就在于后者在等待的时候设置了超时时间</li>
<li>通过Object.wait，Thread.join两种方式进入的WAITING或者TIMED_WAITING,通过jstack查看显示的都是wait on monitor,而通过其他方式（Thread.sleep,LockSupport等）进入的WAITING或者TIMED_WAITING,通过jstack查看显示的都是waiting on condition。</li>
<li>BLOCKED状态，通过jstack查看，显示的是waiting for monitor entry，注意与WAITING和TIMED_WAITING的区别。</li>
</ol>
<h2 id="java_u7EBF_u7A0B_u72B6_u6001_u4E4B_u95F4_u7684_u8F6C_u6362"><a href="#java_u7EBF_u7A0B_u72B6_u6001_u4E4B_u95F4_u7684_u8F6C_u6362" class="headerlink" title="java线程状态之间的转换"></a>java线程状态之间的转换</h2><p>java线程通过不同的方法调用进入不同的状态，下面图描述的很清楚：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/state-machine-example-java-6-thread-states.png" alt="java线程状态转换UML"></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps" target="_blank" rel="external">https://sites.google.com/site/threaddumps/java-thread-dumps</a></li>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps-2" target="_blank" rel="external">https://sites.google.com/site/threaddumps/java-thread-dumps-2</a></li>
<li>图片来源：<a href="http://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html" target="_blank" rel="external">http://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html</a></li>
</ol>
<p>顺便推荐个很好的网站：<br>Java中的UML图：<a href="http://www.uml-diagrams.org/examples/java-uml-examples.html" target="_blank" rel="external">http://www.uml-diagrams.org/examples/java-uml-examples.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[java线程有6种不同的状态，不同的状态之间是怎样转换的？在实际程序运行过程中，我们应该如何判断线程处于什么状态呢？]]>
    
    </summary>
    
      <category term="Troubleshooting Tools" scheme="http://blog.onlycatch.com/tags/Troubleshooting-Tools/"/>
    
      <category term="java" scheme="http://blog.onlycatch.com/tags/java/"/>
    
      <category term="jstack" scheme="http://blog.onlycatch.com/tags/jstack/"/>
    
      <category term="线程" scheme="http://blog.onlycatch.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java线程池异常处理最佳实践]]></title>
    <link href="http://blog.onlycatch.com/what-if-exception-occurs-in-threadpool/"/>
    <id>http://blog.onlycatch.com/what-if-exception-occurs-in-threadpool/</id>
    <published>2016-01-07T13:37:30.000Z</published>
    <updated>2016-01-10T14:21:59.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>问题描述：<br>假设我们有一个线程池，由于程序需要，我们向该线程池中提交了好多任务，但是这些任务都没有对异常进行try catch处理，并且运行的时候都抛出了异常。这会对线程池的运行带来什么影响？</p>
</blockquote>
<p>正确答案是：没有影响。<br>想一下，如果是你开发了一个线程池供开发者使用，你会不会对这种情况做处理？想想也是肯定的，不然你提供给别人使用的东西就是有问题的，欠考虑的。而且java线程池的主要开发人员是大名鼎鼎的Doug Lea，你觉得他开发的代码怎么会允许出现这种问题？</p>
<h2 id="u95EE_u9898_u5206_u6790"><a href="#u95EE_u9898_u5206_u6790" class="headerlink" title="问题分析"></a>问题分析</h2><p>接下来我们来看一下java中的线程池是如何运行我们提交的任务的，详细流程比较复杂，这里我们不关注，我们只关注任务执行的部分。java中的线程池用的是ThreadPoolExecutor，真正执行代码的部分是runWorker方法：<code>final void runWorker(Worker w)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略无关部分</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    beforeExecute(wt, task);  </span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run();  <span class="comment">//执行程序逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123; <span class="comment">//捕获RuntimeException</span></span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error x) &#123; <span class="comment">//捕获Error</span></span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;   <span class="comment">//捕获Throwable</span></span><br><span class="line">        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterExecute(task, thrown);  <span class="comment">//运行完成，进行后续处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    task = <span class="keyword">null</span>;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略无关部分</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，程序会捕获包括Error在内的所有异常，并且在程序最后，将出现过的异常和当前任务传递给afterExecute方法。</p>
<p>而ThreadPoolExecutor中的afterExecute方法是没有任何实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，默认情况下，线程池会捕获任务抛出的所有异常，但是不做任何处理。</p>
<h2 id="u5B58_u5728_u95EE_u9898"><a href="#u5B58_u5728_u95EE_u9898" class="headerlink" title="存在问题"></a>存在问题</h2><p>想象下ThreadPoolExecutor这种处理方式会有什么问题？<br>这样做能够保证我们提交的任务抛出了异常不会影响其他任务的执行，同时也不会对用来执行该任务的线程产生任何影响。<br>问题就在<code>afterExecute</code>方法上，这个方法没有做任何处理，所以如果我们的任务抛出了异常，我们也无法立刻感知到。即使感知到了，也无法查看异常信息。</p>
<p>所以，作为一名好的开发者，是不应该允许这种情况出现的。</p>
<h2 id="u5982_u4F55_u907F_u514D_u8FD9_u79CD_u95EE_u9898"><a href="#u5982_u4F55_u907F_u514D_u8FD9_u79CD_u95EE_u9898" class="headerlink" title="如何避免这种问题"></a>如何避免这种问题</h2><p>思路很简单。</p>
<ol>
<li>在提交的任务中将异常捕获并处理，不抛给线程池。</li>
<li>异常抛给线程池，但是我们要及时处理抛出的异常。</li>
</ol>
<p>第一种思路很简单，就是我们提交任务的时候，将所有可能的异常都Catch住，并且自己处理，任务的大致代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//处理所有的业务逻辑</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="comment">//打印日志等</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//其他处理</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>说白了就是把业务逻辑都trycatch起来。<br>但是这种思路的缺点就是：1）所有的不同任务类型都要trycatch，增加了代码量。2）不存在checkedexception的地方也需要都trycatch起来，代码丑陋。</p>
<p>第二种思路就可以避免上面的两个问题。<br>第二种思路又有以下几种实现方式：</p>
<ol>
<li>自定义线程池，继承ThreadPoolExecutor并复写其<code>afterExecute(Runnable r, Throwable t)</code>方法。</li>
<li>实现Thread.UncaughtExceptionHandler接口，实现<code>void uncaughtException(Thread t, Throwable e);</code>方法，并将该handler传递给线程池的ThreadFactory</li>
<li>采用Future模式，将返回结果以及异常放到Future中，在Future中处理</li>
<li>继承ThreadGroup，覆盖其uncaughtException方法。（与第二种方式类似，因为ThreadGroup类本身就实现了Thread.UncaughtExceptionHandler接口)</li>
</ol>
<p>下面是以上几种方式的代码</p>
<h3 id="u65B9_u5F0F1"><a href="#u65B9_u5F0F1" class="headerlink" title="方式1"></a>方式1</h3><p>自定义线程池：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The values have been hard-coded for brevity</span></span><br><span class="line">  ExecutorService pool = <span class="keyword">new</span> CustomThreadPoolExecutor(</span><br><span class="line">      <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... Constructor ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CustomThreadPoolExecutor</span><span class="params">(</span><br><span class="line">      <span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">      TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Exception occurred, forward to handler</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... Perform task-specific cleanup actions</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.terminated();</span><br><span class="line">    <span class="comment">// ... Perform final clean-up actions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u65B9_u5F0F2"><a href="#u65B9_u5F0F2" class="headerlink" title="方式2"></a>方式2</h3><p>实现Thread.UncaughtExceptionHandler接口，实现<code>void uncaughtException(Thread t, Throwable e);</code>方法，并将该handler传递给线程池的ThreadFactory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory factory =</span><br><span class="line">      <span class="keyword">new</span> ExceptionThreadFactory(<span class="keyword">new</span> MyExceptionHandler());</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService pool =</span><br><span class="line">      Executors.newFixedThreadPool(<span class="number">10</span>, factory);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Task()); <span class="comment">// Task is a runnable class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory defaultFactory =</span><br><span class="line">        Executors.defaultThreadFactory();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread.UncaughtExceptionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExceptionThreadFactory</span><span class="params">(</span><br><span class="line">        Thread.UncaughtExceptionHandler handler)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable run)</span> </span>&#123;</span><br><span class="line">      Thread thread = defaultFactory.newThread(run);</span><br><span class="line">      thread.setUncaughtExceptionHandler(handler);</span><br><span class="line">      <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ExceptionReporter</span></span><br><span class="line">      <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Recovery or logging code</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u65B9_u5F0F3"><a href="#u65B9_u5F0F3" class="headerlink" title="方式3"></a>方式3</h3><p>继承ThreadGroup，覆盖其uncaughtException方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadGroup</span> <span class="keyword">extends</span> <span class="title">ThreadGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThreadGroup</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + thread.getName()</span><br><span class="line">              + <span class="string">" died, exception was: "</span>);</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadGroup workerThreads =</span><br><span class="line">      <span class="keyword">new</span> MyThreadGroup(<span class="string">"Worker Threads"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(workerThreads, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> WorkerThread(<span class="string">"Worker Thread"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>确实这种方式与上面通过ThreadFactory来指定UncaughtExceptionHandler是一样的，只是代码逻辑不同，但原理上都是一样的，即给线程池中的每个线程都指定一个UncaughtExceptionHandler。</p>
<p><strong> 注意：上面三种方式针对的都是通过execute(xx)的方式提交任务，如果你提交任务用的是submit()方法，那么上面的三种方式都将不起作用,而应该使用下面的方式 </strong></p>
<h3 id="u65B9_u5F0F4"><a href="#u65B9_u5F0F4" class="headerlink" title="方式4"></a>方式4</h3><p>如果提交任务的时候使用的方法是submit，那么该方法将返回一个Future对象，所有的异常以及处理结果都可以通过future对象获取。<br>采用Future模式，将返回结果以及异常放到Future中，在Future中处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Future&lt;?&gt; future = pool.submit(<span class="keyword">new</span> Task());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      future.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt(); <span class="comment">// Reset interrupted status</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      Throwable exception = e.getCause();</span><br><span class="line">      <span class="comment">// Forward to exception reporter</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>java线程池会捕获任务抛出的异常和错误，但不做任何处理</li>
<li>好的程序设计应该考虑到对于类异常的处理</li>
<li>处理线程池中的异常有两种思路：<br>1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池<br>2）由线程池统一处理</li>
<li>对于execute方法提交的线程，有两种处理方式<br>1）自定义线程池并实现afterExecute方法<br>2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。</li>
<li>对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[假设我们有一个线程池，由于程序需要，我们向该线程池中提交了好多任务，但是这些任务都没有对异常进行try catch处理，并且运行的时候都抛出了异常。这会对线程池的运行带来什么影响？]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.onlycatch.com/tags/java/"/>
    
      <category term="多线程" scheme="http://blog.onlycatch.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://blog.onlycatch.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Linux工具] rsync数据同步工具]]></title>
    <link href="http://blog.onlycatch.com/linux-rsync/"/>
    <id>http://blog.onlycatch.com/linux-rsync/</id>
    <published>2016-01-06T12:27:36.000Z</published>
    <updated>2016-01-10T14:22:24.000Z</updated>
    <content type="html"><![CDATA[<p>之前有个统计脚本，监控多台机器的日志，发现异常数据自动报警。由于统计脚本只存在一台机器上，所以需要将多台机器日志同步过来。这个同步日志的功能就是通过rsync实现的。</p>
<h2 id="rsync__u662F_u4EC0_u4E48_uFF1F"><a href="#rsync__u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="rsync 是什么？"></a>rsync 是什么？</h2><p>通过man rsync命令可以看到，它是a fast, versatile, remote (and local) file-copying tool，就是一个数据同步工具。versatile:通用的，万能的，多才多艺的。可以简单理解为：一个功能强大的数据同步工具。<br>官方说明：</p>
<blockquote>
<p>Rsync is a fast and extraordinarily versatile file copying tool. It can copy locally, to/from another host over any remote shell, or to/from a remote rsync daemon.  It offers a large  number  of  options that control every aspect of its behavior and permit very flexible specification of the set of files to be copied.</p>
</blockquote>
<p>它支持本地与本地，本地到远程，远程到本地三种方式的数据传输。它提供了非常多的选项可以让你控制数据传输过程中的各个方面。</p>
<h2 id="rsync_u7528_u6CD5"><a href="#rsync_u7528_u6CD5" class="headerlink" title="rsync用法"></a>rsync用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">本地模式:  rsync [OPTION...] SRC... [DEST]</span><br><span class="line"></span><br><span class="line">shell模式:</span><br><span class="line">        拉: rsync [OPTION...] [USER@]HOST:SRC... [DEST]</span><br><span class="line">        推: rsync [OPTION...] SRC... [USER@]HOST:DEST</span><br><span class="line"></span><br><span class="line">rsync deamon模式:</span><br><span class="line">        拉: rsync [OPTION...] [USER@]HOST::SRC... [DEST]</span><br><span class="line">            rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]</span><br><span class="line">        推: rsync [OPTION...] SRC... [USER@]HOST::DEST</span><br><span class="line">            rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST</span><br><span class="line"></span><br><span class="line">      DEST目录可以省略，如果省略，将只会列出SRC中的文件，而不进行拷贝.</span><br></pre></td></tr></table></figure>
<p>同步远程数据有两种方式</p>
<ol>
<li>使用其他远程脚本程序进行传输，比如ssh或者rsh。即上面所说的shell模式。</li>
<li>通过TCP协议直接连接到一个rsync后台进程。使用这种方式就需要在远程机器上启动一个rsync后台进程，默认该进程监听的端口是873。即上面所说的rsync deamon模式。</li>
</ol>
<h2 id="rsync_u4F7F_u7528_u4E3E_u4F8B"><a href="#rsync_u4F7F_u7528_u4E3E_u4F8B" class="headerlink" title="rsync使用举例"></a>rsync使用举例</h2><h3 id="u672C_u5730_u62F7_u8D1D"><a href="#u672C_u5730_u62F7_u8D1D" class="headerlink" title="本地拷贝"></a>本地拷贝</h3><p>用法： <code>rsync [OPTION...] SRC... [DEST]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dev@mymachaine tmp]$ mkdir src</span><br><span class="line">[dev@mymachaine tmp]$ mkdir dest</span><br><span class="line">[dev@mymachaine tmp]$ rsync <span class="number">2305.</span>txt dest/</span><br></pre></td></tr></table></figure></p>
<p>以上命令将会把2305.txt这个文件拷贝到dest目录中。</p>
<h3 id="u4ECE_u8FDC_u7A0B_u673A_u5668_u540C_u6B65_u6570_u636E_u5230_u672C_u5730"><a href="#u4ECE_u8FDC_u7A0B_u673A_u5668_u540C_u6B65_u6570_u636E_u5230_u672C_u5730" class="headerlink" title="从远程机器同步数据到本地"></a>从远程机器同步数据到本地</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -vz -P --bwlimit=<span class="number">8096</span> rsync://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/src/xxx.log rsync://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/src/yyy.log /local/dest/</span><br></pre></td></tr></table></figure>
<p>上面的命令，将127.0.0.1这台机器上src目录下的xxx.log和yyy.log两个文件同步到本地的/local/dest目录下。采用的是rsync deamon模式。<br>-z:压缩<br>-v:verbose,即打印传输日志<br>-P:相当于–partial –progress 两个命令一起用。<br>–bwlimit: (–bwlimit=KBPS)限制IO带宽，KB每秒。<br>–partial:默认情况下，在传输中断的时候，rsync会将已经传输完成的部分删掉，使用该命令就告诉rsync不要删除已经传完的部分，这样就能够提高后续传输的速度。<br>–progress:告诉rsync，显示传输进度。比如:<code>782448  63%  110.64kB/s    0:00:04</code></p>
<h2 id="rsync_u673A_u5236"><a href="#rsync_u673A_u5236" class="headerlink" title="rsync机制"></a>rsync机制</h2><h3 id="delta-transfer__u7B97_u6CD5"><a href="#delta-transfer__u7B97_u6CD5" class="headerlink" title="delta-transfer 算法"></a>delta-transfer 算法</h3><p>它只传输源文件和目标文件不同的部分数据，这样就可以减少网络传输的数据量。</p>
<h3 id="quick_check__u7B97_u6CD5"><a href="#quick_check__u7B97_u6CD5" class="headerlink" title="quick check 算法"></a>quick check 算法</h3><p>它默认使用quick check算法来查找需要传输的文件，quick check算法是通过判断文件大小和修改时间来判断文件是否发生了改变。当它发现数据文件不需要传输的时候，可以将文件其他属性（属性可以指定）的变化直接同步到目标文件上。</p>
<h3 id="u5176_u4ED6_u7279_u70B9"><a href="#u5176_u4ED6_u7279_u70B9" class="headerlink" title="其他特点"></a>其他特点</h3><ol>
<li>支持拷贝连接(links)，设备(devices),所有者（owners）,所在组（groups）和权限（permissions）</li>
<li>文件传输过程中支持pipeline，从而降低延迟</li>
<li>不需要超级用户权限</li>
<li>可以使用任意的远程脚本，包括ssh和rsh</li>
<li>具有和GNU tar打包工具类似的功能参数exclude和exclude-from</li>
<li>CVS exclude模式会忽略掉那些在.cvsignore文件中存在的文件</li>
<li>支持匿名或者需要身份验证的rsync进程访问（特别适合镜像同步）</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>rsync是一个快速的数据同步工具</li>
<li>支持本地之间，本地与远程之间的数据同步</li>
<li>本地与远程的数据同步包括推和拉两种模式，同时又可以使用其他远程传输shell或者使用rsync deamon两种传输方式。</li>
<li>参数多样</li>
<li>支持pipeline，能够极大减少传输延时</li>
<li>支持只传输差异部分数据，减少网络传输数据量</li>
</ol>
<h2 id="u6269_u5C55_u9605_u8BFB"><a href="#u6269_u5C55_u9605_u8BFB" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol>
<li><a href="https://github.com/renzhexigua/LUG/blob/master/mirrors/%E8%AF%91.md" target="_blank" rel="external">https://github.com/renzhexigua/LUG/blob/master/mirrors/%E8%AF%91.md</a></li>
<li>linux系统 man rsync</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Linux系统中的数据同步工具rsync的简单介绍。]]>
    
    </summary>
    
      <category term="linux" scheme="http://blog.onlycatch.com/tags/linux/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[广播（broadcast)，组播(multicast)，单播(unicast)的Java实现]]></title>
    <link href="http://blog.onlycatch.com/broadcast-multicast-unicast/"/>
    <id>http://blog.onlycatch.com/broadcast-multicast-unicast/</id>
    <published>2016-01-06T12:21:27.000Z</published>
    <updated>2016-01-10T14:21:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="IP_u5730_u5740"><a href="#IP_u5730_u5740" class="headerlink" title="IP地址"></a>IP地址</h2><p>在IPv4中，一共有五类IP地址   </p>
<ul>
<li>A类地址：网络号占1个字节。网络号的第一位固定为0。</li>
<li>B类地址：网络号占2个字节。网络号的前两位固定为10。</li>
<li>C类地址：网络号占3个字节。网络号的前三位固定位110。</li>
<li>D类地址：前四位是1110，用于多播(multicast)，即一对多通信。</li>
<li>E类地址：前四位是1111，保留为以后使用。</li>
</ul>
<p>其中，D类地址是从224.0.0.0到239.255.255.255这个范围的。这类地址的主要做用就是用作组播（又叫做多播）。<br>而ABC类地址是单播地址。<br>广播地址：主机位全部是1的地址都是广播地址,即<code>&lt;net-id,-1&gt;</code>。网络位和主机位全都是1的是本地广播地址，即<code>&lt;-1,-1&gt;</code>,IPV4:255.255.255.255。</p>
<h2 id="u5355_u64AD"><a href="#u5355_u64AD" class="headerlink" title="单播"></a>单播</h2><p>单播就是一对一通信，我们常用的就是TCP协议，在Java中的体现就是Socket和ServerSocket。有人可能会问，那UDP协议呢？其实UDP协议即可以用来做单播又可以用来做多播和广播。Java中，处理UDP对应的是DatagramSocket。</p>
<p>下面我们分别使用TCP和UDP实现一个服务端客户端。</p>
<h3 id="u57FA_u4E8ETCP_u7684_u5B9E_u73B0"><a href="#u57FA_u4E8ETCP_u7684_u5B9E_u73B0" class="headerlink" title="基于TCP的实现"></a>基于TCP的实现</h3><p>TCP服务端：<br>服务端监听本地端口9999，然后等待客户端输入，将客户端的输入原样输出给客户端。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Date: 2016年1月6日 下午1:16:57 &lt;br/&gt;</span><br><span class="line"> * TCP服务端，监听端口，等待连接，然后将客户端的输入的内容原样返回给客户端</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPUnicastServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 服务端，绑定到端口9999</span></span><br><span class="line">			serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">final</span> Socket clientSocket = serverSocket.accept();</span><br><span class="line">				<span class="comment">// 启动一个线程，处理客户端连接</span></span><br><span class="line">				<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">					<span class="annotation">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">							PrintWriter writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(clientSocket.getOutputStream()));</span><br><span class="line">							<span class="comment">// 监听客户端的输入</span></span><br><span class="line">							<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">								String requestData = reader.readLine();</span><br><span class="line">								<span class="keyword">if</span> (requestData == <span class="keyword">null</span>) &#123;</span><br><span class="line">									<span class="keyword">break</span>;</span><br><span class="line">								&#125;</span><br><span class="line"></span><br><span class="line">								System.out.println(<span class="string">"server received:"</span> + requestData);</span><br><span class="line">								<span class="comment">// 将客户端的输入原样返回给客户端</span></span><br><span class="line">								writer.println(requestData);</span><br><span class="line">								writer.flush();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					serverSocket.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TCP客户端：<br>客户端负责与客户端建立连接，并向服务端发送数据，同时接受服务端返回的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 向服务端创建连接</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">		BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">		PrintWriter writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送数据</span></span><br><span class="line">		writer.println(<span class="string">"Hello,i am client"</span>);</span><br><span class="line">		writer.flush();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 等待服务端响应</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			String serverData = reader.readLine();</span><br><span class="line">			<span class="keyword">if</span> (serverData == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"client received:"</span> + serverData);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>TCP的实现比较特殊，Socket分为服务端Socket(ServerSocket)和客户端Socket(Socket)。</p>
<h3 id="u57FA_u4E8EUDP_u7684_u5B9E_u73B0"><a href="#u57FA_u4E8EUDP_u7684_u5B9E_u73B0" class="headerlink" title="基于UDP的实现"></a>基于UDP的实现</h3><p>Java中UDP对应的Socket只有一个DatagramSocket，不区分客户端与服务端（想想也是）。<br>发送数据的一端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DatagramSocket serverSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送的目的地址和端口</span></span><br><span class="line">		InetAddress destination = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] buf = <span class="string">"Hello client"</span>.getBytes();</span><br><span class="line">			DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length, destination, <span class="number">9999</span>);</span><br><span class="line">			serverSocket.send(packet);</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		serverSocket.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>接收数据的一端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DatagramSocket clientSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>], <span class="number">256</span>);</span><br><span class="line">			clientSocket.receive(packet);</span><br><span class="line">			System.out.println(<span class="keyword">new</span> String(packet.getData()).trim());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>发送端和接收端都使用DatagramSocket</li>
<li>发送端发送的时候指定的地址是一个单播地址</li>
<li>发送和接收数据使用的是DatagramPacket</li>
</ol>
<h2 id="u591A_u64AD"><a href="#u591A_u64AD" class="headerlink" title="多播"></a>多播</h2><p>多播就是一对多通信，即从一台机器发送数据到多台机器。在Java里的体现就是MulticastSocket，MulticastSocket是DatagramSocket的子类。<br>很多人喜欢将多播称作组播，是因为多播不同于广播，广播是向所有机器发送数据，而多播是针对某一组机器发送数据。下面我们来看一下多播的实现。</p>
<p>发送数据的一端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 指定组播要发送的组</span></span><br><span class="line">		InetAddress group = InetAddress.getByName(<span class="string">"224.0.0.3"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建MulticastSocket，它是DatagramSocket的子类</span></span><br><span class="line">		MulticastSocket socket = <span class="keyword">new</span> MulticastSocket();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			String data = <span class="string">"hello client"</span>;</span><br><span class="line">			<span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">			<span class="comment">// 将数据发送到对应组的对应端口</span></span><br><span class="line">			socket.send(<span class="keyword">new</span> DatagramPacket(bytes, bytes.length, group, <span class="number">9999</span>));</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>接收数据的一端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 多播客户端监听相应的端口</span></span><br><span class="line">		MulticastSocket clientSocket = <span class="keyword">new</span> MulticastSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 客户端将自己加入到指定的多播组中，这样就能收到来自这个组的消息</span></span><br><span class="line">		InetAddress group = InetAddress.getByName(<span class="string">"224.0.0.3"</span>);</span><br><span class="line">		clientSocket.joinGroup(group);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>];</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 读取数据</span></span><br><span class="line">			DatagramPacket msgPacket = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">			clientSocket.receive(msgPacket);</span><br><span class="line"></span><br><span class="line">			String msg = <span class="keyword">new</span> String(msgPacket.getData());</span><br><span class="line">			System.out.println(<span class="string">"Socket 1 received msg: "</span> + msg.trim());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//离开组</span></span><br><span class="line">		<span class="comment">//clientSocket.leaveGroup(group);</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ol>
<li>多播发送端和接收端使用的都是MulticastSocket，它是DatagramSocket的一个子类，其实在底层，多播也是基于UDP的。</li>
<li>客户端需要加入到对应的group中，才可以接收到服务端的消息：<code>clientSocket.joinGroup(group);</code></li>
</ol>
<h2 id="u5E7F_u64AD"><a href="#u5E7F_u64AD" class="headerlink" title="广播"></a>广播</h2><p>广播分组的目标IP地址的主机部分全为1，这意味着本地网络（广播域）中的所有主机都将接收并查看该分组。诸如ARP和DHCP等很多网络协议都使用广播。<br>例如：</p>
<ol>
<li>C类网络192.168.1.0的默认子网掩码为255.255.255.0，其广播地址为192.168.1.255，其主机部分为十进制数255或二进制数11111111（全为1）。</li>
<li>B类网络172.16.0.0的默认子网掩码为255.255.0.0，其广播地址为172.16.255.255。</li>
<li>A类网络10.0.0.0的默认子网掩码为255.0.0.0，其广播地址为10.255.255.255。</li>
</ol>
<p>在java中，广播也是借助DatagramSocket实现的。<br>消息发送方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DatagramSocket serverSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 发送的目的地址和端口</span></span><br><span class="line">		InetAddress destination = InetAddress.getByName(<span class="string">"255.255.255.255"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] buf = <span class="string">"Hello client"</span>.getBytes();</span><br><span class="line">			DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length, destination, <span class="number">9999</span>);</span><br><span class="line">			serverSocket.send(packet);</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		serverSocket.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：发送的地址必须是广播地址。</p>
<p>消息接收方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DatagramSocket clientSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">256</span>], <span class="number">256</span>);</span><br><span class="line">			clientSocket.receive(packet);</span><br><span class="line">			System.out.println(<span class="keyword">new</span> String(packet.getData()).trim());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实仔细观察一下你会发现，在前面的UDP实现单播的时候的代码与广播的代码基本是一样的，区别就在于单播的时候目的端的地址必须是单播地址，而广播的时候，目的端的地址必须是广播地址。</p>
<h2 id="u5355_u64AD_uFF0C_u7EC4_u64AD_uFF0C_u5E7F_u64AD_u90FD_u6709_u54EA_u4E9B_u5E94_u7528_u573A_u666F_uFF1F"><a href="#u5355_u64AD_uFF0C_u7EC4_u64AD_uFF0C_u5E7F_u64AD_u90FD_u6709_u54EA_u4E9B_u5E94_u7528_u573A_u666F_uFF1F" class="headerlink" title="单播，组播，广播都有哪些应用场景？"></a>单播，组播，广播都有哪些应用场景？</h2><ol>
<li>单播：点对点通信，最常用的就是TCP协议。</li>
<li>组播：一对多通信，视频教学：多个学生连接到同一个服务端。</li>
<li>广播：一对多通信，DHCP动态分配IP地址的时候，客户机器就是通过发送一个广播信息，只有DHCP服务器才会对这个广播信息进行响应。</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>IPv4地址分为五类，其中ABC三类都是单播地址，D类是多播地址，地址范围为224.0.0.0到239.255.255.255。</li>
<li>广播地址：地址位都为1。网络位和地址位都为1的（255.255.255.255）为本地广播地址。</li>
<li>广播和多播都是通过UDP协议实现的，在Java中广播是借助DatagramSocket实现，多播是MulticastSocket，后者是前者的子类。</li>
</ol>
<h2 id="u6269_u5C55_u9605_u8BFB"><a href="#u6269_u5C55_u9605_u8BFB" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol>
<li><a href="http://www.nakov.com/inetjava/lectures/part-1-sockets/InetJava-1.5-UDP-and-Multicast-Sockets.html" target="_blank" rel="external">http://www.nakov.com/inetjava/lectures/part-1-sockets/InetJava-1.5-UDP-and-Multicast-Sockets.html</a></li>
<li><a href="http://book.51cto.com/art/200904/120471.htm" target="_blank" rel="external">http://book.51cto.com/art/200904/120471.htm</a></li>
<li><a href="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/（这篇文章讲解的非常好）" target="_blank" rel="external">http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/（这篇文章讲解的非常好）</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[IPV4地址共分为5类，其中ABC三类为单播(unicast)地址，D类为组播地址，另外，IP地址包括网络号和主机号两部分，主机号的二进制为都为1的就是该网络中的多播地址。那么广播(broadcast)，组播(multicast)，单播(unicast)都有哪些特点呢?它们在java中是如何体现的呢？]]>
    
    </summary>
    
      <category term="IP" scheme="http://blog.onlycatch.com/tags/IP/"/>
    
      <category term="java" scheme="http://blog.onlycatch.com/tags/java/"/>
    
      <category term="网络" scheme="http://blog.onlycatch.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自旋锁]]></title>
    <link href="http://blog.onlycatch.com/spinlock/"/>
    <id>http://blog.onlycatch.com/spinlock/</id>
    <published>2016-01-04T13:03:40.000Z</published>
    <updated>2016-01-10T14:22:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4EC0_u4E48_u662F_u81EA_u65CB_u9501_uFF1F"><a href="#u4EC0_u4E48_u662F_u81EA_u65CB_u9501_uFF1F" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h2><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。<br>获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成<a href="https://en.wikipedia.org/wiki/Busy_waiting" target="_blank" rel="external">busy-waiting</a>。</p>
<h2 id="Java_u5982_u4F55_u5B9E_u73B0_u81EA_u65CB_u9501_uFF1F"><a href="#Java_u5982_u4F55_u5B9E_u73B0_u81EA_u65CB_u9501_uFF1F" class="headerlink" title="Java如何实现自旋锁？"></a>Java如何实现自旋锁？</h2><p>下面是个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Date: 2016年1月4日 下午4:41:50 &lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> medusar</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="comment">// 利用CAS</span></span><br><span class="line">		<span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">			<span class="comment">// DO nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		cas.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。   </p>
<h2 id="u81EA_u65CB_u9501_u5B58_u5728_u7684_u95EE_u9898"><a href="#u81EA_u65CB_u9501_u5B58_u5728_u7684_u95EE_u9898" class="headerlink" title="自旋锁存在的问题"></a>自旋锁存在的问题</h2><p>使用自旋锁会有以下一个问题：</p>
<ol>
<li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</li>
<li>上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。     </li>
</ol>
<h2 id="u81EA_u65CB_u9501_u7684_u4F18_u70B9"><a href="#u81EA_u65CB_u9501_u7684_u4F18_u70B9" class="headerlink" title="自旋锁的优点"></a>自旋锁的优点</h2><ol>
<li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li>
<li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li>
</ol>
<h2 id="u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501_u548C_u4E0D_u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501"><a href="#u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501_u548C_u4E0D_u53EF_u91CD_u5165_u7684_u81EA_u65CB_u9501" class="headerlink" title="可重入的自旋锁和不可重入的自旋锁"></a>可重入的自旋锁和不可重入的自旋锁</h2><p>文章开始的时候的那段代码，仔细分析一下就可以看出，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。<br>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。   </p>
<p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Date: 2016年1月4日 下午5:21:23 &lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> medusar</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantSpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="keyword">if</span> (current == cas.get()) &#123; <span class="comment">// 如果当前线程已经获取到了锁，线程数增加一，然后返回</span></span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果没获取到锁，则通过CAS自旋</span></span><br><span class="line">		<span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">			<span class="comment">// DO nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread cur = Thread.currentThread();</span><br><span class="line">		<span class="keyword">if</span> (cur == cas.get()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</span></span><br><span class="line">				count--;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。</span></span><br><span class="line">				cas.compareAndSet(cur, <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u81EA_u65CB_u9501_u7684_u5176_u4ED6_u53D8_u79CD"><a href="#u81EA_u65CB_u9501_u7684_u5176_u4ED6_u53D8_u79CD" class="headerlink" title="自旋锁的其他变种"></a>自旋锁的其他变种</h2><h3 id="1-_TicketLock"><a href="#1-_TicketLock" class="headerlink" title="1. TicketLock"></a>1. TicketLock</h3><p>TicketLock主要解决的是公平性的问题。<br>思路：每当有线程获取锁的时候，就给该线程分配一个递增的id，我们称之为排队号，同时，锁对应一个服务号，每当有线程释放锁，服务号就会递增，此时如果服务号与某个线程排队号一致，那么该线程就获得锁，由于排队号是递增的，所以就保证了最先请求获取锁的线程可以最先获取到锁，就实现了公平性。<br>可以想象成银行办理业务排队，排队的每一个顾客都代表一个需要请求锁的线程，而银行服务窗口表示锁，每当有窗口服务完成就把自己的服务号加一，此时在排队的所有顾客中，只有自己的排队号与服务号一致的才可以得到服务。<br>实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *</span><br><span class="line"> * date: 2016年1月4日 下午6:09:16 &lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> Medusar</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketLock</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 服务号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger serviceNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 排队号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger ticketNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * lock:获取锁，如果获取成功，返回当前线程的排队号，获取排队号用于释放锁. &lt;br/&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> currentTicketNum = ticketNum.incrementAndGet();</span><br><span class="line">		<span class="keyword">while</span> (currentTicketNum != serviceNum.get()) &#123;</span><br><span class="line">			<span class="comment">// Do nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> currentTicketNum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * unlock:释放锁，传入当前持有锁的线程的排队号 &lt;br/&gt;</span><br><span class="line">	 *</span><br><span class="line">	 * <span class="doctag">@param</span> ticketnum</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">int</span> ticketnum)</span> </span>&#123;</span><br><span class="line">		serviceNum.compareAndSet(ticketnum, ticketnum + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的实现方式是，线程获取锁之后，将它的排队号返回，等该线程释放锁的时候，需要将该排队号传入。但这样是有风险的，因为这个排队号是可以被修改的，一旦排队号被不小心修改了，那么锁将不能被正确释放。一种更好的实现方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Date: 2016年1月4日 下午6:11:50 &lt;br/&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@author</span> medusar</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketLockV2</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 服务号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger serviceNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 排队号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger ticketNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 新增一个ThreadLocal，用于存储每个线程的排队号</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> ThreadLocal&lt;Integer&gt; ticketNumHolder = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> currentTicketNum = ticketNum.incrementAndGet();</span><br><span class="line">		<span class="comment">// 获取锁的时候，将当前线程的排队号保存起来</span></span><br><span class="line">		ticketNumHolder.set(currentTicketNum);</span><br><span class="line">		<span class="keyword">while</span> (currentTicketNum != serviceNum.get()) &#123;</span><br><span class="line">			<span class="comment">// Do nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 释放锁，从ThreadLocal中获取当前线程的排队号</span></span><br><span class="line">		Integer currentTickNum = ticketNumHolder.get();</span><br><span class="line">		serviceNum.compareAndSet(currentTickNum, currentTickNum + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的实现方式是将每个线程的排队号放到了ThreadLocal中。   </p>
<p><strong>TicketLock存在的问题</strong></p>
<blockquote>
<p>多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</p>
</blockquote>
<p>下面介绍的MCSLock和CLHLock就是解决这个问题的。</p>
<h3 id="2-_CLHLock"><a href="#2-_CLHLock" class="headerlink" title="2. CLHLock"></a>2. CLHLock</h3><p>CLH锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋，获得锁。<br>实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * CLH的发明人是：Craig，Landin and Hagersten。</span><br><span class="line"> * 代码来源：http://ifeve.com/java_lock_see2/</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 定义一个节点，默认的lock状态为true</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 尾部节点,只用一个节点即可</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;CLHNode&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class,</span><br><span class="line">			<span class="string">"tail"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 新建节点并将节点与当前线程保存起来</span></span><br><span class="line">		CLHNode node = <span class="keyword">new</span> CLHNode();</span><br><span class="line">		LOCAL.set(node);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将新建的节点设置为尾部节点，并返回旧的节点（原子操作），这里旧的节点实际上就是当前节点的前驱节点</span></span><br><span class="line">		CLHNode preNode = UPDATER.getAndSet(<span class="keyword">this</span>, node);</span><br><span class="line">		<span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 前驱节点不为null表示当锁被其他线程占用，通过不断轮询判断前驱节点的锁标志位等待前驱节点释放锁</span></span><br><span class="line">			<span class="keyword">while</span> (preNode.isLocked) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			preNode = <span class="keyword">null</span>;</span><br><span class="line">			LOCAL.set(node);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果不存在前驱节点，表示该锁没有被其他线程占用，则当前线程获得锁</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取当前线程对应的节点</span></span><br><span class="line">		CLHNode node = LOCAL.get();</span><br><span class="line">		<span class="comment">// 如果tail节点等于node，则将tail节点更新为null，同时将node的lock状态职位false，表示当前线程释放了锁</span></span><br><span class="line">		<span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="keyword">this</span>, node, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			node.isLocked = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_MCSLock"><a href="#3-_MCSLock" class="headerlink" title="3. MCSLock"></a>3. MCSLock</h3><p>MCSLock则是对本地变量的节点进行循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * MCS:发明人名字John Mellor-Crummey和Michael Scott</span><br><span class="line"> * 代码来源：http://ifeve.com/java_lock_see2/</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 节点，记录当前节点的锁状态以及后驱节点</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">volatile</span> MCSNode next;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;MCSNode&gt; NODE = <span class="keyword">new</span> ThreadLocal&lt;MCSNode&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 队列</span></span><br><span class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> MCSNode queue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// queue更新器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(MCSLock.class, MCSNode.class,</span><br><span class="line">			<span class="string">"queue"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建节点并保存到ThreadLocal中</span></span><br><span class="line">		MCSNode currentNode = <span class="keyword">new</span> MCSNode();</span><br><span class="line">		NODE.set(currentNode);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将queue设置为当前节点，并且返回之前的节点</span></span><br><span class="line">		MCSNode preNode = UPDATER.getAndSet(<span class="keyword">this</span>, currentNode);</span><br><span class="line">		<span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果之前节点不为null，表示锁已经被其他线程持有</span></span><br><span class="line"></span><br><span class="line">			preNode.next = currentNode;</span><br><span class="line">			<span class="comment">// 循环判断，直到当前节点的锁标志位为false</span></span><br><span class="line">			<span class="keyword">while</span> (currentNode.isLocked) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		MCSNode currentNode = NODE.get();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// next为null表示没有正在等待获取锁的线程</span></span><br><span class="line">		<span class="keyword">if</span> (currentNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 更新状态并设置queue为null</span></span><br><span class="line">			<span class="keyword">if</span> (UPDATER.compareAndSet(<span class="keyword">this</span>, currentNode, <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="comment">// 如果成功了，表示queue==currentNode,即当前节点后面没有节点了</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果不成功，表示queue!=currentNode,即当前节点后面多了一个节点，表示有线程在等待</span></span><br><span class="line">				<span class="comment">// 如果当前节点的后续节点为null，则需要等待其不为null（参考加锁方法）</span></span><br><span class="line">				<span class="keyword">while</span> (currentNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果不为null，表示有线程在等待获取锁，此时将等待线程对应的节点锁状态更新为false，同时将当前线程的后继节点设为null</span></span><br><span class="line">			currentNode.next.isLocked = <span class="keyword">false</span>;</span><br><span class="line">			currentNode.next = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-_CLHLock__u548C_MCSLock"><a href="#4-_CLHLock__u548C_MCSLock" class="headerlink" title="4. CLHLock 和 MCSLock"></a>4. CLHLock 和 MCSLock</h3><ul>
<li>都是基于链表，不同的是CLHLock是基于隐式链表，没有真正的后续节点属性，MCSLock是显示链表，有一个指向后续节点的属性。</li>
<li>将获取锁的线程状态借助节点(node)保存,每个线程都有一份独立的节点，这样就解决了TicketLock多处理器缓存同步的问题。</li>
</ul>
<h2 id="u81EA_u65CB_u9501_u4E0E_u4E92_u65A5_u9501"><a href="#u81EA_u65CB_u9501_u4E0E_u4E92_u65A5_u9501" class="headerlink" title="自旋锁与互斥锁"></a>自旋锁与互斥锁</h2><ul>
<li>自旋锁与互斥锁都是为了实现保护资源共享的机制。  </li>
<li>无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</li>
<li>获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。</li>
<li>自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。</li>
<li>自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。</li>
<li>自旋锁本身无法保证公平性，同时也无法保证可重入性。</li>
<li>基于自旋锁，可以实现具备公平性和可重入性质的锁。</li>
<li>TicketLock:采用类似银行排号叫好的方式实现自旋锁的公平性，但是由于不停的读取serviceNum，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</li>
<li>CLHLock和MCSLock通过链表的方式避免了减少了处理器缓存同步，极大的提高了性能，区别在于CLHLock是通过轮询其前驱节点的状态，而MCS则是查看当前节点的锁状态。   </li>
<li>CLHLock在<a href="http://cenalulu.github.io/linux/numa/" target="_blank" rel="external">NUMA架构</a>下使用会存在问题。在没有cache的NUMA系统架构中，由于CLHLock是在当前节点的前一个节点上自旋,NUMA架构中处理器访问本地内存的速度高于通过网络访问其他节点的内存，所以CLHLock在NUMA架构上不是最优的自旋锁。</li>
</ul>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.searchtb.com/2011/06/spinlock%E5%89%96%E6%9E%90%E4%B8%8E%E6%94%B9%E8%BF%9B.html" target="_blank" rel="external">http://www.searchtb.com/2011/06/spinlock%E5%89%96%E6%9E%90%E4%B8%8E%E6%94%B9%E8%BF%9B.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spinlock" target="_blank" rel="external">https://en.wikipedia.org/wiki/Spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Busy_waiting" target="_blank" rel="external">https://en.wikipedia.org/wiki/Busy_waiting</a></li>
<li><a href="http://blog.csdn.net/chen77716/article/details/6618779" target="_blank" rel="external">http://blog.csdn.net/chen77716/article/details/6618779</a></li>
<li><a href="http://ifeve.com/java_lock_see4/" target="_blank" rel="external">http://ifeve.com/java_lock_see4/</a></li>
<li><a href="http://ifeve.com/java_lock_see2/" target="_blank" rel="external">http://ifeve.com/java_lock_see2/</a></li>
<li><a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="external">http://coderbee.net/index.php/concurrent/20131115/577</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[锁，自旋锁，Java中自旋锁，可重入自旋锁，公平的自旋锁，TicketLock，CLHLock，MCSLock，自旋锁的原理以及改进。]]>
    
    </summary>
    
      <category term="Java" scheme="http://blog.onlycatch.com/tags/Java/"/>
    
      <category term="并发" scheme="http://blog.onlycatch.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="锁" scheme="http://blog.onlycatch.com/tags/%E9%94%81/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的可重入(Reentrant)锁]]></title>
    <link href="http://blog.onlycatch.com/Reentrant-lock/"/>
    <id>http://blog.onlycatch.com/Reentrant-lock/</id>
    <published>2016-01-04T00:34:06.000Z</published>
    <updated>2016-01-10T14:22:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4EC0_u4E48_u662F_u53EF_u91CD_u5165_u9501_uFF1F"><a href="#u4EC0_u4E48_u662F_u53EF_u91CD_u5165_u9501_uFF1F" class="headerlink" title="什么是可重入锁？"></a>什么是可重入锁？</h2><p>可重入锁是一种特殊的互斥锁，它可以被同一个线程多次获取，而不会产生死锁。   </p>
<ol>
<li>首先它是互斥锁：任意时刻，只有一个线程锁。即假设A线程已经获取了锁，在A线程释放这个锁之前，B线程是无法获取到这个锁的，B要获取这个锁就会进入阻塞状态。</li>
<li>其次，它可以被同一个线程多次持有。即，假设A线程已经获取了这个锁，如果A线程在释放锁之前又一次请求获取这个锁，那么是能够获取成功的。<br>举例说明：   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lockB();  <span class="comment">//lockA方法中调用lockB方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"lock B"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如上面的的代码所示，假如我们要调用lockA方法，而lockA方法又要调用lockB方法，并且这两个方法上都有synchronized关键字，即两个方法都会以类对象作为锁，所以两个方法是统一把锁，如果没有可重入锁的机制，那么这个方法就无法被正确执行。另外可以想象一下，假如我们有一个递归方法，而这个方法是需要加锁的，如果没有可重入锁的机制，加锁的递归方法也是不能实现的。这就是为什么要有可重入锁。  </p>
<h2 id="Java_u4E2D_u7684_u53EF_u91CD_u5165_u9501"><a href="#Java_u4E2D_u7684_u53EF_u91CD_u5165_u9501" class="headerlink" title="Java中的可重入锁"></a>Java中的可重入锁</h2><h3 id="1-_synchronized"><a href="#1-_synchronized" class="headerlink" title="1. synchronized"></a>1. synchronized</h3><p>synchronized是Java提供的内置锁，是互斥锁，又是可重入锁。<br>synchronized关键字有三种用法：</p>
<ul>
<li>加在对象方法上:锁住的是当前对象，不同的对象可以被同时访问</li>
<li>加在类方法上：锁住的是当前类对应在JVM中的Class对象</li>
<li>加在代码块上：锁住的是synchronized(lockobj)中的lockobj</li>
</ul>
<p>synchronized可重入举例：<br>我们知道Hashtable是线程安全的，因为它的所有对元素的读写操作都有synchronized关键字修饰，其中有个putAll方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Copies all of the mappings from the specified map to this hashtable.</span><br><span class="line">    * These mappings will replace any mappings that this hashtable had for any</span><br><span class="line">    * of the keys currently in the specified map.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> t mappings to be stored in this map</span><br><span class="line">    * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span><br><span class="line">    * <span class="doctag">@since</span> 1.2</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())</span><br><span class="line">           put(e.getKey(), e.getValue());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个方法是被synchronized关键字修饰的，方法里面是通过for循环调用put(K,V)方法，我们再来看一下put方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Make sure the value is not null</span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">      Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">      <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">      <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">      <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">      <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">              V old = entry.value;</span><br><span class="line">              entry.value = value;</span><br><span class="line">              <span class="keyword">return</span> old;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      addEntry(hash, key, value, index);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，put方法也是被synchronized关键字修饰的。<br>所以，当我们调用一个Hashtable对象的putAll方法的时候，如果synchronized关键字不支持重入，那么程序将不能正常运行。</p>
<h3 id="2-_ReentrantLock"><a href="#2-_ReentrantLock" class="headerlink" title="2. ReentrantLock"></a>2. ReentrantLock</h3><p>ReentrantLock是Java提供的显示锁，它也是互斥锁，也是可重入锁（通过名字就知道，哈哈）。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFirstLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"doFirstLock---"</span> + Thread.currentThread().getId());</span><br><span class="line">			doSecondLock();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSecondLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"doSecondLock---"</span> + Thread.currentThread().getId());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">				<span class="annotation">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">new</span> ReentrantLockTest().doFirstLock();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;.start();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">100</span> * <span class="number">50</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">doFirstLock---<span class="number">9</span></span><br><span class="line">doFirstLock---<span class="number">10</span></span><br><span class="line">doSecondLock---<span class="number">9</span></span><br><span class="line">doSecondLock---<span class="number">10</span></span><br><span class="line">doFirstLock---<span class="number">11</span></span><br><span class="line">doSecondLock---<span class="number">11</span></span><br><span class="line">doFirstLock---<span class="number">12</span></span><br><span class="line">doSecondLock---<span class="number">12</span></span><br><span class="line">doFirstLock---<span class="number">13</span></span><br><span class="line">doSecondLock---<span class="number">13</span></span><br><span class="line">doFirstLock---<span class="number">16</span></span><br><span class="line">doSecondLock---<span class="number">16</span></span><br><span class="line">doFirstLock---<span class="number">14</span></span><br><span class="line">doSecondLock---<span class="number">14</span></span><br><span class="line">doFirstLock---<span class="number">15</span></span><br><span class="line">doSecondLock---<span class="number">15</span></span><br><span class="line">doFirstLock---<span class="number">17</span></span><br><span class="line">doSecondLock---<span class="number">17</span></span><br><span class="line">doFirstLock---<span class="number">18</span></span><br><span class="line">doSecondLock---<span class="number">18</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Java_u4E2D_u7684_u4E0D_u53EF_u91CD_u5165_u9501"><a href="#Java_u4E2D_u7684_u4E0D_u53EF_u91CD_u5165_u9501" class="headerlink" title="Java中的不可重入锁"></a>Java中的不可重入锁</h2><p>下面是我在<a href="//自旋锁">自旋锁</a>中写的一个自旋锁的例子，它就是不可重入的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AtomicReference&lt;Thread&gt; cas = <span class="keyword">new</span> AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		<span class="comment">// 利用CAS</span></span><br><span class="line">		<span class="keyword">while</span> (!cas.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">			<span class="comment">// DO nothing</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread current = Thread.currentThread();</span><br><span class="line">		cas.compareAndSet(current, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子，如果线程A两次调用lock方法获取锁，那么只有第一次可以成功，第二次将进入循环等待。<br>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">		System.out.println(<span class="string">"invoke lock"</span>);</span><br><span class="line">		spinLock.lock();</span><br><span class="line">		System.out.println(<span class="string">" invoke lock success"</span>);</span><br><span class="line">		System.out.println(<span class="string">"try lock again"</span>);</span><br><span class="line">		spinLock.lock();</span><br><span class="line">		System.out.println(<span class="string">"try lock success"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">invoke lock</span><br><span class="line"> invoke lock success</span><br><span class="line"><span class="keyword">try</span> lock again</span><br></pre></td></tr></table></figure></p>
<p>可以看到，并没有输出”try lock success”,是因为在第二次获取锁的时候，由于不可重入，而进入循环等待。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>可重入锁：即某个线程获得了锁之后，在锁释放前，它可以多次重新获取该锁。</li>
<li>可重入锁解决了重入锁死的问题。</li>
<li>java的内置锁synchronized和ReentrantLock都是可重入锁</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[大家都听说过可重入锁，那么什么是可重入锁，为什么要用可重入锁，Java中是否有不可重入锁？可重入锁应该如何使用呢？]]>
    
    </summary>
    
      <category term="Java" scheme="http://blog.onlycatch.com/tags/Java/"/>
    
      <category term="并发" scheme="http://blog.onlycatch.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="锁" scheme="http://blog.onlycatch.com/tags/%E9%94%81/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
</feed>
