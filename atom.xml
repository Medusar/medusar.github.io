<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Medusar's playground]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.onlycatch.com/"/>
  <updated>2016-01-27T12:24:30.000Z</updated>
  <id>http://blog.onlycatch.com/</id>
  
  <author>
    <name><![CDATA[Medusar]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[CAP理论和BASE理论]]></title>
    <link href="http://blog.onlycatch.com/cap-and-base/"/>
    <id>http://blog.onlycatch.com/cap-and-base/</id>
    <published>2016-01-27T12:23:46.000Z</published>
    <updated>2016-01-27T12:24:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="CAP_u7406_u8BBA"><a href="#CAP_u7406_u8BBA" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>一个分布式系统不可能同时满足CAP三个需求，最多只能同时满足其中的两项。<br>C(consistency)一致性，A(avaliability)可用性，P(Partition tolerance)分区容错性。</p>
<h3 id="u4E00_u81F4_u6027_28consistency_29"><a href="#u4E00_u81F4_u6027_28consistency_29" class="headerlink" title="一致性(consistency)"></a>一致性(consistency)</h3><p>与数据库事务的一致性不同，分布式系统中的一致性指的是数据在多个副本之间是否能够保持一致。即某个节点的数据发生了变动，需要将数据更新同步到其他节点上。</p>
<h3 id="u53EF_u7528_u6027_28avalibility_29"><a href="#u53EF_u7528_u6027_28avalibility_29" class="headerlink" title="可用性(avalibility)"></a>可用性(avalibility)</h3><p>系统提供的服务必须一直处于可用的状态。对于用户的每一个操作请求总是能在<strong>有限时间内返回结果</strong>。</p>
<h3 id="u5206_u533A_u5BB9_u9519_u6027_28partition_tolerence_29"><a href="#u5206_u533A_u5BB9_u9519_u6027_28partition_tolerence_29" class="headerlink" title="分区容错性(partition tolerence)"></a>分区容错性(partition tolerence)</h3><p>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务。除非是整个网络环境都发生了故障。即网络分区出现故障不应该影响整个系统的运行。</p>
<p>根据CAP理论，在我们设计分布式系统的时候，无法同时满足CAP三个需求，所以就需要进行取舍。<br>对于分布式系统来说，分区容错性可以说是一个最基本的要求，因为分布式中必然存在子网络。所以一般我们都会在C和A之间寻求平衡。</p>
<h2 id="BASE_u7406_u8BBA"><a href="#BASE_u7406_u8BBA" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BA: Basically Avaliable(基本可用)<br>S:Soft State(软状态)<br>E:Eventually consistent(最终一致性)</p>
<p>BASE是对CAP中一致性和可用性权衡的结果，核心思想是，即使无法做到强一致性，但是每个应用都可以根据自身的业务特点，采取适当的方式使系统达到最终一致性(E)。</p>
<h3 id="u57FA_u672C_u53EF_u7528__28Basically_avaliable_29"><a href="#u57FA_u672C_u53EF_u7528__28Basically_avaliable_29" class="headerlink" title="基本可用 (Basically avaliable)"></a>基本可用 (Basically avaliable)</h3><p>分布式系统出现不可预知故障的时候，允许损失部分可用性。包括性能损失(响应时间增加）和功能损失（降级）</p>
<h3 id="u8F6F_u72B6_u6001_uFF08soft_state_29"><a href="#u8F6F_u72B6_u6001_uFF08soft_state_29" class="headerlink" title="软状态（soft state)"></a>软状态（soft state)</h3><p>允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h3 id="u6700_u7EC8_u4E00_u81F4_u6027_28eventually_consitent_29"><a href="#u6700_u7EC8_u4E00_u81F4_u6027_28eventually_consitent_29" class="headerlink" title="最终一致性(eventually consitent)"></a>最终一致性(eventually consitent)</h3><p>系统中所有的数据副本，在经过一段时间的同步之后，最终达到一个一致的状态。强调的是最终一致，而不是实时一致。</p>
]]></content>
    <summary type="html">
    <![CDATA[关于CAP理论和BASE理论]]>
    
    </summary>
    
      <category term="BASE" scheme="http://blog.onlycatch.com/tags/BASE/"/>
    
      <category term="CAP" scheme="http://blog.onlycatch.com/tags/CAP/"/>
    
      <category term="分布式系统" scheme="http://blog.onlycatch.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Netty中的零拷贝]]></title>
    <link href="http://blog.onlycatch.com/zero-copy-in-netty/"/>
    <id>http://blog.onlycatch.com/zero-copy-in-netty/</id>
    <published>2016-01-26T12:20:44.000Z</published>
    <updated>2016-01-26T12:22:13.000Z</updated>
    <content type="html"><![CDATA[<p>Netty中的零拷贝与我们传统理解的零拷贝不太一样。<br>传统的零拷贝指的是数据传输过程中，不需要CPU进行数据的拷贝。主要是数据在用户空间与内核中间之间的拷贝。</p>
<h2 id="u4F20_u7EDF_u610F_u4E49_u7684_u96F6_u62F7_u8D1D"><a href="#u4F20_u7EDF_u610F_u4E49_u7684_u96F6_u62F7_u8D1D" class="headerlink" title="传统意义的零拷贝"></a>传统意义的零拷贝</h2><blockquote>
<p>Zero-Copy describes computer operations in which the CPU does not perform the task of copying data from one memory area to another.\</p>
</blockquote>
<p>在发送数据的时候，传统的实现方式是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File.read(bytes)</span><br><span class="line">Socket.send(bytes)</span><br></pre></td></tr></table></figure></p>
<p>这种方式需要四次数据拷贝和四次上下文切换：</p>
<ol>
<li>数据从磁盘读取到内核的read buffer</li>
<li>数据从内核缓冲区拷贝到用户缓冲区</li>
<li>数据从用户缓冲区拷贝到内核的socket buffer</li>
<li>数据从内核的socket buffer拷贝到网卡接口的缓冲区</li>
</ol>
<p>明显上面的第二步和第三步是没有必要的，通过java的FileChannel.transferTo方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）</p>
<ol>
<li>调用transferTo,数据从文件由DMA引擎拷贝到内核read buffer</li>
<li>接着DMA从内核read buffer将数据拷贝到网卡接口buffer</li>
</ol>
<p>上面的两次操作都不需要CPU参与，所以就达到了零拷贝。</p>
<h2 id="Netty_u4E2D_u7684_u96F6_u62F7_u8D1D"><a href="#Netty_u4E2D_u7684_u96F6_u62F7_u8D1D" class="headerlink" title="Netty中的零拷贝"></a>Netty中的零拷贝</h2><p>Netty中也用到了FileChannel.transferTo方法，所以Netty的零拷贝也包括上面将的操作系统级别的零拷贝。除此之外，在ByteBuf的实现上，Netty也提供了零拷贝的一些实现。</p>
<p>关于ByteBuffer，Netty提供了两个接口:</p>
<ol>
<li>ByteBuf</li>
<li>ByteBufHolder</li>
</ol>
<p>对于ByteBuf，Netty提供了多种实现：</p>
<ol>
<li>Heap ByteBuf:直接在堆内存分配</li>
<li>Direct ByteBuf：直接在内存区域分配而不是堆内存</li>
<li>CompositeByteBuf：组合Buffer</li>
</ol>
<h3 id="Direct_Buffers"><a href="#Direct_Buffers" class="headerlink" title="Direct Buffers"></a>Direct Buffers</h3><p>直接在内存区域分配空间，而不是在堆内存中分配。如果使用传统的堆内存分配，当我们需要将数据通过socket发送的时候，就需要从堆内存拷贝到直接内存，然后再由直接内存拷贝到网卡接口层。<br>Netty提供的直接Buffer，直接将数据分配到内存空间，从而避免了数据的拷贝，实现了零拷贝。</p>
<h3 id="Composite_Buffers"><a href="#Composite_Buffers" class="headerlink" title="Composite Buffers"></a>Composite Buffers</h3><p>传统的ByteBuffer，如果需要将两个ByteBuffer中的数据组合到一起，我们需要首先创建一个size=size1+size2大小的新的数组，然后将两个数组中的数据拷贝到新的数组中。但是使用Netty提供的组合ByteBuf，就可以避免这样的操作，因为CompositeByteBuf并没有真正将多个Buffer组合起来，而是保存了它们的引用，从而避免了数据的拷贝，实现了零拷贝。</p>
<h3 id="u5BF9_u4E8EFileChannel-transferTo_u7684_u4F7F_u7528"><a href="#u5BF9_u4E8EFileChannel-transferTo_u7684_u4F7F_u7528" class="headerlink" title="对于FileChannel.transferTo的使用"></a>对于FileChannel.transferTo的使用</h3><p>Netty中使用了FileChannel的transferTo方法，该方法依赖于操作系统实现零拷贝。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>Netty的零拷贝体现在三个方面：</p>
<ol>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li>
<li>Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。</li>
<li>Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://my.oschina.net/plucury/blog/192577" target="_blank" rel="external">http://my.oschina.net/plucury/blog/192577</a></li>
<li><a href="http://www.infoq.com/cn/articles/netty-high-performance" target="_blank" rel="external">http://www.infoq.com/cn/articles/netty-high-performance</a></li>
<li>《Netty in Action V5_meap》</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Netty中是如何应用零拷贝的，Netty零拷贝与我们常说的零拷贝有什么区别和联系]]>
    
    </summary>
    
      <category term="netty" scheme="http://blog.onlycatch.com/tags/netty/"/>
    
      <category term="零拷贝" scheme="http://blog.onlycatch.com/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[零拷贝]]></title>
    <link href="http://blog.onlycatch.com/zero-copy/"/>
    <id>http://blog.onlycatch.com/zero-copy/</id>
    <published>2016-01-26T12:19:26.000Z</published>
    <updated>2016-01-26T12:24:52.000Z</updated>
    <content type="html"><![CDATA[<p>在看kafka的时候又提到了零拷贝，之前netty中也提到过零拷贝，今天就来看一下什么是零拷贝，零拷贝的又来以及如何使用。</p>
<h2 id="u539F_u7406_u4ECB_u7ECD"><a href="#u539F_u7406_u4ECB_u7ECD" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>网络服务器都存在网络数据传输的问题，在服务器上，文件都是存放在磁盘上，当有请求到来的时候，需要将磁盘上的文件发送到网络中。</p>
<h3 id="u4F20_u7EDF_u7684_u6570_u636E_u53D1_u9001_u8FC7_u7A0B"><a href="#u4F20_u7EDF_u7684_u6570_u636E_u53D1_u9001_u8FC7_u7A0B" class="headerlink" title="传统的数据发送过程"></a>传统的数据发送过程</h3><p>在传统情况下，java中要实现这个过程需要调用下面两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File.read(fileDesc, buf, len);</span><br><span class="line">Socket.send(socket, buf, len);</span><br></pre></td></tr></table></figure></p>
<p>即首先调用read方法，将磁盘文件读取到内存中；然后调用Socket的send方法，将字节数据发送出去。</p>
<p>java代码很简单，但是这个过程在操作系统层面却被分成了四个步骤：</p>
<ol>
<li>将数据从硬盘拷贝到内核空间中的缓冲区</li>
<li>将数据从内核缓冲区拷贝到用户空间缓冲区</li>
<li>将数据从用户空间缓冲区再拷回到内核缓冲区（Socket Buffer)</li>
<li>将数据从内核缓冲区拷贝到网卡缓冲区(NIC Buffer）</li>
</ol>
<p>可以看到，上面四个步骤中进行了四次数据拷贝，并且还涉及到了四次上下文切换。</p>
<p>下图描述的更清楚：<br>数据拷贝：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/%40%2Fima%2Ffigure1.gif" alt="传统方式的数据拷贝"><br>上下文切换：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/%40%2Fima%2Ffigure2.gif" alt="传统拷贝方式的上下文切换"><br>Step 1. read()方法会造成一次上下文切换，即从用户态切换到内核态。在底层会调用sys_read()方法（或者其他等同的方法）来读取文件。第一次拷贝由DMA引擎完成，从磁盘读取数据然后保存在内核空间缓冲区。<br>Step 2. 被请求的数据从read buffer 拷贝到用户缓冲区，此时read()方法返回。read()方法返回会造成上下文从内核态切换回用户态。此时数据被存放在用户空间缓冲区。<br>Step 3. socket的send()方法会使上下文从用户态切换到内核态。第三次拷贝发生了，数据被从用户缓冲区拷贝回到内核缓冲区。但是这次数据不再是放在read buffer中了，而是放到了不同的地方:Socket Buffer中。<br>Step 4. send()方法返回，造成第四次上下文切换。第四次拷贝异步并独立地将数据从内核缓冲区拷贝到协议引擎。</p>
<h3 id="u96F6_u62F7_u8D1D_u7684_u5B9E_u73B0"><a href="#u96F6_u62F7_u8D1D_u7684_u5B9E_u73B0" class="headerlink" title="零拷贝的实现"></a>零拷贝的实现</h3><p>零拷贝通过消除了不必要的数据拷贝过程而达到提高性能的目的。<br>上面的传统方式来说，第二步和第三步的拷贝是不必要的，即数据可以直接从内核缓冲区的read buffer拷贝到内核缓冲区的 socket buffer。实现这个功能的是java中的FileChannal的transferTo()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">  * &lt;p&gt; This method is potentially much more efficient than a simple loop</span><br><span class="line">     * that reads from this channel and writes to the target channel.  Many</span><br><span class="line">     * operating systems can transfer bytes directly from the filesystem cache</span><br><span class="line">     * to the target channel without actually copying them.  &lt;/p&gt;</span><br><span class="line">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>该方法将数据从文件管道传输到指定的可写的channel。在内部是依赖与操作系统对于零拷贝的支持。linux系统中，提供了一个sendfile()方法，它可以将数据从一个文件描述符转移到另一个文件描述符。关于sendfile可以参考这里：<a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">sendfile API</a></p>
<p>使用transferTo之后，数据的拷贝过程如下：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/%40%2Fima%2Ffigure3.gif" alt="transferTo"><br>上下文切换如下：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/%40%2Fima%2Ffigure4.gif" alt="神下文切换"></p>
<ol>
<li>transferTo()方法导致DMA引擎将数据从磁盘拷贝到内核缓冲区的read buffer中，然后又从read buffer中拷贝到相关的socke buffer中。</li>
<li>接下来DMA引擎将数据从内核缓冲区的socket buffer中拷贝到协议引擎。</li>
</ol>
<p>虽然仍然有三次拷贝(虽然之后一次需要CPU介入，即第二次），但是对于上下文切换来说却减少到了两次，即在调用transferTo的时候从用户态切换到内核态，等transferTo完成之后，再从内核态切换回用户态。但这仍然没有达到零拷贝的目的。</p>
<p>如果底层的网卡接口支持gather操作的话，我们还可以进一步减少内存拷贝。在linux内核2.4以及以后的版本中，对socket缓冲区描述符进行了调整以满足该需求。这种方式不仅减少了上下文切换也减少了需要CPU接入的数据拷贝。从用户使用的角度来讲并没有什么不同，但是底层实现却变了：</p>
<ol>
<li>transferTo()方法促使DMA引擎将数据从文件中拷贝到内核缓冲区</li>
<li>数据不再拷贝到socket buffer中，相反，只有包含关于数据的位置和长度的信息的描述符被追加到了套接字缓冲区。DMA引擎直接把数据从内核缓冲区传输到协议引擎，从而消除了剩下的最后一次 CPU 拷贝。<br>如下图：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/%40%2Fima%2Ffigure5.gif" alt="改进后的transferTo"></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>零拷贝并不是没有任何数据拷贝过程，而是将需要CPU参与的数据拷贝过程都消除掉。</li>
<li>零拷贝在java中是通过FileChannel的transferTo实现的，但是它是依赖与所在操作系统对于零拷贝的支持。</li>
<li>linux系统中提供了sendfile()方法来支持将数据从一个文件描述符转移到另外一个，从而实现零拷贝的目的。</li>
<li>零拷贝的演变过程：首先消除了数据在内核空间与用户空间之间的拷贝，但是仍然需要在内核态中进行一次拷贝（从read buffer到socket buffer)。如果网卡接口支持gather操作，那么可以直接从read buffer拷贝到网卡接口buffer。</li>
<li>零拷贝仍然需要经历两次数据拷贝：1）将数据从磁盘拷贝到内核缓冲区2）将数据从内核缓冲区拷贝到网卡接口数据缓冲区。零拷贝只需要两次上下文切换，即调用transferTo的时候从用户态转移到内核态，transferTo返回的时候从内核态转移回用户态。</li>
</ol>
<blockquote>
<p>Zero-Copy describes computer operations in which the CPU does not perform the task of copying data from one memory area to another.</p>
</blockquote>
<h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>sendfile支持在文件描述符之间拷贝数据，由于拷贝是在内核中进行，所以比组合使用read()和write()方法更有效，因为read,write需要将数据拷贝到用户空间。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sendfile() copies data between one file descriptor and another.</span><br><span class="line">      Because this copying is <span class="keyword">done</span> within the kernel, sendfile() is more</span><br><span class="line">      efficient than the combination of <span class="built_in">read</span>(<span class="number">2</span>) and write(<span class="number">2</span>), <span class="built_in">which</span> would</span><br><span class="line">      require transferring data to and from user space</span><br></pre></td></tr></table></figure></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.ibm.com/developerworks/linux/library/j-zerocopy/" target="_blank" rel="external">https://www.ibm.com/developerworks/linux/library/j-zerocopy/</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man2/sendfile.2.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/（更详细）" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/（更详细）</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/（更详细）" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/（更详细）</a><br>DMA:direct memory access 直接内存访问</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[操作系统中的零拷贝原理及实现]]>
    
    </summary>
    
      <category term="网络" scheme="http://blog.onlycatch.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="计算机基础" scheme="http://blog.onlycatch.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据库事务]]></title>
    <link href="http://blog.onlycatch.com/database-transaction/"/>
    <id>http://blog.onlycatch.com/database-transaction/</id>
    <published>2016-01-26T12:18:10.000Z</published>
    <updated>2016-01-26T12:18:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4EC0_u4E48_u662F_u6570_u636E_u5E93_u4E8B_u52A1"><a href="#u4EC0_u4E48_u662F_u6570_u636E_u5E93_u4E8B_u52A1" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h2><p>数据库事务指的是对数据库进行的一些列操作集合。这些集合中的操作要么全部执行成功，要么全部回滚。</p>
<h2 id="u6570_u636E_u5E93_u4E8B_u52A1_u7684ACID_u7279_u6027"><a href="#u6570_u636E_u5E93_u4E8B_u52A1_u7684ACID_u7279_u6027" class="headerlink" title="数据库事务的ACID特性"></a>数据库事务的ACID特性</h2><p>数据库事务必须满足ACID四个特性。</p>
<p>A(atomic):原子性。即事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，要么全部执行，要么全部不执行。<br>C(consistent):一致性，即事务的执行不能破坏数据库的完整性和一致性。一个事务在执行前和执行后，数据库都必须处于一致性状态。就是说，事务执行的结果必须使数据库从一个一致性状态转移到另一个一致性状态。<br>I(isolated):隔离性,在并发环境中，并发的事务是相互隔离的，一个事务的执行不被其他事务干扰。<br>D(durable):持久性。即一个事务一旦提交，它对数据库中对于数据状态的变更就是永久性的。也就是说，一旦某个事务成功结束，那么它对数据库的变更就必须被永久保存下来。</p>
<h2 id="u6570_u636E_u5E93_u4E8B_u52A1_u9694_u79BB_u7EA7_u522B"><a href="#u6570_u636E_u5E93_u4E8B_u52A1_u9694_u79BB_u7EA7_u522B" class="headerlink" title="数据库事务隔离级别"></a>数据库事务隔离级别</h2><p>数据库事务有四种隔离级别:Read Uncommited,read commited,repeatable read,serialization。意思就是 未提交读，提交读，可重复读，序列化四个级别。四个级别的隔离程度依次升高，并发性也就依次降低。</p>
<p>Read Uncommited: 看字面意思就可以理解，即读取到了未提交的数据。即事务A修改了数据但是还没提交，此时事务B进来读取了该数据，而读取的数据正好是A刚修改却还没提交的。这就叫 read uncommited。该隔离级别下，事务B可以读取到事务A未提交的修改。这种情况叫做”脏读”</p>
<p>Read Commited: 该隔离级别下，事务B不能读取到事务A未提交的修改，只能等到事务A提交了之后，事务B才能读取到A做的修改。但是该级别下仍然存在一个问题:”不可重复读”。即事务B分两次读取数据，第一次在事务A提交之前，第二次在事务A提交之后，如果事务A对数据进行了更改，那么事务B的两次读取结果是不相同的。也就是说，不能重复读取。</p>
<p>Repeatable read:可重复读，就是说允许事务B两次读取同一组数据，并且所得结果一样。该隔离级别解决了不可重复读的问题，但是仍然存在“幻读”的问题。</p>
<p>Serialization:序列化，能够解决幻读的问题，这是最高的隔离级别。</p>
<p>幻读：第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
<h2 id="u4E0D_u540C_u9694_u79BB_u7EA7_u522B_u5BF9_u6BD4"><a href="#u4E0D_u540C_u9694_u79BB_u7EA7_u522B_u5BF9_u6BD4" class="headerlink" title="不同隔离级别对比"></a>不同隔离级别对比</h2><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ_UNCOMMITTED</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>READ_COMMITTED</td>
<td>禁止</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>REPEATABLE_READ</td>
<td>禁止</td>
<td>禁止</td>
<td>允许</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>禁止</td>
<td>禁止</td>
<td>禁止</td>
</tr>
</tbody>
</table>
<p>事务隔离级别越高，就越能保证数据的完整性和一致性，但同时对于并发性能的影响也就越大。<br>在MySQL中，InnoDB默认的隔离级别是Repeatable read。</p>
<h2 id="u6269_u5C55_u9605_u8BFB"><a href="#u6269_u5C55_u9605_u8BFB" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol>
<li><a href="http://my.oschina.net/huangyong/blog/160012" target="_blank" rel="external">http://my.oschina.net/huangyong/blog/160012</a></li>
<li><a href="http://my.oschina.net/huangyong/blog/159852" target="_blank" rel="external">http://my.oschina.net/huangyong/blog/159852</a></li>
<li><a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank" rel="external">https://en.wikipedia.org/wiki/Database_transaction</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[数据库事务以及ACID性质]]>
    
    </summary>
    
      <category term="数据库" scheme="http://blog.onlycatch.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka学习笔记之初见]]></title>
    <link href="http://blog.onlycatch.com/kafka-selflearning-00/"/>
    <id>http://blog.onlycatch.com/kafka-selflearning-00/</id>
    <published>2016-01-25T12:07:48.000Z</published>
    <updated>2016-01-25T12:08:30.000Z</updated>
    <content type="html"><![CDATA[<p>kafka是一个高性能的分布式消息系统。高水平扩展和高吞吐量。支持动态扩容，由LinkedIn用Scala编写而成。</p>
<h2 id="kafka_u4E0E_u5176_u4ED6_u6D88_u606F_u7CFB_u7EDF_u5BF9_u6BD4"><a href="#kafka_u4E0E_u5176_u4ED6_u6D88_u606F_u7CFB_u7EDF_u5BF9_u6BD4" class="headerlink" title="kafka与其他消息系统对比"></a>kafka与其他消息系统对比</h2><p>flume,storm,spark,elesticsearch都能与kafka集成。<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/kafka.png" alt="kafka与其他消息系统的对比"></p>
<ol>
<li>kafka使用的协议为仿AMQP协议。</li>
<li>kafka不支持事务，activeMQ支持</li>
<li>kafka支持动态扩容，集群，负载均衡。</li>
</ol>
<p><a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol" target="_blank" rel="external">AMQP协议</a>:<a href="http://langyu.iteye.com/blog/759663" target="_blank" rel="external">http://langyu.iteye.com/blog/759663</a></p>
<h2 id="kafka_u7684_u6D88_u8D39_u8005_u7F16_u7A0B_u6A21_u578B"><a href="#kafka_u7684_u6D88_u8D39_u8005_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="kafka的消费者编程模型"></a>kafka的消费者编程模型</h2><ol>
<li>分区消费模型</li>
<li>组消费模型<h3 id="u5206_u533A_u6D88_u8D39_u6A21_u578B"><a href="#u5206_u533A_u6D88_u8D39_u6A21_u578B" class="headerlink" title="分区消费模型"></a>分区消费模型</h3>缺点：</li>
<li>需要自己处理各种异常情况</li>
<li>需要自己管理消息偏移量以实现消息传递的各种语义</li>
</ol>
<h3 id="u6D88_u606F_u4F20_u9012_u7684_u8BED_u4E49"><a href="#u6D88_u606F_u4F20_u9012_u7684_u8BED_u4E49" class="headerlink" title="消息传递的语义"></a>消息传递的语义</h3><ol>
<li>至少一次：发送者向消费者至少发送一次（可能会重复）</li>
<li>至多一次：发送者向消费者至多发送一次（可能会丢）</li>
<li>有且仅有一次：发送者与消费者的关系一对一。<h3 id="u7EC4_u6D88_u8D39_u6A21_u578B"><a href="#u7EC4_u6D88_u8D39_u6A21_u578B" class="headerlink" title="组消费模型"></a>组消费模型</h3></li>
<li>不需要自己处理异常情况，不需要自己管理offset</li>
<li>只能实现默认的kafka至少一次的消息传递语义</li>
</ol>
<h2 id="kafka_u7684_u751F_u4EA7_u8005_u7F16_u7A0B_u6A21_u578B"><a href="#kafka_u7684_u751F_u4EA7_u8005_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="kafka的生产者编程模型"></a>kafka的生产者编程模型</h2><h3 id="u540C_u6B65_u751F_u4EA7_u6A21_u578B"><a href="#u540C_u6B65_u751F_u4EA7_u6A21_u578B" class="headerlink" title="同步生产模型"></a>同步生产模型</h3><p>生产者发送消息后需要等待kafka集群的确认消息，直到收到确认消息或者超过最大投递次数。</p>
<p>特点：</p>
<ol>
<li>低消息丢失率</li>
<li>高消息重复率（网络原因导致回复确认没收到）</li>
<li>高延迟<h3 id="u5F02_u6B65_u751F_u4EA7_u6A21_u578B"><a href="#u5F02_u6B65_u751F_u4EA7_u6A21_u578B" class="headerlink" title="异步生产模型"></a>异步生产模型</h3>生产者先把消息发送到客户端的缓冲队列，队列中的消息会被打包一起发送到kafka服务器。<br>特点：</li>
<li>高消息丢失率（无确认机制，发送端队列满）</li>
<li>高发送性能</li>
<li>低延迟</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[kafka入门简介]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://blog.onlycatch.com/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://blog.onlycatch.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka学习笔记之高性能设计]]></title>
    <link href="http://blog.onlycatch.com/kafka-selflearning-02/"/>
    <id>http://blog.onlycatch.com/kafka-selflearning-02/</id>
    <published>2016-01-25T12:03:52.000Z</published>
    <updated>2016-01-25T13:15:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6301_u4E45_u5316"><a href="#u6301_u4E45_u5316" class="headerlink" title="持久化"></a>持久化</h2><p>kafka非常依赖文件系统进行消息存储和缓存。大部分人会认为“磁盘很慢”，所以很多人会怀疑持久化是否能够提供很好的性能。实际上磁盘速度的快慢与磁盘的使用方式有着很大关系，设计好的磁盘结构通常会很快。</p>
<p>对于磁盘的线性读写操作在很多系统中都进行了大量优化，在某些情况下，对于磁盘的顺序访问甚至比对于内存的随机访问还要快！</p>
<p>很多现代操作系统都大量使用主存做磁盘缓存，一个现代操作系统可以将内存中的所有剩余空间用作磁盘缓存，而当内存回收的时候几乎没有性能损失。所有的磁盘读写都会经过这个统一的缓存。哪怕使用directI/O，这个特性也很难被关闭，所以如果某个进程维护了一份进程内缓存，那么这部分数据很可能也在操作系统的页面缓存中存在。</p>
<p>由于kafka是基于JVM的，并且任何与java内存使用打过交道的人都知道两件事：</p>
<ol>
<li>对象的内存开销非常高，通常是实际要存储数据大小的两倍</li>
<li>随着数据的增加，java的垃圾收集也会越来越频繁并且缓慢<br>基于此，使用文件系统，同时依赖页面缓存就比使用其他数据结构和维护内存缓存更有吸引力：</li>
<li>不使用进程内缓存，就腾出了内存空间，可以用来存放页面缓存的空间几乎可以翻倍。</li>
<li>如果kafka重启，进行内缓存就会丢失，但是使用操作系统的页面缓存依然可以继续使用。</li>
</ol>
<p>kafka如此频繁利用页面缓存，如果内存大小不够了怎么办？kafka会将数据写入到持久化日志中而不是刷新到磁盘。实际上它只是转移到了内核的页面缓存。</p>
<h2 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="http://kafka.apache.org/documentation.html#design_constanttime" target="_blank" rel="external">http://kafka.apache.org/documentation.html#design_constanttime</a></p>
<h2 id="u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C_u548C_u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D"><a href="#u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C_u548C_u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D" class="headerlink" title="大量的小IO操作和大量的字节拷贝"></a>大量的小IO操作和大量的字节拷贝</h2><p>除了上面说的磁盘读写影响性能之外，另外两个影响性能的就是：</p>
<ol>
<li>大量的IO操作</li>
<li>大量的字节拷贝</li>
</ol>
<h3 id="u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C"><a href="#u5927_u91CF_u7684_u5C0FIO_u64CD_u4F5C" class="headerlink" title="大量的小IO操作"></a>大量的小IO操作</h3><p>对于消息服务端来说，写操作是很频繁的，为了避免这个问题，kafka的协议是基于一种“消息集合”的抽象，它允许网络请求将消息集中发送而不是每次发送一条消息。服务端同样，也是一次性将一组消息写入日志，消费者也是每次取一大块。</p>
<p>这样做能够产生更大的网络数据包，更大的连续磁盘操作以及连续的内存块，这些都使得kafka更容易将大量随机消息编程线性的写操作。</p>
<h3 id="u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D"><a href="#u5927_u91CF_u7684_u5B57_u8282_u62F7_u8D1D" class="headerlink" title="大量的字节拷贝"></a>大量的字节拷贝</h3><p>kafka消费者，生产者还有服务端使用的日志格式都是一样的。这样做的好处就是能够为网络传输数据块提供最大的优化。</p>
<p>一般来讲，将文件中的数据转移到Socket需要经过以下几步：</p>
<ol>
<li>操作系统将数据从磁盘读到内核空间的页面缓存中</li>
<li>应用程序从内核空间将数据读取到用户空间</li>
<li>应用程序将数据重新写入到内核空间中的socket缓存中</li>
<li>操作系统将数据从socket缓存中拷贝到网卡缓存中（网卡缓存中的数据将被发送到网络中）</li>
</ol>
<p>上面的过程经过了四次拷贝和两次系统调用，明显这是不高效的。<br>通过使用sendfile API,允许操作系统直接从页面缓存将数据发送到网络，就减少了不必要的拷贝，只有最后一步：将数据拷贝到网卡缓存是必须的。</p>
<p>假设某个Topic有多个消费者，使用上面的零拷贝技术，数据只会被拷贝一次进入页面缓存，每次消费都可以被重复使用。这样就避免了每次读的时候都将数据存到内存中然后拷贝到内核空间。</p>
<h2 id="u7AEF_u5230_u7AEF_u6279_u91CF_u538B_u7F29"><a href="#u7AEF_u5230_u7AEF_u6279_u91CF_u538B_u7F29" class="headerlink" title="端到端批量压缩"></a>端到端批量压缩</h2><p>在很多情况下，系统的瓶颈不是CPU而是带宽。所以数据压缩就很重要。<br>可以每个消息都压缩，但是压缩率相对很低。所以kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩。<br>kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩。<br>kafka支持Gzip和Snappy压缩协议。</p>
<h2 id="u751F_u4EA7_u8005"><a href="#u751F_u4EA7_u8005" class="headerlink" title="生产者"></a>生产者</h2><h3 id="u8D1F_u8F7D_u5747_u8861"><a href="#u8D1F_u8F7D_u5747_u8861" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>生产者直接将数据发送到broker中，中间不会经过任何路由层。<br>为了达到这个目的，所有的kafka节点都能在任何时候回答是否服务器可以用以及主题分区的leader机器在哪里等问题，以便于生产者正确的发送数据。</p>
<p>生产者客户端控制着消息发往哪个分区。可以通过随机负载均衡或者其他分区语义功能来实现。kafka提供了分区语义接口允许用户指定一个用户哈希分析的字段。</p>
<h3 id="u5F02_u6B65_u53D1_u9001"><a href="#u5F02_u6B65_u53D1_u9001" class="headerlink" title="异步发送"></a>异步发送</h3><p>为了实现批量发送，kafka需要在内存中积累数据，以便于在单次请求中发送足够大的数据。可以通过配置消息数量不超过某个值或者等待时间不超过某个值来进行控制。</p>
<h2 id="u6D88_u8D39_u8005"><a href="#u6D88_u8D39_u8005" class="headerlink" title="消费者"></a>消费者</h2><p>消费者通过指定log的offset来获取消息，每次取回一块以指定的offset开始的消息块。</p>
<h3 id="u63A8_vs-__u62C9"><a href="#u63A8_vs-__u62C9" class="headerlink" title="推 vs. 拉"></a>推 vs. 拉</h3><p>在kafka中，消息是被消费者推到broker的，然后被生产者拉过来。<br>一些以日志为中心的系统，比如Scibe和Flume则允许将数据推向下游。</p>
<p>推和拉各有利弊，推模式中，由于是broker控制数据传输速度，目标是以尽可能提高消费者的消息消费率，push模式中，如果消费者消费速度跟不上推的速度，消费者就处于过载状态。而使用拉模式，消费者可以根据自己的处理能力控制拉取消息的速度。</p>
<p>传统拉模式的缺点是：如果服务端没有消息，消费者将会进入循环等待，直到新的数据到达。为了避免这个问题，kafka提供了配置参数，允许消费者请求进入long poll 等待，直到有数据到达。（。。。表示不太懂）</p>
<h3 id="u6D88_u8D39_u8005_u4F4D_u7F6E"><a href="#u6D88_u8D39_u8005_u4F4D_u7F6E" class="headerlink" title="消费者位置"></a>消费者位置</h3><p>在很多消息系统中，服务端是需要维护消息的消费状态的，即当消息投递给消费者之后，服务端要么立即记录下来，要么等待消费端的确认。</p>
<p>如果broker每次将消息投递出去就将消息状态置为“已消费”，那么如果消费者没有成功消费该消息（可能消费者宕机了或者请求超时了等），那消息就相当于丢失了。为了避免这个问题，很多系统增加了确认机制，当消息发送出去的时候，被置为“已发送”状态而不是“已消费”，当收到消费者的确认信息之后，才将消息状态置为“已消费”。</p>
<p>但这会有新的问题，首先，如果消费者消费了消息但是在发送确认信息之前出错了，那么消息将会被消费两次。其次是性能问题，这样一来broker就必须维护很多状态（每条信息一组状态）。另外还需要处理很多其他问题，例如:消息发送出去了但是没有收到确认该怎么办？</p>
<p>kafka的做法是这样的：<br>Topic被分成多个完全有序的分区，任何时候，任意一个分区都只有一个消费者消费。这意味着在每个分区中的消费者位置都是一个整数：下一个即将消费的offset值。这样就使得消息确认变得很容易。<br>另外还有一个好处：消费者可以故意将offset置为一个很老的值，然后重新消费数据。</p>
<h3 id="u79BB_u7EBF_u6570_u636E_u52A0_u8F7D"><a href="#u79BB_u7EBF_u6570_u636E_u52A0_u8F7D" class="headerlink" title="离线数据加载"></a>离线数据加载</h3><h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>kafka使用文件系统作为持久化介质，为了提高速度采用了顺序读写磁盘的方式。</li>
<li>kafka使用了页面缓存而不是进程内缓存，即可以提高缓存空间又能保证重启的时候缓存不是小。</li>
<li>kafka的写操作使用了sendfile API，它允许在文件描述符之间传输数据，从而减少了不必要的拷贝，提高了效率。</li>
<li>kafka支持批量消息压缩，从而降低对网络带宽的占用。</li>
<li>生产者负载均衡是在客户端实现，生产者直接将数据发送到broker中</li>
<li>kafka中，生产者推数据到broker中，消费者从broker中拉取数据</li>
<li>kafka分区和offset降低了消息状态维护的成本</li>
</ol>
<h2 id="u53C2_u8003_u6587_u6863"><a href="#u53C2_u8003_u6587_u6863" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://kafka.apache.org/documentation.html#design" target="_blank" rel="external">kafka设计</a></li>
<li><a href="http://umeng.baijia.baidu.com/article/227913" target="_blank" rel="external">kafka高性能吞吐揭秘</a></li>
<li><a href="https://www.varnish-cache.org/trac/wiki/ArchitectNotes" target="_blank" rel="external">Vanish的以页面缓存为中心的设计</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">sendfile API</a></li>
<li><a href="https://www.ibm.com/developerworks/linux/library/j-zerocopy/" target="_blank" rel="external">零拷贝</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Kafka在设计过程中的为了追求高性能而做的一些处理]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://blog.onlycatch.com/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://blog.onlycatch.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka学习笔记之基础概念及原理]]></title>
    <link href="http://blog.onlycatch.com/kafka-selflearning-01/"/>
    <id>http://blog.onlycatch.com/kafka-selflearning-01/</id>
    <published>2016-01-25T12:02:11.000Z</published>
    <updated>2016-01-25T12:03:19.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u7EC4_u4EF6_u6982_u5FF5"><a href="#u7EC4_u4EF6_u6982_u5FF5" class="headerlink" title="组件概念"></a>组件概念</h3><p>Topic:消息分类<br>Producer:发布消息到kafka集群<br>consumer:订阅Topic并且处理消息<br>broker:组成kafka集群的服务器</p>
<p>kafka客户端与服务端通信是通过TCP协议实现的。</p>
<h3 id="u6570_u636E_u5B58_u50A8"><a href="#u6570_u636E_u5B58_u50A8" class="headerlink" title="数据存储"></a>数据存储</h3><p>一个kafka集群通常包含多个代理（broker)，为了负载均衡，将话题分为多个分区，每个代理存储一个或多个分区。多个producer和comsumer可以同时生产和获取消息。</p>
<p><img src="http://kafka.apache.org/images/log_anatomy.png" alt="kafka分区"><br>如上图：每个Topic对应多个分区，每个分区是一个有序的消息序列，新提交的消息被添加在序列尾部。</p>
<p>每个分区对应一个逻辑日志，物理上，一个日志为相同大小的一组分段文件。每次生产者发布消息到一个分区，代理就将消息追加到最后一个段文件中。当发布的消息数量达到设定值或者经过一段时间之后，段文件真正写入磁盘。写入完成后，消息公开给消费者（只有同步到磁盘之后才会通知消费者？？）。</p>
<p>kafka中的消息没有消息id，而是通过offset(偏移量)来确定消息的位置。这样就避免了维护消息ID到实际消息地址的开销。消费者向代理异步发出拉请求，每个拉请求都包含要消费的消息偏移量。</p>
<p>如图：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/%40%2Fima%2F0609012.png" alt="kafka存储结构"></p>
<h3 id="u4F7F_u7528_u5206_u533A_u5B58_u50A8_u6709_u4EC0_u4E48_u597D_u5904_uFF1F"><a href="#u4F7F_u7528_u5206_u533A_u5B58_u50A8_u6709_u4EC0_u4E48_u597D_u5904_uFF1F" class="headerlink" title="使用分区存储有什么好处？"></a>使用分区存储有什么好处？</h3><ol>
<li>允许超过单机允许大小的日志文件存在</li>
<li>多个分区可以提高并行度</li>
</ol>
<h3 id="u5206_u5E03_u5F0F"><a href="#u5206_u5E03_u5F0F" class="headerlink" title="分布式"></a>分布式</h3><p>分区日志分布在kafka集群中的多台机器上，每台机器处理一部分分区。每个分区在多台机器上进行备份以增加容错性。</p>
<p>每个分区只有一个leader机器，0台或者多台follower机器。leader机器处理对该分区的所有读写请求，follower机器负责同步leader机器的数据。如果leader挂掉了，剩下的followers将自动选一台leader。</p>
<p>一台机器作为A分区的follower可以作为B分区的leader，这样就实现了集群内负载均衡。</p>
<h3 id="u6570_u636E_u4F20_u8F93"><a href="#u6570_u636E_u4F20_u8F93" class="headerlink" title="数据传输"></a>数据传输</h3><p>kafka利用sendfile API从代理的日志段文件中分发字节给消费者。<br>sendfile API:<a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man2/sendfile.2.html</a><br>它可以直接在两个文件的描述符之间传输数据，sendfile(）可以将一个文件描述符表示的文件中的数据拷贝到另外的文件描述符中，由于拷贝是在内核中进行的，所以比组合使用read()和write()要快很多，因为后者read和write数据需要经过用户空间。</p>
<h3 id="kafka_u4EE3_u7406_uFF08broker_uFF09"><a href="#kafka_u4EE3_u7406_uFF08broker_uFF09" class="headerlink" title="kafka代理（broker）"></a>kafka代理（broker）</h3><p>kafka代理是无状态的，消费者需要自己维护已消费的状态信息。<br>代理删除消息：代理由于无状态，故它不知道消费者是否已经使用了该消息。Kafka使用基于时间的SLA应用于保留策略。当消息在代理中超过一定时间后，将会被自动删除。</p>
<p>kafka集群会维护所有发布的消息，无论是否被消费过，直到消息过期。过期时间是可以配置的。比如：某个日志被设置为两天，那么消息发布之后两天之内，它都是可以被消费的，但是两天之后，kafka将把消息丢弃以腾出空间。<br>kafka的性能是不受存储数据大小的影响的，所以维护大量数据并不是问题。</p>
<h3 id="zookeeper_u4E0Ekafka"><a href="#zookeeper_u4E0Ekafka" class="headerlink" title="zookeeper与kafka"></a>zookeeper与kafka</h3><p>ZooKeeper在kafka中被用于管理、协调Kafka代理。每个Kafka代理都通过ZooKeeper协调其它Kafka代理。当Kafka系统中新增了代理或者某个代理故障失效时，ZooKeeper服务将通知生产者和消费者。生产者和消费者据此开始与其它代理协调工作。<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/%40%2Fima%2Fkafka_zk.png" alt="zk在kafka中的应用"></p>
<h3 id="u6D88_u8D39_u8005_u7EC4"><a href="#u6D88_u8D39_u8005_u7EC4" class="headerlink" title="消费者组"></a>消费者组</h3><p>传统消息系统有两种模型：队列模型和发布-订阅模型。<br>队列模型：队列中的每条消息只会发到众多消费者中的一个。<br>发布订阅模型：消息会被广播到所有的消费者。</p>
<p>kafka将消费者抽象出来了“消费者组”的概念，这个概念能够同时实现上述两种模型的功能。</p>
<p>每个消费者属于一个组，消息会被发送到每个组中的某一个消费者实例。<br>注意：每个组中的某一个消费者实例。意思就是，假如我有2个组，A和B，然后有一条消息，这条消息会被发往A和B两个组，但是每个组中只有一个消费者实例能够收到该条消息。所以就有了如下变种：</p>
<p>如果所有的消费者都属于一个组，那么就相当于实现了队列模型。<br>如果每个消费者都属于不同的组，那么就相当于实现了发布-订阅模型。</p>
<h3 id="u6D88_u606F_u987A_u5E8F_u4FDD_u8BC1"><a href="#u6D88_u606F_u987A_u5E8F_u4FDD_u8BC1" class="headerlink" title="消息顺序保证"></a>消息顺序保证</h3><p>kafka提供了很高的消息顺序保证。</p>
<p>传统的消息系统服务器，在服务端按存储顺序维护消息，但是消息发送给消费者是通过异步发送的，所以消息实际到达消费者的顺序就可能与服务端维护的顺序不一致。很多消息系统对此采用的办法就是只允许一个进程消费消息，这样虽然能够保证消息的顺序性，但是却丢失了并发性。</p>
<p>kafka通过将Topic进行分区，很好的提高了并发性，它既能提供顺序保证又能在多个消费者之间做到负载均衡。它是通过绑定主题分区与消费者组中的消费者，从而保证每个分区只能被分区中的一个消费者所消费。这样就能够保证被指定的消费者是唯一一个读取指定分区的消费者，并且该消费者按顺序消费数据。由于存在多个分区，所以仍然不必担心负载均衡的问题。</p>
<p>简单来说就是：kafka是通过保证某一个分区是只被每个组中的一个消费者消费，控制的只是单个分区中消息的顺序。如果你要保证整个Topic的消息顺序，那只需要将分区数设置为1就可以了。</p>
<h3 id="kafka_u63D0_u4F9B_u7684_u4FDD_u8BC1"><a href="#kafka_u63D0_u4F9B_u7684_u4FDD_u8BC1" class="headerlink" title="kafka提供的保证"></a>kafka提供的保证</h3><ul>
<li>生产者发送到某个特定Topic分区的消息将会按照它们的发送顺序依次追加。就是说，如果M1和M2是由同一个生产者发送的消息，M1是先发送的，那么M1在日志中的offset就会比M2低很多。</li>
<li>消费者实例看到消息的顺序与它们在日志中的存储顺序一致。</li>
<li>对于备份因子为N的一个消息主题，可以允许N-1台服务器宕机而不会丢失任何已经提交到日志中的消息。</li>
</ul>
<h3 id="kafka_u7684_u5E94_u7528_u573A_u666F"><a href="#kafka_u7684_u5E94_u7528_u573A_u666F" class="headerlink" title="kafka的应用场景"></a>kafka的应用场景</h3><ol>
<li>消息系统</li>
<li>网站活动追踪</li>
<li>日志收集</li>
<li>流处理（与Storm配合使用）</li>
<li>事件源</li>
<li>日志提交（Bookeeper)</li>
</ol>
<h3 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.infoq.com/cn/articles/apache-kafka" target="_blank" rel="external">Apache Kafka：下一代分布式消息系统</a></li>
<li><a href="http://kafka.apache.org/documentation.html#uses" target="_blank" rel="external">Kafka官方文档</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[kafka的基本概念以及原理解释，学习记录，有点乱。]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://blog.onlycatch.com/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://blog.onlycatch.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dubbo启动脚本学习]]></title>
    <link href="http://blog.onlycatch.com/how-linux-commands-used-in-dubbo/"/>
    <id>http://blog.onlycatch.com/how-linux-commands-used-in-dubbo/</id>
    <published>2016-01-25T11:59:07.000Z</published>
    <updated>2016-01-25T12:00:10.000Z</updated>
    <content type="html"><![CDATA[<p>Dubbod启动的脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`</span><br><span class="line">BIN_DIR=`<span class="built_in">pwd</span>`</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">DEPLOY_DIR=`<span class="built_in">pwd</span>`</span><br><span class="line">CONF_DIR=<span class="variable">$DEPLOY_DIR</span>/conf</span><br><span class="line"></span><br><span class="line">SERVER_NAME=`sed <span class="string">'/dubbo.application.name/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br><span class="line">SERVER_PROTOCOL=`sed <span class="string">'/dubbo.protocol.name/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br><span class="line">SERVER_PORT=`sed <span class="string">'/dubbo.protocol.port/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br><span class="line">LOGS_FILE=`sed <span class="string">'/dubbo.log4j.file/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$SERVER_NAME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    SERVER_NAME=`hostname`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">PIDS=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$CONF_DIR</span>"</span> |awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$PIDS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ERROR: The <span class="variable">$SERVER_NAME</span> already started!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"PID: <span class="variable">$PIDS</span>"</span></span><br><span class="line">    <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$SERVER_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    SERVER_PORT_COUNT=`netstat -tln | grep <span class="variable">$SERVER_PORT</span> | wc <span class="operator">-l</span>`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$SERVER_PORT_COUNT</span> <span class="operator">-gt</span> <span class="number">0</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"ERROR: The <span class="variable">$SERVER_NAME</span> port <span class="variable">$SERVER_PORT</span> already used!"</span></span><br><span class="line">        <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">LOGS_DIR=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$LOGS_FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    LOGS_DIR=`dirname <span class="variable">$LOGS_FILE</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    LOGS_DIR=<span class="variable">$DEPLOY_DIR</span>/logs</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="variable">$LOGS_DIR</span> ]; <span class="keyword">then</span></span><br><span class="line">    mkdir <span class="variable">$LOGS_DIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">STDOUT_FILE=<span class="variable">$LOGS_DIR</span>/stdout.log</span><br><span class="line"></span><br><span class="line">LIB_DIR=<span class="variable">$DEPLOY_DIR</span>/lib</span><br><span class="line">LIB_JARS=`ls <span class="variable">$LIB_DIR</span>|grep .jar|awk <span class="string">'&#123;print "'</span><span class="variable">$LIB_DIR</span><span class="string">'/"$0&#125;'</span>|tr <span class="string">"\n"</span> <span class="string">":"</span>`</span><br><span class="line"></span><br><span class="line">JAVA_OPTS=<span class="string">" -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true "</span></span><br><span class="line">JAVA_DEBUG_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"debug"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_DEBUG_OPTS=<span class="string">" -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">JAVA_JMX_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"jmx"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_JMX_OPTS=<span class="string">" -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">JAVA_MEM_OPTS=<span class="string">""</span></span><br><span class="line">BITS=`java -version <span class="number">2</span>&gt;&amp;<span class="number">1</span> | grep -i <span class="number">64</span>-bit`</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$BITS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_MEM_OPTS=<span class="string">" -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 "</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    JAVA_MEM_OPTS=<span class="string">" -server -Xms1g -Xmx1g -XX:PermSize=128m -XX:SurvivorRatio=2 -XX:+UseParallelGC "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"Starting the <span class="variable">$SERVER_NAME</span> ...\c"</span></span><br><span class="line">nohup java <span class="variable">$JAVA_OPTS</span> <span class="variable">$JAVA_MEM_OPTS</span> <span class="variable">$JAVA_DEBUG_OPTS</span> <span class="variable">$JAVA_JMX_OPTS</span> -classpath <span class="variable">$CONF_DIR</span>:<span class="variable">$LIB_JARS</span> com.alibaba.dubbo.container.Main &gt; <span class="variable">$STDOUT_FILE</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"></span><br><span class="line">COUNT=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$COUNT</span> <span class="operator">-lt</span> <span class="number">1</span> ]; <span class="keyword">do</span>    </span><br><span class="line">    <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">".\c"</span></span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$SERVER_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$SERVER_PROTOCOL</span>"</span> == <span class="string">"dubbo"</span> ]; <span class="keyword">then</span></span><br><span class="line">    	    COUNT=`<span class="built_in">echo</span> status | nc -i <span class="number">1</span> <span class="number">127.0</span>.<span class="number">0.1</span> <span class="variable">$SERVER_PORT</span> | grep -c OK`</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            COUNT=`netstat -an | grep <span class="variable">$SERVER_PORT</span> | wc <span class="operator">-l</span>`</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	COUNT=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$DEPLOY_DIR</span>"</span> | awk <span class="string">'&#123;print $2&#125;'</span> | wc <span class="operator">-l</span>`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$COUNT</span> <span class="operator">-gt</span> <span class="number">0</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"OK!"</span></span><br><span class="line">PIDS=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$DEPLOY_DIR</span>"</span> | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID: <span class="variable">$PIDS</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"STDOUT: <span class="variable">$STDOUT_FILE</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>下面是简单的解释：</p>
<p>startserver.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`</span><br></pre></td></tr></table></figure></p>
<p>$0当前Shell程序的文件名<br>dirname $0，获取当前Shell程序的路径<br>cd <code>dirname $0</code>，进入当前Shell程序的目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SERVER_NAME=`sed <span class="string">'/dubbo.application.name/!d;s/.*=//'</span> conf/dubbo.properties | tr <span class="operator">-d</span> <span class="string">'\r'</span>`</span><br></pre></td></tr></table></figure>
<p><code>sed &#39;/dubbo.application.name/!d;s/.*=//&#39; ../conf/dubbo.properties</code> 从conf/dubbo.properties文件中截取dubbo.application.name对应的值</p>
<p><code>sed &#39;/dubbo.application.name/!d&#39; dubbo.properties</code> 从dubbo.properties文件中查找包含dubbo.application.name的行，<code>!d</code>表示不删除，这样执行完的结果是：<br><code>ubbo.application.name=my-server</code></p>
<p>后面的：<code>;s/.*=//</code> 表示替换，即将所得数据中的 ‘.*=’部分，替换成掉。<br>结果：<br><code>my-server</code> 即，只有我的服务名称了</p>
<p><code>tr -d &#39;\r&#39;</code> 将回车符号删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$SERVER_NAME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    SERVER_NAME=`hostname`</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if  [ -z $string  ]             如果string 为空</p>
<p><code>hostname</code> 显示当前系统的hostname</p>
<blockquote>
<p>hostname - show or set the system’s host name<br>       domainname - show or set the system’s NIS/YP domain name<br>       dnsdomainname - show the system’s DNS domain name<br>       nisdomainname - show or set system’s NIS/YP domain name<br>       ypdomainname - show or set the system’s NIS/YP domain name</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PIDS=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$CONF_DIR</span>"</span> |awk <span class="string">'&#123;print $2&#125;'</span>`</span><br></pre></td></tr></table></figure>
<p><code>ps -f | grep java | grep &quot;$CONF_DIR&quot;</code> 根据配置文件路径定位到当前服务的进程id。格式如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root     <span class="number">25867</span>     <span class="number">1</span>  <span class="number">0</span> Jan04 ?        <span class="number">00</span>:<span class="number">37</span>:<span class="number">35</span> java -Djava.awt.headless=<span class="literal">true</span> -Djava.net.preferIPv4Stack=<span class="literal">true</span> -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=<span class="number">128</span>m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompa...</span><br></pre></td></tr></table></figure></p>
<p>此时调用<code>awk &#39;{print $2}&#39;</code>，则将第二列打印出来，正好是当前进行的进程id。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$PIDS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"ERROR: The <span class="variable">$SERVER_NAME</span> already started!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"PID: <span class="variable">$PIDS</span>"</span></span><br><span class="line">    <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if  [ -n $string  ]             如果string 非空(非0），返回0(true)<br>若果当前进程存在，则输出：已经启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$SERVER_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    SERVER_PORT_COUNT=`netstat -tln | grep <span class="variable">$SERVER_PORT</span> | wc <span class="operator">-l</span>`</span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$SERVER_PORT_COUNT</span> <span class="operator">-gt</span> <span class="number">0</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"ERROR: The <span class="variable">$SERVER_NAME</span> port <span class="variable">$SERVER_PORT</span> already used!"</span></span><br><span class="line">        <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>如果端口号不为空，则通过<br><code>netstat -tln | grep $SERVER_PORT | wc -l</code> 来统计当前已经占用该端口的数量<br>如果数量大于0.则提示端口被占用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOGS_DIR=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$LOGS_FILE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    LOGS_DIR=`dirname <span class="variable">$LOGS_FILE</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    LOGS_DIR=<span class="variable">$DEPLOY_DIR</span>/logs</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="variable">$LOGS_DIR</span> ]; <span class="keyword">then</span></span><br><span class="line">    mkdir <span class="variable">$LOGS_DIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>if [ ! -d $LOGS_DIR ] 如果日志目录不存在，就创建该目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIB_DIR=<span class="variable">$DEPLOY_DIR</span>/lib</span><br><span class="line">LIB_JARS=`ls <span class="variable">$LIB_DIR</span>|grep .jar|awk <span class="string">'&#123;print "'</span><span class="variable">$LIB_DIR</span><span class="string">'/"$0&#125;'</span>|tr <span class="string">"\n"</span> <span class="string">":"</span>`</span><br></pre></td></tr></table></figure>
<p>获取lib目录下的jar包。</p>
<p><code>ls $LIB_DIR|grep .jar|</code> 获取lib目录下的所有.jar文件名称。<br><code>awk &#39;{print &quot;&#39;$LIB_DIR&#39;/&quot;$0}</code> 将上面的jar文件名称，拼接上lib的路径然后输出。</p>
<p><code>tr &quot;\n&quot; &quot;:&quot;</code> 将换行符替换成冒号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">" -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true "</span></span><br><span class="line">JAVA_DEBUG_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"debug"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_DEBUG_OPTS=<span class="string">" -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">JAVA_JMX_OPTS=<span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">"jmx"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_JMX_OPTS=<span class="string">" -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">JAVA_MEM_OPTS=<span class="string">""</span></span><br><span class="line">BITS=`java -version <span class="number">2</span>&gt;&amp;<span class="number">1</span> | grep -i <span class="number">64</span>-bit`</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$BITS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    JAVA_MEM_OPTS=<span class="string">" -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 "</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    JAVA_MEM_OPTS=<span class="string">" -server -Xms1g -Xmx1g -XX:PermSize=128m -XX:SurvivorRatio=2 -XX:+UseParallelGC "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"Starting the <span class="variable">$SERVER_NAME</span> ...\c"</span></span><br><span class="line">nohup java <span class="variable">$JAVA_OPTS</span> <span class="variable">$JAVA_MEM_OPTS</span> <span class="variable">$JAVA_DEBUG_OPTS</span> <span class="variable">$JAVA_JMX_OPTS</span> -classpath <span class="variable">$CONF_DIR</span>:<span class="variable">$LIB_JARS</span> com.alibaba.dubbo.container.Main &gt; <span class="variable">$STDOUT_FILE</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p><code>java -version 2&gt;&amp;1 | grep -i 64-bit</code>这里，首先将java版本号信息输出到标准输出，然后查找’64-bit’信息，目的就是判断jdk版本是否为64位。</p>
<p><code>nohup java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp;</code> 通过java命令启动服务，同时将其作为后台任务执行。</p>
<p>关于 <code>2&gt;&amp;1</code> 可以看：<a href="http://blog.sina.com.cn/s/blog_4aae007d010192qc.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4aae007d010192qc.html</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">COUNT=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$COUNT</span> <span class="operator">-lt</span> <span class="number">1</span> ]; <span class="keyword">do</span>   </span><br><span class="line">    <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">".\c"</span></span><br><span class="line">    sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$SERVER_PORT</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$SERVER_PROTOCOL</span>"</span> == <span class="string">"dubbo"</span> ]; <span class="keyword">then</span></span><br><span class="line">            COUNT=`<span class="built_in">echo</span> status | nc -i <span class="number">1</span> <span class="number">127.0</span>.<span class="number">0.1</span> <span class="variable">$SERVER_PORT</span> | grep -c OK`</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            COUNT=`netstat -an | grep <span class="variable">$SERVER_PORT</span> | wc <span class="operator">-l</span>`</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        COUNT=`ps <span class="operator">-f</span> | grep java | grep <span class="string">"<span class="variable">$DEPLOY_DIR</span>"</span> | awk <span class="string">'&#123;print $2&#125;'</span> | wc <span class="operator">-l</span>`</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$COUNT</span> <span class="operator">-gt</span> <span class="number">0</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>echo -e &quot;.\c&quot;</code><br><code>echo status | nc -i 1 127.0.0.1 $SERVER_PORT | grep -c OK</code></p>
<p>grep -c 阻止正常的结果输出，转而输出匹配的结果数量，这里就是输出OK的个数。</p>
]]></content>
    <summary type="html">
    <![CDATA[Dubbo启动脚本中的一些比较复杂的linux命令的使用介绍]]>
    
    </summary>
    
      <category term="Dubbo" scheme="http://blog.onlycatch.com/tags/Dubbo/"/>
    
      <category term="linux" scheme="http://blog.onlycatch.com/tags/linux/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Murmur哈希算法]]></title>
    <link href="http://blog.onlycatch.com/murmurhash/"/>
    <id>http://blog.onlycatch.com/murmurhash/</id>
    <published>2016-01-25T11:51:27.000Z</published>
    <updated>2016-01-25T11:56:37.000Z</updated>
    <content type="html"><![CDATA[<p>在看<a href="http://redisbook.com/preview/dict/hash_algorithm.html" target="_blank" rel="external">redis哈希</a>的时候发现了这个算法。</p>
<h2 id="u4F5C_u7528"><a href="#u4F5C_u7528" class="headerlink" title="作用"></a>作用</h2><p>MurmurHash是一种非加密型哈希函数。与其他流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好。</p>
<p>最早发明与2008年，目前的版本是MurmurHash3,可以产生32位或者128位的哈希值。其名字来自于MUltiply and Rotate,因为要经过多次MUltiply and Rotate，所以叫Murmur.</p>
<h2 id="u5B9E_u73B0"><a href="#u5B9E_u73B0" class="headerlink" title="实现"></a>实现</h2><p>在java中，Guava的Hashing类中提供了多个版本的实现。<br><a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/Murmur3_32HashFunction.java" target="_blank" rel="external">32位版本</a><br><a href="https://github.com/google/guava/blob/master/guava%2Fsrc%2Fcom%2Fgoogle%2Fcommon%2Fhash%2FMurmur3_128HashFunction.java" target="_blank" rel="external">128位版本</a></p>
<p>另外，很多应用广泛的开源产品也使用了MurmurHash<br><a href="https://github.com/xetorthio/jedis/blob/master/src/main/java/redis/clients/util/MurmurHash.java" target="_blank" rel="external">jedis的MurmurHash</a><br><a href="https://github.com/xetorthio/jedis/blob/master/src/main/java/redis/clients/util/MurmurHash.java" target="_blank" rel="external">cassandra的MurmurHash实现</a><br><a href="https://github.com/apache/hbase/blob/a545d71295e582398b2689ed09d2167d7f118cec/hbase-common/src/main/java/org/apache/hadoop/hbase/util/MurmurHash3.java" target="_blank" rel="external">Hbase中的Murmurhash</a><br><a href="https://lucene.apache.org/core/4_8_0/codecs/org/apache/lucene/codecs/bloom/MurmurHash2.html" target="_blank" rel="external">Lucene中的murmurhsah</a></p>
<h2 id="u76F8_u5173_u6587_u6863"><a href="#u76F8_u5173_u6587_u6863" class="headerlink" title="相关文档"></a>相关文档</h2><ol>
<li><a href="http://redisbook.com/preview/dict/hash_algorithm.html" target="_blank" rel="external">redis hash</a></li>
<li><a href="https://zh.wikipedia.org/zh-cn/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="external">murmur哈希wiki</a></li>
<li><a href="http://calvin1978.blogcn.com/articles/murmur.html" target="_blank" rel="external">陌生但默默一统江湖的MurmurHash</a></li>
<li><a href="http://openwares.net/misc/murmurhash%E7%AE%97%E6%B3%95.html" target="_blank" rel="external">murmurhash算法</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[一种非加密哈希算法，2008年发明，一杯应用于Redis，HBase，Cassandra等项目]]>
    
    </summary>
    
      <category term="哈希算法" scheme="http://blog.onlycatch.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://blog.onlycatch.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[密码学综述]]></title>
    <link href="http://blog.onlycatch.com/cryptology/"/>
    <id>http://blog.onlycatch.com/cryptology/</id>
    <published>2016-01-25T11:49:15.000Z</published>
    <updated>2016-01-25T11:55:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5BC6_u7801_u5B66_u7B97_u6CD5_u7684_u5206_u7C7B"><a href="#u5BC6_u7801_u5B66_u7B97_u6CD5_u7684_u5206_u7C7B" class="headerlink" title="密码学算法的分类"></a>密码学算法的分类</h2><ul>
<li>消息编码：base64</li>
<li>消息摘要：MD类，SHA类，MAC</li>
<li>对称密码: DES,3DES,AES</li>
<li>非对称密码：RSA，DH秘钥交换</li>
<li>数字签名：RSASignature，DSASignature</li>
</ul>
<h2 id="u5BC6_u7801_u5B665_u5143_u7956"><a href="#u5BC6_u7801_u5B665_u5143_u7956" class="headerlink" title="密码学5元祖"></a>密码学5元祖</h2><p>（明文，密文，加密算法，解密算法，密钥）<br>加密算法和解密算法都是公开的。使用保密的加密算法和解密算法是不够安全的，而且也很难做到保密工作）</p>
<p>安全性完全依赖于秘钥。</p>
<p>密码与密钥<br>密码=秘钥+规则<br>秘钥才是需要保证绝密的。</p>
<h2 id="u5BF9_u79F0_u5BC6_u7801_u4E0E_u975E_u5BF9_u79F0_u5BC6_u7801"><a href="#u5BF9_u79F0_u5BC6_u7801_u4E0E_u975E_u5BF9_u79F0_u5BC6_u7801" class="headerlink" title="对称密码与非对称密码"></a>对称密码与非对称密码</h2><p>对称密码：加密和解密使用相同的秘钥<br>非对称：加密和解密是用不同的秘钥。</p>
<p>两者不能相互取代，也无法区分哪个更安全。是否更安全主要取决于秘钥的长度以及破译密文所需要的计算量。</p>
<h2 id="java_u4E2D_u7684_u7C7B"><a href="#java_u4E2D_u7684_u7C7B" class="headerlink" title="java中的类"></a>java中的类</h2><ol>
<li>消息编码：BASE64Encoder,BASE64Decoder</li>
<li>消息摘要：MessageDigest</li>
<li>对称密码：KeyGenerator，SecretKey，Cipher</li>
<li>非对称密码：KeyPairGenerator,KeyFactory,KeyPair,PublicKey,PrivateKey,Cipher</li>
<li>数字签名：Signature</li>
</ol>
<h2 id="Base64_u7684_u7F16_u7A0B_u4F7F_u7528"><a href="#Base64_u7684_u7F16_u7A0B_u4F7F_u7528" class="headerlink" title="Base64的编程使用"></a>Base64的编程使用</h2><h3 id="Base64_u7B97_u6CD5_u5B9A_u4E49"><a href="#Base64_u7B97_u6CD5_u5B9A_u4E49" class="headerlink" title="Base64算法定义"></a>Base64算法定义</h3><p>是一种基于64个字符的编码算法，以任意8位字节序列组合的描述形式，这种形式不容易直接识别。<br>Base64秘钥：就是Base64字符映射表。</p>
<h3 id="Base64_u7F16_u7A0B_u4F7F_u7528"><a href="#Base64_u7F16_u7A0B_u4F7F_u7528" class="headerlink" title="Base64编程使用"></a>Base64编程使用</h3><p><img src="http://7xo4v8.com1.z0.glb.clouddn.com/base64.png" alt="Base64编程使用"></p>
<p>jdk本身没有自带，需要导入sun提供的BASE64相关jar包。</p>
<h3 id="Base64_u7B97_u6CD5_u7684_u5B9E_u9645_u5E94_u7528"><a href="#Base64_u7B97_u6CD5_u7684_u5B9E_u9645_u5E94_u7528" class="headerlink" title="Base64算法的实际应用"></a>Base64算法的实际应用</h3><p>最早被用在电子邮件中，由于邮件只允许传输ASCII码，所以需要用Base64编码。通过telnet远程登录邮箱可以看到使用Base64编码的账号和密码等信息。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p>极客学院课程</p>
]]></content>
    <summary type="html">
    <![CDATA[密码学相关信息]]>
    
    </summary>
    
      <category term="密码学" scheme="http://blog.onlycatch.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://blog.onlycatch.com/hello-world/"/>
    <id>http://blog.onlycatch.com/hello-world/</id>
    <published>2016-01-19T09:34:37.000Z</published>
    <updated>2016-01-19T09:34:37.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ shit</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Hexo 使用举例]]>
    
    </summary>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP三次握手和四次握手]]></title>
    <link href="http://blog.onlycatch.com/tcp-handshakes/"/>
    <id>http://blog.onlycatch.com/tcp-handshakes/</id>
    <published>2016-01-19T08:33:33.000Z</published>
    <updated>2016-01-23T14:55:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="TCP_u8FDE_u63A5_u5EFA_u7ACB_u65F6_u7684_u4E09_u6B21_u63E1_u624B"><a href="#TCP_u8FDE_u63A5_u5EFA_u7ACB_u65F6_u7684_u4E09_u6B21_u63E1_u624B" class="headerlink" title="TCP连接建立时的三次握手"></a>TCP连接建立时的三次握手</h2><p>TCP是面向连接的通信，所以在使用TCP通信之前，必须先建立连接。在连接正式建立之前，需要经过一个被称为“三次握手”（three-way handshake)的过程：</p>
<h3 id="u4E09_u6B21_u63E1_u624B"><a href="#u4E09_u6B21_u63E1_u624B" class="headerlink" title="三次握手"></a>三次握手</h3><p>连接建立的前提是服务端需要事先启动并监听到某个端口。</p>
<ol>
<li>客户端向服务端发送SYN报文</li>
<li>服务端收到SYN报文之后，向客户端发送确认报文ACK和SYN报文</li>
<li>客户端向服务端发送确认报文ACK<br>图解如下：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/three-way-handshake.png" alt="TCP三次握手"></li>
</ol>
<h3 id="u4E3A_u4EC0_u4E48_u9700_u8981_u4E09_u6B21_u63E1_u624B"><a href="#u4E3A_u4EC0_u4E48_u9700_u8981_u4E09_u6B21_u63E1_u624B" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><p>这个问题在网上有很多，但是我想问的是，如果不需要三次，那么需要几次呢？<br>我们可以把TCP连接建立过程想象成两个人通过qq聊天，A和B，A想和B聊天，但是A需要确认B是否能跟自己聊天，这个过程就可以用来模拟TCP连接的建立。</p>
<blockquote>
<p>A:在吗？<br>B:在的。</p>
</blockquote>
<p>首先A向B发送信息”在吗？“，就像TCP连接中的syn。<br>b收到之后，向A回复”在的“，就像TCP连接中的ack+syn。</p>
<p>其实如果是聊天，AB两句话过后就可以谈正事了。其实TCP也是这样，按道理也可以开始数据传输了，第三次就可以携带数据。但是为什么还需要三次握手呢？<br>我们都知道，TCP是提供的是数据的可靠传输。为了达到这个目的，就需要考虑各种异常情况，然后避免异常情况，对于TCP连接的建立来说，三次握手可以避免<strong>已失效的连接请求报文段</strong>突然又传到了服务端，因而产生错误。</p>
<p>假设客户端向服务端发送了请求连接的报文，但是报文丢失了，从而也没收到服务端返回的确认报文。于是客户端再次发送一个请求连接报文，而这次的报文顺利到达了服务端，服务端返回了确认报文。但是如果第一次的报文由于网络原因又到达了服务端，而这个报文已经被认为是失效的了，但是服务端是无法确定的，所以服务端还是会返回给客户端确认报文，同意建立连接，如果不采用三次握手，那么刚才的情况就会建立两个连接，而实际上只需要一个连接，这样就会造成资源浪费。<br>三次握手就解决了上面的这个问题，因为服务端还需要客户端的第二次确认，而对于上面的这种情况，客户端是知道第一个报文是废弃的，所以它就不会发送给服务端确认报文，所以就不会建立第二个连接。</p>
<p>关于三次握手我们可以想象到生活中的好多场景，比如施工的时候，需要一起协作，可能两个人会有如下对话：<br>A:准备好了吗？<br>B:准备好了<br>A:走起！<br>然后AB两人就一起做点什么事情。</p>
<h3 id="TCP_u4E09_u6B21_u63E1_u624B_u7684_u8FC7_u7A0B_u4E2D_u53EF_u4EE5_u643A_u5E26_u6570_u636E_u5417_uFF1F"><a href="#TCP_u4E09_u6B21_u63E1_u624B_u7684_u8FC7_u7A0B_u4E2D_u53EF_u4EE5_u643A_u5E26_u6570_u636E_u5417_uFF1F" class="headerlink" title="TCP三次握手的过程中可以携带数据吗？"></a>TCP三次握手的过程中可以携带数据吗？</h3><p>第一次握手和第二次握手都不能携带数据，但是都需要消耗掉一个序号。<br>第三次握手的ACK报文可以携带数据，但是如果不携带数据则不消耗序号。<br>详细了解可以参考这里：<a href="http://www.tuicool.com/articles/VJjE7bU" target="_blank" rel="external">点击</a></p>
<h2 id="TCP_u8FDE_u63A5_u65AD_u5F00_u65F6_u7684_u56DB_u6B21_u63E1_u624B"><a href="#TCP_u8FDE_u63A5_u65AD_u5F00_u65F6_u7684_u56DB_u6B21_u63E1_u624B" class="headerlink" title="TCP连接断开时的四次握手"></a>TCP连接断开时的四次握手</h2><h3 id="u56DB_u6B21_u63E1_u624B"><a href="#u56DB_u6B21_u63E1_u624B" class="headerlink" title="四次握手"></a>四次握手</h3><p>TCP连接在断开的时候也很复杂，需要四次握手：   </p>
<ol>
<li>主动发起断开请求的一方向被动方发送FIN报文</li>
<li>被动方收到报文后向主动方先发送一个ACK报文</li>
<li>被动方向主动方发送FIN报文，然后等待主动方的确认，收到主动方确认报文后断开连接。</li>
<li>主动方向被动方发送ACK报文后等待两个MSL时间后断开连接。</li>
</ol>
<p>需要注意的是:这里的描述是“主动方”和“被动方”，而不是“客户端”和”服务端”，因为发起连接关闭请求的，可以是客户端，也可以是服务端。</p>
<p>图示：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/four-way-handshake.png" alt="TCP断开时的四次握手"></p>
<p>这个过程可以想象成两个同事中午一起去吃饭，相约楼梯口见。<br>A:吃饭去?<br>B:等一下（B可能有一些事情要继续处理一下）<br>…<br>B:走！（处理完了，B告诉A可以走了）<br>A:走！（A再发一个确认）<br>A发送完最后一条消息之后，等待一会儿（2MSL)，如果B没有任何回应了，可能B已经在路上了，所以自己也就出发去电梯口了。</p>
<h3 id="u4E3A_u4EC0_u4E48_u4E3B_u52A8_u5173_u95ED_u7684_u4E00_u65B9_u6700_u540E_u8981_u7B49_u5F852MSL_u7684_u65F6_u95F4_uFF1F"><a href="#u4E3A_u4EC0_u4E48_u4E3B_u52A8_u5173_u95ED_u7684_u4E00_u65B9_u6700_u540E_u8981_u7B49_u5F852MSL_u7684_u65F6_u95F4_uFF1F" class="headerlink" title="为什么主动关闭的一方最后要等待2MSL的时间？"></a>为什么主动关闭的一方最后要等待2MSL的时间？</h3><ol>
<li>为了保证最后发送的确认报文能够到达被动方，从而可靠地实现TCP全双工连接的终止。因为这个报文有可能会丢失，如果丢失了，被动方就要重传FIN这个报文，并且主动方要能够收到重传的这个报文，而如果重传，就需要等待2MSL的时间（ACK的时间+重传的时间），所以，如果主动方不到2MSL就关闭了，那么就可能收不到被动方重传的报文，就会导致被动方无法正常关闭。</li>
<li>为了防止”已失效的连接请求报文段”出现在本连接中（允许老的重复报文在网络中消失）。主动方发完最后一个ACK报文之后，等待2MSL，就可以使本连接持续时间内所产生的所有报文都在网络中消失，这样就可以在下一次连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h2 id="TCP_u8FDE_u63A5_u671F_u95F4_u5BA2_u6237_u7AEF_u670D_u52A1_u7AEF_u72B6_u6001"><a href="#TCP_u8FDE_u63A5_u671F_u95F4_u5BA2_u6237_u7AEF_u670D_u52A1_u7AEF_u72B6_u6001" class="headerlink" title="TCP连接期间客户端服务端状态"></a>TCP连接期间客户端服务端状态</h2><h3 id="u72B6_u6001_u56FE"><a href="#u72B6_u6001_u56FE" class="headerlink" title="状态图"></a>状态图</h3><p>下面的图很好的解释了在连接建立时，建立后，连接释放时服务端和客户端的状态。<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/tcp-state.gif" alt="TCP状态图"><br>下面的图也很好<br><img src="https://upload.wikimedia.org/wikipedia/commons/a/a2/Tcp_state_diagram_fixed.svg" alt="状态图"></p>
<h3 id="TIME_WAIT_u72B6_u6001"><a href="#TIME_WAIT_u72B6_u6001" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p>TIME_WAIT状态之所以会存在，就是因为上面讲的：1）可靠地关闭TCP连接2）等待老的重复报文消失。<br>在TCP连接关闭的时候，主动关闭的一方会进入时间长达2MSL的TIME_WAIT状态，而这个状态下，连接并没有关闭。所以，如果服务器上TIME_WAIT状态的连接过多的话，可能会造成新的连接建立不了，从而影响服务器响应，可以参考这里：<a href="http://huoding.com/2013/12/31/316" target="_blank" rel="external">http://huoding.com/2013/12/31/316</a></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>《Unix网络编程 卷1：套接字联网API》</li>
<li>《计算机网络（第五版）》</li>
<li><a href="http://blog.csdn.net/wenqian1991/article/details/40110703（推荐）" target="_blank" rel="external">http://blog.csdn.net/wenqian1991/article/details/40110703（推荐）</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[TCP连接建立时的三次握手以及连接断开时的四次握手，以及过程中客户端与服务端各自的状态。]]>
    
    </summary>
    
      <category term="TCP" scheme="http://blog.onlycatch.com/tags/TCP/"/>
    
      <category term="基础" scheme="http://blog.onlycatch.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="网络" scheme="http://blog.onlycatch.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[流量劫持]]></title>
    <link href="http://blog.onlycatch.com/traffic-hijack/"/>
    <id>http://blog.onlycatch.com/traffic-hijack/</id>
    <published>2016-01-16T15:23:33.000Z</published>
    <updated>2016-01-19T09:32:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6D41_u91CF_u52AB_u6301"><a href="#u6D41_u91CF_u52AB_u6301" class="headerlink" title="流量劫持"></a>流量劫持</h2><h3 id="u4EC0_u4E48_u662F_u6D41_u91CF_u52AB_u6301_uFF1F"><a href="#u4EC0_u4E48_u662F_u6D41_u91CF_u52AB_u6301_uFF1F" class="headerlink" title="什么是流量劫持？"></a>什么是流量劫持？</h3><p>流量劫持，就是通过某种手段得到我们上网的时候传输的数据，然后对这些数据进行篡改或者窥探，以达到劫持者的目的。在我们生活中最常见的应该就属运营商流量劫持了，比如我们流量一个网页的时候，如果我们输错了网址，可能就会跳到一个运营商的提示页面，提示网址错误，同时这个页面里会有运营商的一些广告等信息。<br>由于网络分为很多层，典型的OSI模型，网络分为七层：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。每一层都有发生流量劫持的可能。下面是常见的一些流量劫持：</p>
<ul>
<li>Hub 嗅探</li>
<li>MAC 欺骗</li>
<li>MAC 冲刷</li>
<li>ARP 攻击</li>
<li>DHCP 钓鱼</li>
<li>DNS 劫持</li>
<li>CDN 入侵</li>
<li>路由器 弱口令</li>
<li>路由器 CSRF</li>
<li>PPPoE 钓鱼</li>
<li>蜜罐代理</li>
<li>WiFi 弱口令</li>
<li>WiFi 伪热点</li>
<li>WiFi 强制断线</li>
<li>WLAN 基站钓鱼</li>
</ul>
<p>根据手段的不同，基本可以分为两类：</p>
<ol>
<li>DNS劫持：通过将通过劫持掉域名的DNS解析结果，将HTTP请求劫持到特定IP上，使得客户端和攻击者的服务器建立TCP连接，而非和目标服务器直接连接，这样攻击者就可以对内容进行窃取或篡改。在极端的情况下甚至攻击者可能伪造目标网站页面进行钓鱼攻击。</li>
<li>直接流量修改：在数据通路上对页面进行固定的内容插入，比如广告弹窗等。在这种情况下，虽然客户端和服务器是直接建立的连接，但是数据内容依然可能遭到野蛮破坏。</li>
</ol>
<h2 id="u6D41_u91CF_u52AB_u6301_u7684_u5371_u5BB3"><a href="#u6D41_u91CF_u52AB_u6301_u7684_u5371_u5BB3" class="headerlink" title="流量劫持的危害"></a>流量劫持的危害</h2><p>不同网络层次上发生的劫持造成的危害可能不太一样，但是都会造成用户信息泄露，隐私被窥探。<br>不同的劫持方式，获得的流量也有所差异。DNS劫持，只能截获通过域名发起的流量，直接使用 IP 地址的通信则不受影响；CDN入侵，只有浏览网页或下载时才有风险，其他场合则毫无问题；而网关被劫持，用户所有流量都难逃魔掌。<br>但流量劫持也有有用的一面，比如我们现在经常用的CDN，就可以算作一种流量劫持，它通过DNS解析，把域名解析到距离用户近的服务器上，减少了资源文件的响应时间。</p>
<h2 id="u5404_u79CD_u6D41_u91CF_u52AB_u6301_u7684_u539F_u7406"><a href="#u5404_u79CD_u6D41_u91CF_u52AB_u6301_u7684_u539F_u7406" class="headerlink" title="各种流量劫持的原理"></a>各种流量劫持的原理</h2><h3 id="Hub_u55C5_u63A2"><a href="#Hub_u55C5_u63A2" class="headerlink" title="Hub嗅探"></a>Hub嗅探</h3><p>Hub的工作原理是通过广播将一个接口收到的数据包群发到所有的接口上，这样任意接口都能获取到所有数据，用户隐私也就无从谈起。<br>这种设备目前唯一可用之处就是旁路嗅探。利用广播的特性，可以非常方便分析其他设备的通信，例如抓取机顶盒的数据包而不影响正常通信。</p>
<h3 id="MAC_u6B3A_u9A97_uFF08_u4EA4_u6362_u673A_uFF09"><a href="#MAC_u6B3A_u9A97_uFF08_u4EA4_u6362_u673A_uFF09" class="headerlink" title="MAC欺骗（交换机）"></a>MAC欺骗（交换机）</h3><p>交换机的工作原理与Hub不同，交换机可以绑定MAC地址和接口，数据包只发送到一个终端。但是如果没有事先配置好MAC地址和接口，而是采用自动学习的方式，即根据某个接口发出的包，自动关联该包的源地址到此接口。那么就可以被黑客通过伪造某个用户的MAC地址，而导致交换机将该用户的所有数据都发到黑客机器上。同时，被劫持的用户将无法上网。</p>
<h3 id="MAC_u51B2_u5237_uFF08_u4EA4_u6362_u673A_uFF09"><a href="#MAC_u51B2_u5237_uFF08_u4EA4_u6362_u673A_uFF09" class="headerlink" title="MAC冲刷（交换机）"></a>MAC冲刷（交换机）</h3><p>如果交换机发现了一个之前没有遇到过的MAC地址，那么就会将数据包广播到所有的接口。由于交换机的硬件配置有限，显然不可能无限多的记录地址对应条目。我们不停伪造不重复的源地址，交换机里的记录表很快就会填满，甚至覆盖原有的学习记录，用户的数据包无法正常转发，只能广播到所有接口上了。</p>
<h3 id="ARP_u653B_u51FB"><a href="#ARP_u653B_u51FB" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><p>ARP：地址解析协议，即根据IP地址，解析出对应的MAC地址。主机A为了获取主机B的对应的MAC地址，需要广播ARP数据包，包中包含了主机B的IP地址，ARP数据包会被同一链路上的所有主机和路由器接收，主机B收到数据包之后发现自己的IP地址与ARP数据包中的IP地址一致，就将自己的MAC地址响应给主机A。<br>ARP攻击就是通过冒充主机B，将自己的MAC地址抢在主机B之前发送给主机A，这样，发送到主机B的IP地址的数据就会被错误的发送给冒充方。</p>
<h3 id="DHCP_u9493_u9C7C"><a href="#DHCP_u9493_u9C7C" class="headerlink" title="DHCP钓鱼"></a>DHCP钓鱼</h3><p>DHCP（Dynamic Host Configuration Protocol):动态主机配置协议。作用是为主机动态分配IP地址。DHCP的工作机制简单来说就是需要分配IP地址的主机向DHCP服务器广播发送报文（目的地址是255.255.255.255，由于自己还没有IP地址，所以将源地址设置为0.0.0.0），在本网络上的所有主机都能收到这个广播的数据包，但是只有DHCP服务器才对此广播报文进行回答，然后该机器分配一个IP地址。如果存在多个DHCP服务器，则分别予以回复；用户则选择最先收到的。<br>DHCP钓鱼就是利用这个机制，如果一个黑客自己也启动了DHCP服务器，那么就可以收到客户主机的DHCP请求报文，如果黑客在真正的DHCP服务器返回数据之前返回一个IP地址，那么客户主机的所有数据就可以被黑客控制。</p>
<h3 id="DNS_u52AB_u6301"><a href="#DNS_u52AB_u6301" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>DNS的作用就是将域名转换成IP地址。DNS劫持就是将某个域名解析到黑客指定的IP地址，而如果黑客在此IP地址所在机器上设置了HTTP代理，那么用户将几乎看不出任何破绽，但是黑客就可以获取所有数据流量。</p>
<h3 id="CDN_u5165_u4FB5"><a href="#CDN_u5165_u4FB5" class="headerlink" title="CDN入侵"></a>CDN入侵</h3><p>CDN主要用来缓存网站的静态数据文件，以提高网站加载速度，分担网站压力。如果CDN服务器被入侵，那么落到CDN服务器上的请求响应内容就可以被篡改。有些CDN厂商不太靠谱，为了省流量不按套路出牌，超过了缓存时间也不更新，甚至还有忽略URL问号后面的参数，导致程序猿们在资源更新的问题上头疼不已。</p>
<h2 id="HTTPS_u4E0E_u6D41_u91CF_u52AB_u6301"><a href="#HTTPS_u4E0E_u6D41_u91CF_u52AB_u6301" class="headerlink" title="HTTPS与流量劫持"></a>HTTPS与流量劫持</h2><p>对于通过HTTP协议通讯的应用来说，发生流量劫持的根本原因是<strong>HTTP协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验</strong>。没有办法校验通信对方的身份，所以DNS劫持就大行其道。而无法对数据完整性进行校验旧导致了直接数据内容的篡改。而HTTPS却能解决这两个问题。<br>因为HTTPS的证书认证能够解决无法对通信对方的身份认证的问题，而内容加密传输则达到了对数据完整性校验的目的。</p>
<h3 id="HTTPS_u539F_u7406_u7B80_u4ECB"><a href="#HTTPS_u539F_u7406_u7B80_u4ECB" class="headerlink" title="HTTPS原理简介"></a>HTTPS原理简介</h3><p>HTTPS是在HTTP与TCP层之间增加了安全层，安全层是通过SSL以及其现代替代协议TLS来实现的。<br>HTTPS在请求开始之前客户端和服务器端有一个握手机制，握手的主要作用有两个：</p>
<ol>
<li>服务端认证：客户端通过判断服务端的证书是否合法有效，以决定是否信任该服务端。</li>
<li>协商秘钥：客户端服务端协商确定一个秘钥，用于数据传输过程中对数据进行加密。<br>握手过程的解释图：<br><img src="http://www.fenesky.com/images/TLS.svg" alt="tls握手图"></li>
</ol>
<p>关于HTTPS握手，可以参考下面两篇文章</p>
<ol>
<li><a href="http://www.fenesky.com/blog/2014/07/19/how-https-works.html" target="_blank" rel="external">http://www.fenesky.com/blog/2014/07/19/how-https-works.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>流量劫持可能发生在网络通讯中的多个层次。</li>
<li>流量劫持大致可以分为DNS劫持和直接内容修改两种，虽然实施的手段不同，但本质都是一样的。</li>
<li>之所以能够发生流量劫持，原因有两个：1）无法对通信双方身份做认证2）无法对数据的完整性进行校验。HTTPS能解决这个问题，但仅限于HTTP协议应用。</li>
</ol>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://yq.aliyun.com/articles/2666" target="_blank" rel="external">http://yq.aliyun.com/articles/2666</a> （非常推荐）</li>
<li><a href="http://div.io/topic/907" target="_blank" rel="external">http://div.io/topic/907</a></li>
<li><a href="http://www.huxiu.com/article/135293/1.html" target="_blank" rel="external">http://www.huxiu.com/article/135293/1.html</a></li>
<li><a href="https://www.wosign.cn/News/Https_SSLStrip.htm" target="_blank" rel="external">https://www.wosign.cn/News/Https_SSLStrip.htm</a></li>
<li><a href="http://fex.baidu.com/blog/2014/04/traffic-hijack/(非常推荐" target="_blank" rel="external">http://fex.baidu.com/blog/2014/04/traffic-hijack/(非常推荐</a>)</li>
<li><a href="http://fex.baidu.com/blog/2014/04/traffic-hijack-2/(非常推荐" target="_blank" rel="external">http://fex.baidu.com/blog/2014/04/traffic-hijack-2/(非常推荐</a>)</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[流量劫持入门知识]]>
    
    </summary>
    
      <category term="http" scheme="http://blog.onlycatch.com/tags/http/"/>
    
      <category term="https" scheme="http://blog.onlycatch.com/tags/https/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Linux]xargs命令]]></title>
    <link href="http://blog.onlycatch.com/xargs-in-linux/"/>
    <id>http://blog.onlycatch.com/xargs-in-linux/</id>
    <published>2016-01-14T14:45:19.000Z</published>
    <updated>2016-01-17T14:29:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="xargs_u547D_u4EE4_u7684_u4F5C_u7528"><a href="#xargs_u547D_u4EE4_u7684_u4F5C_u7528" class="headerlink" title="xargs命令的作用"></a>xargs命令的作用</h2><p>像很多人一样，我一开始的时候也迫切想知道这个命令的作用，但是到目前为止，我的确是没有用过这个命令。但是我发现别人在用这个命令，于是我便想知道这个命令的作用，于是我使用了<code>man xargs</code>。<br>它给我的解释是：<code>xargs - build and execute command lines from standard input</code>，就是从构建并且执行来自标准输入中的命令行。<br>看不懂？没错，我相信每个人刚接触这个命令的说明的收都看不懂。而且的确，这个命令也很让人迷惑。我们还是先从例子开始看吧。</p>
<h2 id="xargs_u4F7F_u7528_u4E3E_u4F8B"><a href="#xargs_u4F7F_u7528_u4E3E_u4F8B" class="headerlink" title="xargs使用举例"></a>xargs使用举例</h2><h3 id="u8BFB_u53D6_u8F93_u5165_u6570_u636E_uFF0C_u91CD_u65B0_u683C_u5F0F_u5316_u540E_u8F93_u51FA"><a href="#u8BFB_u53D6_u8F93_u5165_u6570_u636E_uFF0C_u91CD_u65B0_u683C_u5F0F_u5316_u540E_u8F93_u51FA" class="headerlink" title="读取输入数据，重新格式化后输出"></a>读取输入数据，重新格式化后输出</h3><p>假设我们有一个文本文件，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt</span><br><span class="line">a b c d e f g h</span><br><span class="line">i j k l m n o p q</span><br><span class="line">r s t u v w x y z</span><br></pre></td></tr></table></figure></p>
<p>data.txt中的文件是换行显示的。</p>
<ul>
<li><p>多行输入变成单行输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt |xargs</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>
</li>
<li><p>-n 控制多行输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat data.txt |xargs -n4</span><br><span class="line">a b c d</span><br><span class="line">e f g h</span><br><span class="line">i j k l</span><br><span class="line">m n o p</span><br><span class="line">q r s t</span><br><span class="line">u v w x</span><br><span class="line">y z</span><br></pre></td></tr></table></figure>
</li>
<li><p>-d 指定分隔符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'testAtestAtestAtest'</span>|xargs <span class="operator">-d</span>A</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">test</span> <span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># -d 与-n 一起使用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'testAtestAtestAtest'</span>|xargs <span class="operator">-d</span>A -n2</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="u8BFB_u53D6stdin_2C_u5C06_u683C_u5F0F_u5316_u540E_u7684_u53C2_u6570_u4F20_u9012_u7ED9_u67D0_u4E9B_u547D_u4EE4"><a href="#u8BFB_u53D6stdin_2C_u5C06_u683C_u5F0F_u5316_u540E_u7684_u53C2_u6570_u4F20_u9012_u7ED9_u67D0_u4E9B_u547D_u4EE4" class="headerlink" title="读取stdin,将格式化后的参数传递给某些命令"></a>读取stdin,将格式化后的参数传递给某些命令</h3><ol>
<li><p>当你尝试用rm 删除太多的文件，你可能得到一个错误信息：/bin/rm Argument list too long. 用xargs 去避免这个问题<br><code>find ~ -name ‘*.log’ -print0 | xargs -0 rm -f</code></p>
</li>
<li><p>获得/etc/ 下所有<em>.conf 结尾的文件列表，有几种不同的方法能得到相同的结果，下面的例子仅仅是示范怎么实用xargs ，在这个例子中实用 xargs将find 命令的输出传递给ls -l<br>`find /etc -name “</em>.conf” | xargs ls –l`</p>
</li>
<li><p>假如你有一个文件包含了很多你希望下载的URL, 你能够使用xargs 下载所有链接<br><code>cat url-list.txt | xargs wget –c</code></p>
</li>
<li><p>查找所有的jpg 文件，并且压缩它<br><code>find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz</code></p>
</li>
<li><p>拷贝所有的图片文件到一个外部的硬盘驱动<br><code>ls *.jpg | xargs -n1 -i cp {} /external-hard-drive/directory</code></p>
</li>
</ol>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>In general xargs is used like this<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog | xargs utility</span><br></pre></td></tr></table></figure></p>
<p>where prog is expected to output one or more newline/space separated results. The trick is that xargs does not! nessarly call utility once for each result, instead it splits the result list into sublists and calls utility for every sublist. If you want to force xargs to call utility for every single result you will need to invoke it with xargs -L1.</p>
<p>Note that xargs promises you that the sublist sent to utility is shorter than <em>ARG_MAX</em> (this is how it avoids those dreaded Argument list to long errors). You can get the current value of <em>ARG_MAX</em> using getconf ARG_MAX</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://man.linuxde.net/xargs" target="_blank" rel="external">http://man.linuxde.net/xargs</a></li>
<li><a href="http://unix.stackexchange.com/questions/24954/when-is-xargs-needed" target="_blank" rel="external">http://unix.stackexchange.com/questions/24954/when-is-xargs-needed</a></li>
<li><a href="https://en.wikipedia.org/wiki/Xargs" target="_blank" rel="external">https://en.wikipedia.org/wiki/Xargs</a></li>
<li><a href="http://stackoverflow.com/questions/1898044/understanding-the-unix-command-xargs" target="_blank" rel="external">http://stackoverflow.com/questions/1898044/understanding-the-unix-command-xargs</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[linux中，xargs命令的应用]]>
    
    </summary>
    
      <category term="Linux" scheme="http://blog.onlycatch.com/tags/Linux/"/>
    
      <category term="Linux命令" scheme="http://blog.onlycatch.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTTP响应码301和302的区别]]></title>
    <link href="http://blog.onlycatch.com/differences-between-301-302/"/>
    <id>http://blog.onlycatch.com/differences-between-301-302/</id>
    <published>2016-01-14T14:16:50.000Z</published>
    <updated>2016-01-14T14:24:59.000Z</updated>
    <content type="html"><![CDATA[<p>301：永久重定向<br>302：临时重定向<br>302重定向与网址劫持:即A网站将自己302重定向到B网站，某些搜索引擎会收录A网站的网址，而显示的却是B网站的内容。   </p>
<p>以下内容转自：<a href="http://www.jameswxx.com/web/301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="external">http://www.jameswxx.com/web/301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB/</a><br>原文写的清晰明了，保存一份。</p>
<h2 id="u4EC0_u4E48_u662F301_u8F6C_u5411_3F_u4EC0_u4E48_u662F301_u91CD_u5B9A_u5411_3F"><a href="#u4EC0_u4E48_u662F301_u8F6C_u5411_3F_u4EC0_u4E48_u662F301_u91CD_u5B9A_u5411_3F" class="headerlink" title="什么是301转向?什么是301重定向?"></a>什么是301转向?什么是301重定向?</h2><p>301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。</p>
<h2 id="u4EC0_u4E48_u662F302_u91CD_u5B9A_u5411_3F"><a href="#u4EC0_u4E48_u662F302_u91CD_u5B9A_u5411_3F" class="headerlink" title="什么是302重定向?"></a>什么是302重定向?</h2><p>302重定向又称之为302代表暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向(temporary redirect)，一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。</p>
<h2 id="301_u91CD_u5B9A_u5411_u4E0E302_u91CD_u5B9A_u5411_u7684_u533A_u522B"><a href="#301_u91CD_u5B9A_u5411_u4E0E302_u91CD_u5B9A_u5411_u7684_u533A_u522B" class="headerlink" title="301重定向与302重定向的区别"></a>301重定向与302重定向的区别</h2><p>302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>
<h2 id="u4E3A_u4EC0_u4E48302__u91CD_u5B9A_u5411_u548C_u7F51_u5740_u52AB_u6301_u6709_u5173_u8054"><a href="#u4E3A_u4EC0_u4E48302__u91CD_u5B9A_u5411_u548C_u7F51_u5740_u52AB_u6301_u6709_u5173_u8054" class="headerlink" title="为什么302 重定向和网址劫持有关联"></a>为什么302 重定向和网址劫持有关联</h2><p>从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。</p>
<p>比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL 劫持的可能性。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p>
<p>302 重定向所造成的网址URL劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的数据中心转换中，302 重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[HTTP响应状态码301和302的区别]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://blog.onlycatch.com/tags/HTTP/"/>
    
      <category term="网络" scheme="http://blog.onlycatch.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[队列与栈的互相实现]]></title>
    <link href="http://blog.onlycatch.com/queue-and-stack-implements/"/>
    <id>http://blog.onlycatch.com/queue-and-stack-implements/</id>
    <published>2016-01-14T14:00:32.000Z</published>
    <updated>2016-01-14T14:14:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5982_u4F55_u4F7F_u7528LIFO_u7684_u6808_u5B9E_u73B0_u961F_u5217FIFO_u7684_u529F_u80FD_uFF1F"><a href="#u5982_u4F55_u4F7F_u7528LIFO_u7684_u6808_u5B9E_u73B0_u961F_u5217FIFO_u7684_u529F_u80FD_uFF1F" class="headerlink" title="如何使用LIFO的栈实现队列FIFO的功能？"></a>如何使用LIFO的栈实现队列FIFO的功能？</h2><p>思路：将一个栈中的所有元素依次取出并放入另外一个栈，那么第二个栈中的元素出栈顺序就与第一个栈中元素的入栈顺序一致。<br>其实可以将栈想象成一个木桶，栈中的元素想象成大饼，如果我们将一个桶中的饼倒入另一个桶中，那么第二个桶中最上面的饼就是第一个桶中最下面的那张。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueByStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Stack&lt;String&gt; putStack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;String&gt; popStack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">		putStack.push(data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!putStack.isEmpty()) &#123;</span><br><span class="line">			popStack.push(putStack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> popStack.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5982_u4F55_u4F7F_u7528FIFO_u7684_u961F_u5217_u5B9E_u73B0LIFO_u7684_u529F_u80FD_uFF1F"><a href="#u5982_u4F55_u4F7F_u7528FIFO_u7684_u961F_u5217_u5B9E_u73B0LIFO_u7684_u529F_u80FD_uFF1F" class="headerlink" title="如何使用FIFO的队列实现LIFO的功能？"></a>如何使用FIFO的队列实现LIFO的功能？</h2><p>思路：每次存入元素的时候，都要想办法保证最后加入的元素是放在队列头部的，这样才能保证取的时候是按照LIFO的顺序。<br>可以借助汉诺塔问题思考一下。</p>
<p>下面是我写的第一个版本的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackByQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; tmpQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">			String poll = queue.poll();</span><br><span class="line">			tmpQueue.add(poll);</span><br><span class="line">		&#125;</span><br><span class="line">		queue.add(data);</span><br><span class="line">		<span class="keyword">while</span> (!tmpQueue.isEmpty()) &#123;</span><br><span class="line">			queue.add(tmpQueue.poll());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> queue.poll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后来发现效率不高，于是有了下面的升级版本(空间换时间)：<br>思路：以空间换时间，增加了一个变量，用于标记当前正在使用的队列。好处是减少了每次数据元素的拷贝。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackByQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> Queue&lt;String&gt; tmpQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> queueInUse = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (queueInUse) &#123;</span><br><span class="line">			tmpQueue.add(data);</span><br><span class="line">			switchQueue(tmpQueue, queue);</span><br><span class="line">			queueInUse = <span class="keyword">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			queue.add(data);</span><br><span class="line">			switchQueue(queue, tmpQueue);</span><br><span class="line">			queueInUse = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">switchQueue</span><span class="params">(Queue&lt;String&gt; dest, Queue&lt;String&gt; source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!source.isEmpty()) &#123;</span><br><span class="line">			dest.add(source.poll());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (queueInUse) &#123;</span><br><span class="line">			<span class="keyword">return</span> queue.poll();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> tmpQueue.poll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[如何使用FIFO队列实现LIFO的栈功能？又如何使用LIFO的栈实现FIFO功能呢？]]>
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.onlycatch.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="面试" scheme="http://blog.onlycatch.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQL中= null与is null的区别]]></title>
    <link href="http://blog.onlycatch.com/how-is-null-differs-from-equals-null-in-sql/"/>
    <id>http://blog.onlycatch.com/how-is-null-differs-from-equals-null-in-sql/</id>
    <published>2016-01-13T14:32:24.000Z</published>
    <updated>2016-01-14T14:36:43.000Z</updated>
    <content type="html"><![CDATA[<p>类似下面的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">field</span> = <span class="literal">null</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">field</span> <span class="keyword">IS</span> <span class="literal">null</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>第一行SQL将不会返回任何内容，而第二行将会返回field字段为NULL的行。</p>
<p>原因如下：</p>
<blockquote>
<p>在SQL中，null值与另外一个值（包括null值）的逻辑比较（=，！=，&lt;&gt;等），返回的结果也是null，而这个null值在where子句中是被当做false来看待的。null表示”未知“，所以比较的结果也是”未知“。   </p>
</blockquote>
<p>所以，上面的第一条SQL就不会返回任何内容。</p>
<p>如果在SQL中，需要判断某个字段是否为NULL，需要用IS NULL或者 IS NOT NULL,而不能使用=null或者！=null或者&lt;&gt;null。</p>
<p>参考资料：<br><a href="http://jackyrong.iteye.com/blog/2076933" target="_blank" rel="external">http://jackyrong.iteye.com/blog/2076933</a><br><a href="http://stackoverflow.com/questions/9581745/sql-is-null-and-null" target="_blank" rel="external">http://stackoverflow.com/questions/9581745/sql-is-null-and-null</a><br><a href="http://www.w3schools.com/sql/sql_null_values.asp" target="_blank" rel="external">http://www.w3schools.com/sql/sql_null_values.asp</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Why in SQL SELECT * FROM table WHERE field = null does not match records with null field?]]>
    
    </summary>
    
      <category term="MySQl" scheme="http://blog.onlycatch.com/tags/MySQl/"/>
    
      <category term="SQL" scheme="http://blog.onlycatch.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java线程间通信]]></title>
    <link href="http://blog.onlycatch.com/java-thread-communication/"/>
    <id>http://blog.onlycatch.com/java-thread-communication/</id>
    <published>2016-01-10T07:16:25.000Z</published>
    <updated>2016-01-23T15:17:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5171_u4EAB_u5185_u5B58"><a href="#u5171_u4EAB_u5185_u5B58" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存在java多线程中的应用是很频繁的，最简单的例子就是共享变量，即多个线程都读或者写一个变量的值。</p>
<h3 id="volatile_u548Csynchronized_u5173_u952E_u5B57"><a href="#volatile_u548Csynchronized_u5173_u952E_u5B57" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h3><p>volatile关键字：保证了内存可见性，能够保证多个线程在读取volatile修饰的变量时，读取到的数据都是最新的。<br>volatile的写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主存。<br>volatile的读：当读一个volatile变量时，JMM会把线程对应的本地内存置为无效，然后从主存中读取共享变量。</p>
]]></content>
    <summary type="html">
    <![CDATA[曾经面试的时候被问过这样一个问题，当时我的答案是：共享内存，信号量，消息队列。如今已经距离那次面试过去半年多了，我也成长了很多，现在让我再回过头来看看这个问题。]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.onlycatch.com/tags/java/"/>
    
      <category term="多线程" scheme="http://blog.onlycatch.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java中线程的状态以及线程栈分析]]></title>
    <link href="http://blog.onlycatch.com/thread-state-and-analysis/"/>
    <id>http://blog.onlycatch.com/thread-state-and-analysis/</id>
    <published>2016-01-10T04:18:38.000Z</published>
    <updated>2016-01-10T15:06:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="java_u4E2D_u7EBF_u7A0B_u7684_u72B6_u6001"><a href="#java_u4E2D_u7EBF_u7A0B_u7684_u72B6_u6001" class="headerlink" title="java中线程的状态"></a>java中线程的状态</h2><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态。线程刚刚被创建，并且start()方法还未被调用</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态。表示线程正在java虚拟机中执行，但是可能正在等待操作系统的其他资源，比如CPU</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态。表示线程正在等待监视器锁。表示线程正在等待获取监视器锁，以便进入同步方法或者同步代码快，也有可能是从wait（）方法被唤醒而等待再次进入同步方法或者同步代码块</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态。表示当前线程需要等待其他线程执行一些特殊操作，比如当前线程调用了a.wait()方法，它正在等待其他线程调用a.notify或a.notifyAll方法;如果当前线程调用了threada.join(),那么它在等待threada执行完成</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>超时等待。与WAITING的不同在于，该状态有超时时间</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
<p>详细介绍：参考Thread内部类:State</p>
<p>WAITING与TIMED_WAITING:<br>调用以下三个方法会进入WAITING状态：</p>
<ul>
<li>Object.wait() 不设置超时时间</li>
<li>Thread.join() 不设置超时时间</li>
<li>LockSupport.park() 不设置超时时间<br>调用下面的方法会进入TIMED_WAITING状态：</li>
<li>Object.wait(time)</li>
<li>Thread.join(time)</li>
<li>Thread.sleep(time)</li>
<li>LockSupport.parkNanos(time)</li>
<li>LockSupport.parkUntil(time)</li>
</ul>
<h2 id="u901A_u8FC7jstack_u67E5_u770B_u7EBF_u7A0B_u72B6_u6001"><a href="#u901A_u8FC7jstack_u67E5_u770B_u7EBF_u7A0B_u72B6_u6001" class="headerlink" title="通过jstack查看线程状态"></a>通过jstack查看线程状态</h2><p>jstack 是一个可以用来打印java进程中的线程堆栈信息的工具。一般都位于jdk安装目录的bin目录下。<br>一般，jstack都用来检测死锁，以及分析当前程序运行状态。</p>
<h3 id="u4F7F_u7528_u65B9_u5F0F"><a href="#u4F7F_u7528_u65B9_u5F0F" class="headerlink" title="使用方式"></a>使用方式</h3><p>jstack [options] pid<br>pid:即进程id，可以通过jps命令查看<br>options:可选选项。一般常用的是-l和-m，-l用于打印详细的堆栈信息，包括当前线程获得到的同步器(AbstractOwnableSynchronizer)。-m则会打印包含C++或C的堆栈信息。</p>
<p>例如：<br>命令：<code>jstack 10968</code> 则会把进程号为10968的进程所包含的线程信息打印出来。<br>其中的部分结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fab88009800 nid=0x2add waiting on condition [0x00007fab8ee92000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">	at test.DeadLockTest.main(DeadLockTest.java:17)</span><br></pre></td></tr></table></figure></p>
<p>命令：<code>jstack -l 10968</code>则会包含当前线程获取到的同步器。<br>其中的部分结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fab88009800 nid=0x2add waiting on condition [0x00007fab8ee92000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)</span><br><span class="line">	at test.DeadLockTest.main(DeadLockTest.java:17)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure></p>
<p>可以看到，带-l参数的，在线程信息后面有个’ Locked ownable synchronizers:’信息。</p>
<p>关于jstack的使用，下面两篇文章写的很不错，非常建议一看:</p>
<ol>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps" target="_blank" rel="external">java-thread-dumps</a></li>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps-2" target="_blank" rel="external">java-thread-dumps-2</a></li>
</ol>
<h3 id="u4E0D_u540C_u7EBF_u7A0B_u72B6_u6001_u5728jstack_u4FE1_u606F_u4E2D_u5F62_u5F0F"><a href="#u4E0D_u540C_u7EBF_u7A0B_u72B6_u6001_u5728jstack_u4FE1_u606F_u4E2D_u5F62_u5F0F" class="headerlink" title="不同线程状态在jstack信息中形式"></a>不同线程状态在jstack信息中形式</h3><p>我们来看一下，当线程处于不同状态的时候，通过jstack看到的是什么样子的。</p>
<h4 id="WAITING_u72B6_u6001"><a href="#WAITING_u72B6_u6001" class="headerlink" title="WAITING状态"></a>WAITING状态</h4><p>通过上面的讲解我们知道，线程进入waiting状态可以通过三种方式：1.Object.wait,2.Thread.join,3.LockSupport.park ，那么我们分别来看下，当程序分别通过这三种方式进入WAITING状态的时候，对应的jstack信息是怎样的。</p>
<p>1.Object.wait方式<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// Object.wait</span></span><br><span class="line">		<span class="keyword">synchronized</span> (WaitingTest.class) &#123;</span><br><span class="line">			WaitingTest.class.wait();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack 结果(省略其他部分，下同):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f384c009800 nid=0x2d9c in Object.wait() [0x00007f385268b000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6ddb9a0</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br><span class="line">	at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddb9a0</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br></pre></td></tr></table></figure></p>
<p>2.Thread.join方式<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// Thread.join</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"run"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span> * <span class="number">300</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前线程调用thread线程的join方法</span></span><br><span class="line">		thread.join();</span><br><span class="line">		<span class="comment">// 只有thread的run方法执行完成之后，才会执行输出</span></span><br><span class="line">		System.out.println(<span class="string">"Current thread running"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f88cc009800 nid=0x2f10 in Object.wait() [0x00007f88d5b73000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6ddddf8</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1245</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddddf8</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1319</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>3.LockSupport.park方式<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		LockSupport.park();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f6efc009800 nid=0x2f88 waiting on condition [0x00007f6f034dd000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">304</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h4 id="TIMED_WAITING"><a href="#TIMED_WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>1.Object.wait(time)<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (WaitingTest.class) &#123;</span><br><span class="line">			WaitingTest.class.wait(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007fd598009800 nid=0x301b in Object.wait() [0x00007fd59eea0000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6ddb9b8</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">9</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddb9b8</span>&gt; (a java.lang.Class <span class="keyword">for</span> test.WaitingTest)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>2.Thread.join(time)<br>代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// Thread.join</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="annotation">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"run"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span> * <span class="number">300</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前线程调用thread线程的join方法</span></span><br><span class="line">		thread.join(<span class="number">1000</span> * <span class="number">200</span>);</span><br><span class="line">		<span class="comment">// 只有thread的run方法执行完成之后，才会执行输出</span></span><br><span class="line">		System.out.println(<span class="string">"Current thread running"</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f024c009800 nid=0x365c in Object.wait() [0x00007f0254768000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000000d6dddf40</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at java.lang.Thread.join(Thread.java:<span class="number">1253</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6dddf40</span>&gt; (a test.WaitingTest$<span class="number">1</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>3.Thread.sleep<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	Thread.currentThread().sleep(<span class="number">1000</span> * <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f54a8009800 nid=0x36eb waiting on condition [0x00007f54ae463000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>4.LockSupport.parkNanos(time) 和 LockSupport.parkUntil(time) 两个方法类似<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	LockSupport.parkNanos(Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007eff98009800 nid=0x37b6 waiting on condition [0x00007effa0141000]</span></span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:<span class="number">338</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h4 id="BLOCKED_u72B6_u6001"><a href="#BLOCKED_u72B6_u6001" class="headerlink" title="BLOCKED状态"></a>BLOCKED状态</h4><p>BLOCKED状态，表示线程正在等待监视器锁。我们可以通过一个死锁的例子来分析。<br>例子很简单，程序中有两个Waiter线程，WaiterA和WaitB，它们都需要获取两个锁：lock_1和lock_2,但是它们获取锁的顺序不同，因此导致了死锁。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object lock_1 = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object lock_2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> WaiterA().start();</span><br><span class="line">		<span class="keyword">new</span> WaiterB().start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaiterA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 先获取lock_1,然后再获取lock_2</span></span><br><span class="line">			<span class="keyword">synchronized</span> (lock_1) &#123;</span><br><span class="line">				System.out.println(<span class="string">"lock1 get,wait to get lock2"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">synchronized</span> (lock_2) &#123;</span><br><span class="line">					System.out.println(<span class="string">"lock2 get"</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaiterB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 先获取lock_2,然后再获取lock_1</span></span><br><span class="line">			<span class="keyword">synchronized</span> (lock_2) &#123;</span><br><span class="line">				System.out.println(<span class="string">"lock2 get,wait to get lock1"</span>);</span><br><span class="line">				<span class="keyword">synchronized</span> (lock_1) &#123;</span><br><span class="line">					System.out.println(<span class="string">"lock1 get"</span>);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Thread-1"</span> <span class="comment">#10 prio=5 os_prio=0 tid=0x00007f0d800dc800 nid=0x39da waiting for monitor entry [0x00007f0d47bfa000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at test.WaitingTest$WaiterB.run(WaitingTest.java:<span class="number">47</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="string">"Thread-0"</span> <span class="comment">#9 prio=5 os_prio=0 tid=0x00007f0d800da800 nid=0x39d9 waiting for monitor entry [0x00007f0d47cfb000]</span></span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">	at test.WaitingTest$WaiterA.run(WaitingTest.java:<span class="number">27</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，上面Thread-1 和Thread-0的状态都是Blocked，原因是它们都在等待监视器锁，而Thread-1 已经获取到了锁0x00000000d6ddc520，正在等待获取0x00000000d6ddc510锁，而0x00000000d6ddc510锁已经被Thread-0获取到了，Thread-0反过来又正在等待获取0x00000000d6ddc520，而这个锁又被Thread-1获取了。<br>在jstack的最后，还有如下信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f0d50004ed8</span> (object <span class="number">0x00000000d6ddc510</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held by <span class="string">"Thread-0"</span></span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f0d500062c8</span> (object <span class="number">0x00000000d6ddc520</span>, a java.lang.Object),</span><br><span class="line">  which <span class="keyword">is</span> held by <span class="string">"Thread-1"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">	at test.WaitingTest$WaiterB.run(WaitingTest.java:<span class="number">47</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">	at test.WaitingTest$WaiterA.run(WaitingTest.java:<span class="number">27</span>)</span><br><span class="line">	- waiting to lock &lt;<span class="number">0x00000000d6ddc520</span>&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;<span class="number">0x00000000d6ddc510</span>&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure></p>
<p>就是说，已经发现了一个死锁，还有就是关于死锁的详细说明。</p>
<h4 id="RUNNABLE_u72B6_u6001"><a href="#RUNNABLE_u72B6_u6001" class="headerlink" title="RUNNABLE状态"></a>RUNNABLE状态</h4><p>我们写一个BIO的server端，server端绑定一个端口，并通过accept()方法等待客户端链接。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">		ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Socket socket = serverSocket.accept();</span><br><span class="line">			<span class="comment">// do something else</span></span><br><span class="line">			<span class="comment">// ....</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>jstack:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=0 tid=0x00007f4b58009800 nid=0x3ab8 runnable [0x00007f4b5ff64000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class="line">	at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:<span class="number">409</span>)</span><br><span class="line">	at java.net.ServerSocket.implAccept(ServerSocket.java:<span class="number">545</span>)</span><br><span class="line">	at java.net.ServerSocket.accept(ServerSocket.java:<span class="number">513</span>)</span><br><span class="line">	at test.WaitingTest.main(WaitingTest.java:<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，此时虽然程序在等待客户端接入，但是程序状态依然是RUNNABLE的。</p>
<h4 id="TERMINATED_u548CNEW_u72B6_u6001"><a href="#TERMINATED_u548CNEW_u72B6_u6001" class="headerlink" title="TERMINATED和NEW状态"></a>TERMINATED和NEW状态</h4><p>这两个状态分别表示线程生命终结和生命开始，在jstack中没有对应的信息显示。</p>
<h4 id="u603B_u7ED3_uFF1A"><a href="#u603B_u7ED3_uFF1A" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>WAITING和TIMED_WAITING的主要不同就在于后者在等待的时候设置了超时时间</li>
<li>通过Object.wait，Thread.join两种方式进入的WAITING或者TIMED_WAITING,通过jstack查看显示的都是wait on monitor,而通过其他方式（Thread.sleep,LockSupport等）进入的WAITING或者TIMED_WAITING,通过jstack查看显示的都是waiting on condition。</li>
<li>BLOCKED状态，通过jstack查看，显示的是waiting for monitor entry，注意与WAITING和TIMED_WAITING的区别。</li>
</ol>
<h2 id="java_u7EBF_u7A0B_u72B6_u6001_u4E4B_u95F4_u7684_u8F6C_u6362"><a href="#java_u7EBF_u7A0B_u72B6_u6001_u4E4B_u95F4_u7684_u8F6C_u6362" class="headerlink" title="java线程状态之间的转换"></a>java线程状态之间的转换</h2><p>java线程通过不同的方法调用进入不同的状态，下面图描述的很清楚：<br><img src="http://7xo4v8.com1.z0.glb.clouddn.com/state-machine-example-java-6-thread-states.png" alt="java线程状态转换UML"></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps" target="_blank" rel="external">https://sites.google.com/site/threaddumps/java-thread-dumps</a></li>
<li><a href="https://sites.google.com/site/threaddumps/java-thread-dumps-2" target="_blank" rel="external">https://sites.google.com/site/threaddumps/java-thread-dumps-2</a></li>
<li>图片来源：<a href="http://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html" target="_blank" rel="external">http://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html</a></li>
</ol>
<p>顺便推荐个很好的网站：<br>Java中的UML图：<a href="http://www.uml-diagrams.org/examples/java-uml-examples.html" target="_blank" rel="external">http://www.uml-diagrams.org/examples/java-uml-examples.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[java线程有6种不同的状态，不同的状态之间是怎样转换的？在实际程序运行过程中，我们应该如何判断线程处于什么状态呢？]]>
    
    </summary>
    
      <category term="Troubleshooting Tools" scheme="http://blog.onlycatch.com/tags/Troubleshooting-Tools/"/>
    
      <category term="java" scheme="http://blog.onlycatch.com/tags/java/"/>
    
      <category term="jstack" scheme="http://blog.onlycatch.com/tags/jstack/"/>
    
      <category term="线程" scheme="http://blog.onlycatch.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java线程池异常处理最佳实践]]></title>
    <link href="http://blog.onlycatch.com/what-if-exception-occurs-in-threadpool/"/>
    <id>http://blog.onlycatch.com/what-if-exception-occurs-in-threadpool/</id>
    <published>2016-01-07T13:37:30.000Z</published>
    <updated>2016-01-10T14:21:59.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>问题描述：<br>假设我们有一个线程池，由于程序需要，我们向该线程池中提交了好多任务，但是这些任务都没有对异常进行try catch处理，并且运行的时候都抛出了异常。这会对线程池的运行带来什么影响？</p>
</blockquote>
<p>正确答案是：没有影响。<br>想一下，如果是你开发了一个线程池供开发者使用，你会不会对这种情况做处理？想想也是肯定的，不然你提供给别人使用的东西就是有问题的，欠考虑的。而且java线程池的主要开发人员是大名鼎鼎的Doug Lea，你觉得他开发的代码怎么会允许出现这种问题？</p>
<h2 id="u95EE_u9898_u5206_u6790"><a href="#u95EE_u9898_u5206_u6790" class="headerlink" title="问题分析"></a>问题分析</h2><p>接下来我们来看一下java中的线程池是如何运行我们提交的任务的，详细流程比较复杂，这里我们不关注，我们只关注任务执行的部分。java中的线程池用的是ThreadPoolExecutor，真正执行代码的部分是runWorker方法：<code>final void runWorker(Worker w)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略无关部分</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    beforeExecute(wt, task);  </span><br><span class="line">    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run();  <span class="comment">//执行程序逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123; <span class="comment">//捕获RuntimeException</span></span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error x) &#123; <span class="comment">//捕获Error</span></span><br><span class="line">        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;   <span class="comment">//捕获Throwable</span></span><br><span class="line">        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterExecute(task, thrown);  <span class="comment">//运行完成，进行后续处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    task = <span class="keyword">null</span>;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略无关部分</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，程序会捕获包括Error在内的所有异常，并且在程序最后，将出现过的异常和当前任务传递给afterExecute方法。</p>
<p>而ThreadPoolExecutor中的afterExecute方法是没有任何实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，默认情况下，线程池会捕获任务抛出的所有异常，但是不做任何处理。</p>
<h2 id="u5B58_u5728_u95EE_u9898"><a href="#u5B58_u5728_u95EE_u9898" class="headerlink" title="存在问题"></a>存在问题</h2><p>想象下ThreadPoolExecutor这种处理方式会有什么问题？<br>这样做能够保证我们提交的任务抛出了异常不会影响其他任务的执行，同时也不会对用来执行该任务的线程产生任何影响。<br>问题就在<code>afterExecute</code>方法上，这个方法没有做任何处理，所以如果我们的任务抛出了异常，我们也无法立刻感知到。即使感知到了，也无法查看异常信息。</p>
<p>所以，作为一名好的开发者，是不应该允许这种情况出现的。</p>
<h2 id="u5982_u4F55_u907F_u514D_u8FD9_u79CD_u95EE_u9898"><a href="#u5982_u4F55_u907F_u514D_u8FD9_u79CD_u95EE_u9898" class="headerlink" title="如何避免这种问题"></a>如何避免这种问题</h2><p>思路很简单。</p>
<ol>
<li>在提交的任务中将异常捕获并处理，不抛给线程池。</li>
<li>异常抛给线程池，但是我们要及时处理抛出的异常。</li>
</ol>
<p>第一种思路很简单，就是我们提交任务的时候，将所有可能的异常都Catch住，并且自己处理，任务的大致代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//处理所有的业务逻辑</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="comment">//打印日志等</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//其他处理</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>说白了就是把业务逻辑都trycatch起来。<br>但是这种思路的缺点就是：1）所有的不同任务类型都要trycatch，增加了代码量。2）不存在checkedexception的地方也需要都trycatch起来，代码丑陋。</p>
<p>第二种思路就可以避免上面的两个问题。<br>第二种思路又有以下几种实现方式：</p>
<ol>
<li>自定义线程池，继承ThreadPoolExecutor并复写其<code>afterExecute(Runnable r, Throwable t)</code>方法。</li>
<li>实现Thread.UncaughtExceptionHandler接口，实现<code>void uncaughtException(Thread t, Throwable e);</code>方法，并将该handler传递给线程池的ThreadFactory</li>
<li>采用Future模式，将返回结果以及异常放到Future中，在Future中处理</li>
<li>继承ThreadGroup，覆盖其uncaughtException方法。（与第二种方式类似，因为ThreadGroup类本身就实现了Thread.UncaughtExceptionHandler接口)</li>
</ol>
<p>下面是以上几种方式的代码</p>
<h3 id="u65B9_u5F0F1"><a href="#u65B9_u5F0F1" class="headerlink" title="方式1"></a>方式1</h3><p>自定义线程池：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The values have been hard-coded for brevity</span></span><br><span class="line">  ExecutorService pool = <span class="keyword">new</span> CustomThreadPoolExecutor(</span><br><span class="line">      <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... Constructor ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CustomThreadPoolExecutor</span><span class="params">(</span><br><span class="line">      <span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">      TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Exception occurred, forward to handler</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... Perform task-specific cleanup actions</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.terminated();</span><br><span class="line">    <span class="comment">// ... Perform final clean-up actions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u65B9_u5F0F2"><a href="#u65B9_u5F0F2" class="headerlink" title="方式2"></a>方式2</h3><p>实现Thread.UncaughtExceptionHandler接口，实现<code>void uncaughtException(Thread t, Throwable e);</code>方法，并将该handler传递给线程池的ThreadFactory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory factory =</span><br><span class="line">      <span class="keyword">new</span> ExceptionThreadFactory(<span class="keyword">new</span> MyExceptionHandler());</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService pool =</span><br><span class="line">      Executors.newFixedThreadPool(<span class="number">10</span>, factory);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Task()); <span class="comment">// Task is a runnable class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory defaultFactory =</span><br><span class="line">        Executors.defaultThreadFactory();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread.UncaughtExceptionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExceptionThreadFactory</span><span class="params">(</span><br><span class="line">        Thread.UncaughtExceptionHandler handler)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable run)</span> </span>&#123;</span><br><span class="line">      Thread thread = defaultFactory.newThread(run);</span><br><span class="line">      thread.setUncaughtExceptionHandler(handler);</span><br><span class="line">      <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ExceptionReporter</span></span><br><span class="line">      <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Recovery or logging code</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u65B9_u5F0F3"><a href="#u65B9_u5F0F3" class="headerlink" title="方式3"></a>方式3</h3><p>继承ThreadGroup，覆盖其uncaughtException方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadGroup</span> <span class="keyword">extends</span> <span class="title">ThreadGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThreadGroup</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable throwable)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + thread.getName()</span><br><span class="line">              + <span class="string">" died, exception was: "</span>);</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadGroup workerThreads =</span><br><span class="line">      <span class="keyword">new</span> MyThreadGroup(<span class="string">"Worker Threads"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(workerThreads, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> WorkerThread(<span class="string">"Worker Thread"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>确实这种方式与上面通过ThreadFactory来指定UncaughtExceptionHandler是一样的，只是代码逻辑不同，但原理上都是一样的，即给线程池中的每个线程都指定一个UncaughtExceptionHandler。</p>
<p><strong> 注意：上面三种方式针对的都是通过execute(xx)的方式提交任务，如果你提交任务用的是submit()方法，那么上面的三种方式都将不起作用,而应该使用下面的方式 </strong></p>
<h3 id="u65B9_u5F0F4"><a href="#u65B9_u5F0F4" class="headerlink" title="方式4"></a>方式4</h3><p>如果提交任务的时候使用的方法是submit，那么该方法将返回一个Future对象，所有的异常以及处理结果都可以通过future对象获取。<br>采用Future模式，将返回结果以及异常放到Future中，在Future中处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Future&lt;?&gt; future = pool.submit(<span class="keyword">new</span> Task());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      future.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt(); <span class="comment">// Reset interrupted status</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      Throwable exception = e.getCause();</span><br><span class="line">      <span class="comment">// Forward to exception reporter</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ol>
<li>java线程池会捕获任务抛出的异常和错误，但不做任何处理</li>
<li>好的程序设计应该考虑到对于类异常的处理</li>
<li>处理线程池中的异常有两种思路：<br>1）提交到线程池中的任务自己捕获异常并处理，不抛给线程池<br>2）由线程池统一处理</li>
<li>对于execute方法提交的线程，有两种处理方式<br>1）自定义线程池并实现afterExecute方法<br>2）给线程池中的每个线程指定一个UncaughtExceptionHandler,由handler来统一处理异常。</li>
<li>对于submit方法提交的任务，异常处理是通过返回的Future对象进行的。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[假设我们有一个线程池，由于程序需要，我们向该线程池中提交了好多任务，但是这些任务都没有对异常进行try catch处理，并且运行的时候都抛出了异常。这会对线程池的运行带来什么影响？]]>
    
    </summary>
    
      <category term="java" scheme="http://blog.onlycatch.com/tags/java/"/>
    
      <category term="多线程" scheme="http://blog.onlycatch.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://blog.onlycatch.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="编程" scheme="http://blog.onlycatch.com/categories/coding/"/>
    
  </entry>
  
</feed>
